{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/ngw-map/src/decorators.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/utils/appendNgwResources.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/utils/prepareWebMapOptions.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/NgwMap.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/loadJsonBrowser.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/loadJsonNode.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/getLayerFilterOptions.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createGeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/createPopupContent.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/getLayerAdapterOptions.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createRasterAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerItem.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwResource.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createAsyncAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createWebMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/identifyUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwKit.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/loadJson.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/template.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/NgwConnector.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/index.ts"],"names":["onMapLoad","decorators","onLoad","appendNgwResources","options","resource","defOptions","overwriteOptions","Number","push","resourceId","Array","isArray","id","OPTIONS","target","baseUrl","controls","controlsOptions","ZOOM","position","ATTRIBUTION","customAttribution","pixelRadius","mapAdapter","kits","connector","auth","opt","identification","starterKits","runtimeParams","prepareWebMapOptions","emitter","_ngwLayers","_createWebMap","then","container","getContainer","classList","add","_addControls","fit","center","zoom","bounds","this","setCenter","setZoom","fitBounds","addControl","controlDef","addNgwLayer","keyname","Error","adapter","utils","addLayer","visibility","adapterOptions","layer","getLayerId","baseLayer","getActiveBaseLayer","console","error","getNgwLayerItem","getNgwLayerItems","getNgwLayerFeature","getNgwLayerFeatures","getIdentifyGeoJson","identify","multiple","getNgwLayers","getNgwLayerByResourceId","mem","n","getIdentificationIds","ids","some","x","getDependLayers","dependLayers","dependFit","find","item","parentId","zoomToLayer","layerDef","String","ngwLayer","getExtent","extent","get","getNgwResourceExtent","event","removeLayer","getLayer","layerId","enableSelection","__selectFromNgwRaster","ev","_selectFromNgwRaster","__selectFromNgwVector","_selectFromNgwVector","on","disableSelection","off","undefined","_isFitFromResource","params","_initMapState","create","qmsId","qmsLayerName","qmsLayerOptions","addBaseLayer","showLayer","resources","layerFitAllowed","webmapId","forEach","r","_emitStatusEvent","controlAdapterName","controlOptions","control","feature","featureId","identifyFeature","fields","properties","label","parent","geom","geometry","featureCount","features","sourceType","nl","promises","selectable","Promise","all","getIds","y","length","getCenter","getZoom","metresPerPixel","Math","abs","cos","PI","pow","radius","sendIdentifyRequest","layers","resp","fixUrlStr","deepmerge","getIcon","loadJSONBrowser","url","callback","onCancel","method","xhr","XMLHttpRequest","open","responseType","processingResponce","forError","cb","response","responseText","JSON","parse","er","message","onreadystatechange","readyState","status","statusText","onerror","upload","onprogress","e","lengthComputable","percentComplete","loaded","total","onProgress","data","headers","h","header","setRequestHeader","withCredentials","file","FormData","append","d","stringify","abort","send","eval","http","https","adapterFor","inputUrl","protocol","loadJSONNode","resolve","reject","chunk","err","catch","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","type","fid","idFilterWorkAround","value","filterById","featureIds","split","map","getNgwLayerItemsRequest","limit","intersects","orderBy","paramList","join","order_by","filters","createFeatureFieldFilterQueries","_queries","_parentAllParams","logic","filters_","filter","createParam","pf","f","itemsParts","items","reduce","a","b","concat","splice","resourceIdFromLayerOptions","getResourceByKeyname","resourceItem","filterOptionsKeys","getLayerFilterOptions","filterOptions","createGeoJsonAdapter","webMap","layerAdapters","GEOJSON","_fullDataLoad","popupOptions","fromProperties","createPopupContent","element","feature_layer","grid_visibility","innerHTML","display_name","p","geoJsonAdapterCb","_lastFilterArgs","_dataPromise","removed","cancel","opt_","vector_layer","vectorLayerGeomToPaintTypeAlias","geometry_type","Object","keys","strategy","propertiesFilter","updateLayer","_addBboxEventListener","beforeRemove","_removeMoveEventListener","_removeBboxEventListener","__disableMapMoveListener","__enableMapMoveListener","__onMapMove","filterArgs","_getMapBbox","setLayerData","emit","setData","clearLayer","removeFilter","isLayerVisible","_addMoveEventListener","getBounds","s","w","getLayerAdapterOptions","getLayerAdapters","isImageAllowed","IMAGE","updateWmsParams","updateImageParams","format","version","simplification","log","createRasterAdapter","resourceCls","clsAdapterAlias","wmsserver_service","terrain_provider","adapterClass","_options","layerAdapterOptions","tileAdapterOptions","addOptions","WebMapLayerItem","_rootDescendantsCount","tree","setParent","item_type","_sumUp","children","root","getRoot","initProperties","_init","initItem","newLayer","_layer","i","reverse","addChild","layer_adapter","toUpperCase","maxZoom","layer_max_scale_denom","_mapScaleToZoomLevel","minZoom","layer_min_scale_denom","minScale","maxScale","order","subOrder","drawOrderEnabled","draw_order_position","layer_enabled","property","set","transparency","layer_transparency","opacity","setLayerOpacity","bringToFront","scale","setScaleRatio","totalValue","child","name","getProperty","onSet","hideLayer","_getWebMapLayerItem","_getWebMapIds","_webmapLayersIds","$$onMapClick","_onMapClick","webmap","getWebMapExtent","getDescendants","visibleLayers","sort","visible","isBlocked","getWebMapConfig","root_item","getAuthorizationHeaders","draw_order_enabled","_updateItemsParams","layer_style_id","webMapItem","promise","_sendIdentifyRequest","_extent","styles","createAdapterFromFirstStyle","childrenStyles","firstStyle","createAsyncAdapter","adapterType","createWebMapAdapter","indexOf","cls","parentOptions","basemap_layer","qms","createQmsAdapter","prototype","resourceAdapter","derivedCtor","baseCtor","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","defineProperty","bbox","size","width","height","timestamp","Date","now","POINT","LINESTRING","POLYGON","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","POINTZ","LINESTRINGZ","POLYGONZ","MULTIPOINTZ","MULTILINESTRINGZ","MULTIPOLYGONZ","bottom","left","top","right","getNgwLayerExtent","maxLat","maxLon","minLat","minLon","res","_pixelsInMeter","d2r","r2d","degrees2meters","lng","lat","tan","points","rlat","rlng","extp","theta","ex","ey","sin","getCirclePoly","latLng","polygon","post","pixelsInMeterWidth","div","document","createElement","style","cssText","body","appendChild","px","offsetWidth","removeChild","centerLat","LN2","getZoomFromScale","getMapWidthForLanInMeters","round","getIdentifyGeoJsonParams","paramsList","l","isNaN","sortingArr","fry","layerFeatures","withGeom","onLoadSync","resourceIds","_getLayerAdapter","createAdapter","_createAdapter","loadJSON","isBrowser","Function","default","templateRe","template","str","replace","key","routeStr","_loadingQueue","_loadingStatus","_keynames","route","setNextGisWeb","logout","connect","login","password","getUserInfo","makeQuery","credentials","_rejectLoadingQueue","user","client","makeClientId","Authorization","window","btoa","unescape","encodeURIComponent","getResourceChildren","request","apiItems","apiItem","shift","replaceParams","arg","nocache","patch","put","delete","_getJson","_executeLoadingQueue","_setLoadingQueue","waiting","q","isError","queue","wait"],"mappings":"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","file":"main~2d9f1139-d4afa11.js","sourcesContent":["import WebMap from '@nextgis/webmap';\nimport { NgwMapEvents } from './interfaces';\n\n/**\n * Decorator to run action only after map is created\n */\nexport function onMapLoad() {\n  return WebMap.decorators.onLoad<NgwMapEvents>('build-map');\n}\n","import { NgwResourceDefinition, NgwLayerOptions } from '../interfaces';\nimport { NgwLayerOptionsAdditional } from '@nextgis/ngw-kit';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: NgwLayerOptionsAdditional,\n  overwriteOptions?: NgwLayerOptionsAdditional\n) {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resourceId: resource\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({ ...defOptions, resourceId, id, ...overwriteOptions });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n","import { deepmerge } from '@nextgis/utils';\nimport { MapAdapter, StarterKit } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport QmsKit from '@nextgis/qms-kit';\nimport NgwKit from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from '../interfaces';\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"http://nextgis.ru\" target=\"_blank\">Â©NextGIS</a>'\n      ]\n    }\n  },\n  pixelRadius: 10\n};\n\nexport function prepareWebMapOptions(\n  mapAdapter: MapAdapter,\n  options: NgwMapOptions\n) {\n  const kits: StarterKit[] = [new QmsKit()];\n\n  if (!options.connector) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl || '',\n      auth: options.auth\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  const opt: NgwMapOptions = deepmerge(OPTIONS, options);\n  if (opt.connector) {\n    kits.push(\n      new NgwKit({\n        connector: opt.connector,\n        auth: opt.auth,\n        identification: opt.identification\n      })\n    );\n  }\n  return {\n    mapAdapter,\n    starterKits: kits,\n    runtimeParams: options.runtimeParams\n  };\n}\n","/**\n * @module ngw-map\n */\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { fixUrlStr, deepmerge } from '@nextgis/utils';\nimport WebMap, {\n  MapAdapter,\n  ControlPositions,\n  MapControls,\n  WebMapEvents,\n  LayerDef,\n  MapClickEvent,\n  LayerAdapter,\n  PropertiesFilter,\n  FilterOptions,\n  OnLayerClickOptions\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureItem,\n  FeatureLayersIdentifyItems,\n  LayerFeature\n} from '@nextgis/ngw-connector';\nimport { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport NgwKit, {\n  NgwLayerOptions,\n  ResourceAdapter,\n  WebMapLayerItem,\n  NgwLayerOptionsAdditional,\n  NgwIdentify,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions,\n  ResourceNgwLayerOptions\n} from '@nextgis/ngw-kit';\nimport { getIcon } from '@nextgis/icons';\n\nimport { onMapLoad } from './decorators';\nimport { appendNgwResources } from './utils/appendNgwResources';\nimport { prepareWebMapOptions, OPTIONS } from './utils/prepareWebMapOptions';\n\nimport {\n  NgwMapOptions,\n  ControlOptions,\n  NgwMapEvents,\n  NgwLayers\n} from './interfaces';\nimport { Geometry, Feature, FeatureCollection } from 'geojson';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import NgwMap from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap(new MapAdapter(), {\n *   target: 'map',\n *   qmsId: 487,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<M = any, L = any, C = any, O = {}> extends WebMap<\n  M,\n  L,\n  C,\n  NgwMapEvents\n> {\n  static utils = {\n    ...WebMap.utils,\n    ...NgwKit.utils,\n    fixUrlStr,\n    deepmerge\n  };\n  static decorators = { onMapLoad, ...WebMap.decorators };\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwMapEvents\n  > = new EventEmitter();\n\n  options: NgwMapOptions<C> & O = {} as NgwMapOptions<C> & O;\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private __selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private __selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n\n  /**\n   * @param mapAdapter #noapi\n   * @param options\n   */\n  constructor(mapAdapter: MapAdapter, options: NgwMapOptions<C> & O) {\n    super(prepareWebMapOptions(mapAdapter, options));\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this.options = deepmerge(OPTIONS, options);\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      this._addControls();\n    });\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit() {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param [options] - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  @WebMap.decorators.onLoad<NgwMapEvents>('controls:create')\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPositions,\n    options?: MapControls[K]\n  ) {\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource id.\n   * @param options - set layer identification parameters and render method.\n   * @param [adapterOptions] - parameters for the selected adapter\n   *\n   * @example\n   * ```javascript\n   * var ngwMap = new NgwMap({ baseUrl: 'https://demo.nextgis.com', target: 'map' });\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resourceId: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resourceId: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  @onMapLoad()\n  async addNgwLayer(\n    options: NgwLayerOptions\n  ): Promise<ResourceAdapter | undefined> {\n    const keyname = (options as KeynamedNgwLayerOptions).keyname;\n    const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n    const resource = (options as ResourceNgwLayerOptions).resource;\n    if (!keyname && !resourceId && !resource) {\n      throw new Error(\n        'resourceId or keyname is required parameter to add NGW layer'\n      );\n    }\n    if (this.options.baseUrl || this.options.baseUrl === '') {\n      try {\n        const adapter = NgwKit.utils.addNgwLayer(\n          options,\n          this,\n          this.options.baseUrl,\n          this.connector\n        );\n\n        const layer = (await this.addLayer(adapter, {\n          visibility: true,\n          // TODO: all options into one object\n          ...options,\n          ...options.adapterOptions\n        })) as ResourceAdapter;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n\n          if (layer.options.baseLayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n\n        return layer;\n      } catch (er) {\n        console.error(\"can't add ngw layer\", er);\n      }\n    }\n  }\n\n  async getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return NgwKit.utils.getNgwLayerItem({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureItem[]> {\n    return NgwKit.utils.getNgwLayerItems({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeature<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return NgwKit.utils.getNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return NgwKit.utils.getNgwLayerFeatures({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false\n  ): CancelablePromise<Feature | undefined> {\n    return NgwKit.utils.getIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple\n    });\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some(x => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as WebMapLayerItem[];\n        const dependFit = dependLayers.find(x => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   * @param layerDef\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.zoomToLayer(ngwLayer);\n   * ngwMap.zoomToLayer('ngw_layer_name');\n   * ```\n   */\n  async zoomToLayer(layerDef: string | ResourceAdapter) {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent);\n        }\n      } else {\n        let item: ResourceItem;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.get('resource.item', null, {\n            id: resourceId\n          });\n        }\n\n        NgwKit.utils.getNgwResourceExtent(item, this.connector).then(extent => {\n          if (extent) {\n            this.fitBounds(extent);\n          }\n        });\n      }\n    }\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection() {\n    if (!this.__selectFromNgwRaster) {\n      this.__selectFromNgwRaster = (ev: MapClickEvent) =>\n        this._selectFromNgwRaster(ev);\n      this.__selectFromNgwVector = (ev: OnLayerClickOptions) =>\n        this._selectFromNgwVector(ev);\n      this.emitter.on('click', this.__selectFromNgwRaster);\n      this.emitter.on('layer:click', this.__selectFromNgwVector);\n    }\n  }\n\n  disableSelection() {\n    if (this.__selectFromNgwRaster) {\n      this.emitter.off('click', this.__selectFromNgwRaster);\n      this.emitter.off('click', this._selectFromNgwVector);\n      this.__selectFromNgwRaster = undefined;\n      this.__selectFromNgwVector = undefined;\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create({ ...this.options });\n    if (this.options.qmsId) {\n      let qmsId: number;\n      let qmsLayerName: string | undefined;\n      if (Array.isArray(this.options.qmsId)) {\n        qmsId = this.options.qmsId[0];\n        qmsLayerName = this.options.qmsId[1];\n      } else {\n        qmsId = Number(this.options.qmsId);\n      }\n      const qmsLayerOptions: QmsAdapterOptions = {\n        qmsId\n      };\n      if (qmsLayerName) {\n        qmsLayerOptions.id = qmsLayerName;\n      }\n\n      this.addBaseLayer('QMS', qmsLayerOptions).then(layer => {\n        this.showLayer(layer);\n      });\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach(x => {\n        const overwriteOptions = {} as NgwLayerOptionsAdditional;\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n\n    for (const r of resources) {\n      await this.addNgwLayer(r);\n    }\n\n    this._emitStatusEvent('ngw-map:create', this);\n\n    this.enableSelection();\n  }\n\n  private _addControls() {\n    if (this.options.controls) {\n      this.options.controls.forEach(x => {\n        let controlAdapterName = x;\n        let controlOptions: ControlOptions = {};\n        if (typeof x === 'string' && this.options.controlsOptions) {\n          if (this.options.controlsOptions[x]) {\n            controlOptions = this.options.controlsOptions[x];\n            if (controlOptions.control !== undefined) {\n              controlAdapterName = controlOptions.control;\n            }\n          }\n        }\n        const { position, ...options } = controlOptions;\n        this.addControl(controlAdapterName, position || 'top-left', options);\n      });\n    }\n    this._emitStatusEvent('controls:create');\n  }\n\n  private async _selectFromNgwVector(\n    ev: OnLayerClickOptions\n  ): Promise<FeatureLayersIdentify | undefined> {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties,\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature]\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items\n        };\n        this._emitStatusEvent('ngw:select', {\n          ...identify,\n          resources: [id],\n          sourceType: 'vector'\n        });\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    for (const nl in this._ngwLayers) {\n      const layer = this._ngwLayers[nl].layer;\n      if (layer.getIdentificationIds && layer.options.selectable) {\n        promises.push(layer.getIdentificationIds());\n      }\n    }\n    const getIds = await Promise.all(promises);\n    const ids: number[] = [];\n    getIds.forEach(x => {\n      if (x) {\n        x.forEach(y => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    const zoom = this.getZoom();\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const metresPerPixel =\n      (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n      Math.pow(2, zoom + 8);\n    // FIXME: understand the circle creation function\n    const radius = pixelRadius * metresPerPixel * 0.0005;\n    return NgwKit.utils\n      .sendIdentifyRequest(ev, {\n        layers: ids,\n        connector: this.connector,\n        radius\n      })\n      .then(resp => {\n        this._emitStatusEvent('ngw:select', {\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev\n        });\n        return resp;\n      });\n  }\n}\n","/**\n * @module ngw-map\n */\n\nimport { NgwMap } from './NgwMap';\n\nexport * from '@nextgis/webmap';\nexport * from './interfaces';\n\nexport { NgwMap };\nexport default NgwMap;\n","import { RequestOptions } from '../interfaces';\n\nexport default function loadJSONBrowser(\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions = {},\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) {\n  options.method = options.method || 'GET';\n\n  const xhr = new XMLHttpRequest();\n  xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n  if (options.responseType === 'blob') {\n    xhr.responseType = options.responseType;\n  }\n\n  const processingResponce = (forError = false) => {\n    const cb = forError ? error : callback;\n    if (options.responseType === 'blob') {\n      cb(xhr.response);\n    } else {\n      if (xhr.responseText) {\n        try {\n          cb(JSON.parse(xhr.responseText));\n        } catch (er) {\n          cb(xhr.responseText);\n        }\n      } else {\n        error({ message: '' });\n      }\n    }\n  };\n\n  xhr.onreadystatechange = () => {\n    if (\n      (xhr.readyState === 4 && xhr.status === 200) ||\n      (xhr.readyState === 3 && xhr.status === 201)\n    ) {\n      processingResponce();\n    } else if (xhr.readyState === 3 && xhr.status === 400) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 500) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 401) {\n      error(xhr.statusText);\n    } else if (xhr.readyState === 4) {\n      error('request error');\n    }\n  };\n\n  xhr.onerror = er => {\n    error(er);\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      const percentComplete = (e.loaded / e.total) * 100;\n      if (options.onProgress) {\n        options.onProgress(percentComplete);\n      }\n      // console.log(percentComplete + '% uploaded');\n    }\n  };\n\n  const headers = options.headers;\n  if (headers) {\n    for (const h in headers) {\n      const header = headers[h];\n      if (typeof header === 'string') {\n        xhr.setRequestHeader(h, header);\n      }\n    }\n  }\n  if (options.withCredentials !== undefined) {\n    xhr.withCredentials = options.withCredentials;\n  }\n\n  let data: FormData | any;\n  if (options.file) {\n    data = new FormData();\n    data.append('file', options.file);\n    if (options.data) {\n      for (const d in data) {\n        data.append(d, data[d]);\n      }\n    }\n  } else {\n    data = options.data\n      ? typeof options.data === 'string'\n        ? options.data\n        : JSON.stringify(options.data)\n      : null;\n  }\n  if (onCancel) {\n    onCancel.push(() => {\n      xhr.abort();\n    });\n  }\n  xhr.send(data);\n}\n","import { RequestOptions, RequestMethods } from '../interfaces';\n\n// the 'eval' is used to exclude packages from the webpack bundle for browser\nconst url = eval('require(\"url\")');\nconst http = eval('require(\"http\")');\nconst https = eval('require(\"https\")');\n\nconst adapterFor = (inputUrl: string) => {\n  const adapters: Record<string, any> = {\n    'http:': http,\n    'https:': https\n  };\n  return adapters[url.parse(inputUrl).protocol];\n};\n\nexport default function loadJSONNode(\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) {\n  const request = new Promise((resolve, reject) => {\n    adapterFor(url)\n      .get(url, (resp: any) => {\n        let data = '';\n        resp.on('data', (chunk: any) => {\n          data += chunk;\n        });\n        resp.on('end', () => {\n          resolve(JSON.parse(data));\n        });\n      })\n      .on('error', (err: any) => {\n        reject(err);\n      });\n  });\n  return request\n    .then(data => {\n      if (callback) {\n        callback(data);\n      }\n      return data;\n    })\n    .catch(er => {\n      if (error) {\n        error(er);\n      }\n      throw new Error(er);\n    });\n}\n","import { Geometry, Feature, FeatureCollection } from 'geojson';\nimport {\n  PropertiesFilter,\n  FilterOptions,\n  PropertyFilter\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  FeatureItem,\n  RequestItemAdditionalParams\n} from '@nextgis/ngw-connector';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport {\n  propertiesFilter,\n  checkIfPropertyFilter\n} from '@nextgis/properties-filter';\n\nexport interface FeatureRequestParams {\n  srs?: number;\n  fields?: string;\n  geom_format?: string;\n  limit?: number;\n  intersects?: string;\n  order_by?: string;\n}\n\nexport interface GetNgwLayerItemsOptions {\n  resourceId: number;\n  connector: NgwConnector;\n  filters?: PropertiesFilter;\n}\n\nconst FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson'\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry\n  };\n  return feature;\n}\n\nexport function getNgwLayerItem<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<FeatureItem> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  return options.connector.get('feature_layer.feature.item', null, {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params\n  });\n}\n\nexport function getNgwLayerFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<Feature<G, P>> {\n  return getNgwLayerItem(options).then(item => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n\nfunction idFilterWorkAround<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(options: { filterById: any; resourceId: number; connector: NgwConnector }) {\n  const value = options.filterById[2];\n  const featureIds: number[] =\n    typeof value === 'number'\n      ? [value]\n      : value.split(',').map((x: string) => Number(x));\n  if (options.filterById[1] !== 'eq' && options.filterById[1] !== 'in') {\n    throw new Error(\n      'Unable to filter by object id. Except `eq` or `in` operator'\n    );\n  }\n  const promises: Promise<FeatureItem>[] = featureIds.map(featureId => {\n    return getNgwLayerItem<G, P>({\n      connector: options.connector,\n      resourceId: options.resourceId,\n      featureId\n    });\n  });\n  return CancelablePromise.all(promises);\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nfunction createFeatureFieldFilterQueries(\n  opt: Required<GetNgwLayerItemsOptions> & FilterOptions,\n  _queries: CancelablePromise<FeatureItem[]>[] = [],\n  _parentAllParams: [string, any][] = []\n): CancelablePromise<FeatureItem[]> {\n  const { filters, connector, resourceId } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter(x => Array.isArray(x)) as PropertyFilter[];\n\n  const createParam = (pf: PropertyFilter): [string, any] => {\n    const [field, operation, value] = pf;\n    return [`fld_${field}__${operation}`, value];\n  };\n\n  if (logic === 'any') {\n    filters_.forEach(f => {\n      if (f[0] === 'id') {\n        _queries.push(\n          idFilterWorkAround({ filterById: f, connector, resourceId })\n        );\n      }\n      if (checkIfPropertyFilter(f)) {\n        _queries.push(\n          getNgwLayerItemsRequest({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)]\n          })\n        );\n      } else {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: f\n          },\n          _queries,\n          [..._parentAllParams]\n        );\n      }\n    });\n  } else if (logic === 'all') {\n    const filterById = filters_.find(x => x[0] === 'id');\n    if (filterById) {\n      _queries.push(idFilterWorkAround({ filterById, connector, resourceId }));\n    } else {\n      const filters: [string, any][] = [];\n      const propertiesFilterList: PropertiesFilter[] = [];\n      filters_.forEach(f => {\n        if (checkIfPropertyFilter(f)) {\n          filters.push(createParam(f));\n        } else {\n          propertiesFilterList.push(f);\n        }\n      });\n\n      if (propertiesFilterList.length) {\n        propertiesFilterList.forEach(x => {\n          createFeatureFieldFilterQueries(\n            {\n              ...opt,\n              filters: x\n            },\n            _queries,\n            [..._parentAllParams, ...filters]\n          );\n        });\n      } else {\n        _queries.push(\n          getNgwLayerItemsRequest({\n            ...opt,\n            paramList: [..._parentAllParams, ...filters]\n          })\n        );\n      }\n    }\n  }\n\n  return CancelablePromise.all(_queries).then((itemsParts: FeatureItem[][]) => {\n    const items = itemsParts.reduce((a, b) => a.concat(b), []);\n    if (opt.limit) {\n      return items.splice(0, opt.limit);\n    }\n    return items;\n  });\n}\n\nfunction getNgwLayerItemsRequest<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: GetNgwLayerItemsOptions &\n    FilterOptions & { paramList?: [string, any][] }\n): CancelablePromise<FeatureItem[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  const {\n    connector,\n    limit,\n    fields,\n    intersects,\n    orderBy,\n    resourceId,\n    paramList\n  } = options;\n  if (limit) {\n    params.limit = limit;\n  }\n  if (fields) {\n    params.fields = fields.join();\n  }\n  if (intersects) {\n    params.intersects = intersects;\n  }\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  if (orderBy) {\n    params.order_by = orderBy.join(',');\n  }\n  return connector.get('feature_layer.feature.collection', null, {\n    id: resourceId,\n    ...params\n  });\n}\n\nexport function getNgwLayerItems<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: GetNgwLayerItemsOptions & FilterOptions\n): CancelablePromise<FeatureItem[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({ ...options, filters });\n  } else {\n    return getNgwLayerItemsRequest(options).then(data => {\n      if (filters) {\n        // control\n        return data.filter(y => {\n          const fields = y.fields;\n          if (fields) {\n            propertiesFilter(fields, filters);\n          }\n        });\n      }\n      return data;\n    });\n  }\n}\n\nexport function getNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & FilterOptions\n): CancelablePromise<FeatureCollection<G, P>> {\n  return getNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach(y => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features\n    };\n    return featureCollection;\n  });\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport {\n  NgwLayerOptions,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions,\n  ResourceNgwLayerOptions\n} from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector\n) {\n  const resource = (options as ResourceNgwLayerOptions).resource;\n  let keyname = (options as KeynamedNgwLayerOptions).keyname;\n  let resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else {\n      resourceId = await resourceIdFromLayerOptions(resource, connector);\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResourceByKeyname(keyname);\n    resourceId = resourceItem.resource.id;\n  }\n  return resourceId;\n}\n","import { FilterOptions, GeoJsonAdapterOptions } from '@nextgis/webmap';\n\nconst filterOptionsKeys: (keyof FilterOptions)[] = [\n  'fields',\n  'intersects',\n  'limit',\n  'orderBy',\n  'strategy'\n];\n\nexport function getLayerFilterOptions(\n  options: GeoJsonAdapterOptions\n): FilterOptions {\n  const filterOptions: Record<string, any> = {};\n  filterOptionsKeys.forEach(x => {\n    const opt = options[x];\n    if (opt !== undefined) {\n      filterOptions[x] = opt;\n    }\n  });\n  return filterOptions as FilterOptions;\n}\n","import { EventEmitter } from 'events';\nimport WebMap, {\n  VectorLayerAdapter,\n  Type,\n  GeoJsonAdapterOptions,\n  PropertiesFilter,\n  FilterOptions\n} from '@nextgis/webmap';\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { debounce } from '@nextgis/utils';\nimport NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { NgwLayerOptions } from './interfaces';\nimport { getNgwLayerFeatures } from './utils/featureLayerUtils';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\nimport { degrees2meters, vectorLayerGeomToPaintTypeAlias } from './utils/utils';\nimport { createPopupContent } from './utils/createPopupContent';\nimport { getLayerFilterOptions } from './utils/getLayerFilterOptions';\n\ninterface FilterArgs {\n  filters?: PropertiesFilter;\n  options?: FilterOptions;\n}\n\nexport async function createGeoJsonAdapter(\n  options: NgwLayerOptions<'GEOJSON'>,\n  webMap: WebMap,\n  connector: NgwConnector,\n  item?: ResourceItem\n) {\n  const adapter = webMap.mapAdapter.layerAdapters.GEOJSON as Type<\n    VectorLayerAdapter\n  >;\n\n  let _dataPromise: CancelablePromise<any> | undefined;\n  const _fullDataLoad = false;\n  let _lastFilterArgs: FilterArgs | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  if (options.adapterOptions?.popupOptions?.fromProperties) {\n    options.adapterOptions.popupOptions.createPopupContent = ({ feature }) => {\n      return feature && createPopupContent(feature, item);\n    };\n  }\n\n  const geoJsonAdapterCb = async (\n    filters?: PropertiesFilter,\n    opt?: FilterOptions\n  ) => {\n    abort();\n    _lastFilterArgs = { filters, options: opt };\n    _dataPromise = getNgwLayerFeatures({\n      resourceId,\n      filters,\n      connector,\n      ...opt\n    });\n    return await _dataPromise;\n  };\n  let removed = false;\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  return class Adapter extends adapter {\n    emitter = new EventEmitter();\n    __onMapMove?: () => void;\n    __enableMapMoveListener?: () => void;\n    __disableMapMoveListener?: () => void;\n\n    async addLayer(opt_: GeoJsonAdapterOptions) {\n      if (options.id !== undefined) {\n        opt_.id = options.id;\n      }\n      if (item && item.vector_layer) {\n        opt_.type =\n          vectorLayerGeomToPaintTypeAlias[item.vector_layer.geometry_type];\n      }\n      if (opt_.data && Object.keys(opt_.data).length === 0) {\n        opt_.data = undefined;\n      }\n      const layer = super.addLayer(opt_);\n      this.options.strategy = opt_.strategy || undefined;\n\n      _lastFilterArgs = {\n        filters: opt_.propertiesFilter,\n        options: getLayerFilterOptions(opt_)\n      };\n      if (!opt_.data) {\n        this.updateLayer();\n      }\n      if (this.options.strategy === 'BBOX') {\n        this._addBboxEventListener();\n      }\n      return layer;\n    }\n\n    beforeRemove() {\n      removed = true;\n      this._removeMoveEventListener();\n      this._removeBboxEventListener();\n      this.__disableMapMoveListener = undefined;\n      this.__enableMapMoveListener = undefined;\n      this.__onMapMove = undefined;\n      abort();\n    }\n\n    async updateLayer(filterArgs?: FilterArgs) {\n      filterArgs = filterArgs || _lastFilterArgs || {};\n      if (this.options.strategy === 'BBOX') {\n        await webMap.onLoad();\n        filterArgs.options = filterArgs.options || {};\n        filterArgs.options.intersects = this._getMapBbox();\n      }\n      if (removed) {\n        return;\n      }\n      const data = await geoJsonAdapterCb(\n        filterArgs.filters,\n        filterArgs.options\n      );\n      webMap.setLayerData(this, data);\n      this.emitter.emit('updated');\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter(e => {\n          if (e.feature && e.feature.properties) {\n            return WebMap.utils.propertiesFilter(e.feature.properties, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await geoJsonAdapterCb(filters, opt);\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(() => {\n          return true;\n        });\n      }\n    }\n\n    _addBboxEventListener() {\n      this.__enableMapMoveListener = () => {\n        this._removeMoveEventListener();\n        if (webMap.isLayerVisible(this)) {\n          this.updateLayer();\n          this._addMoveEventListener();\n        }\n      };\n      this.__disableMapMoveListener = () => {\n        if (!webMap.isLayerVisible(this)) {\n          this._removeMoveEventListener();\n        }\n      };\n      webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      this.__enableMapMoveListener();\n    }\n\n    _removeBboxEventListener() {\n      if (this.__enableMapMoveListener) {\n        webMap.emitter.on('layer:show', this.__enableMapMoveListener);\n      }\n      if (this.__disableMapMoveListener) {\n        webMap.emitter.on('layer:hide', this.__disableMapMoveListener);\n      }\n    }\n\n    _addMoveEventListener() {\n      this.__onMapMove = debounce(() => this.updateLayer());\n      webMap.emitter.on('moveend', this.__onMapMove);\n    }\n\n    _removeMoveEventListener() {\n      if (this.__onMapMove) {\n        webMap.emitter.off('moveend', this.__onMapMove);\n      }\n    }\n\n    _getMapBbox(): string | undefined {\n      const bounds = webMap.getBounds();\n      if (bounds) {\n        const [s, w, n, e] = bounds;\n        const polygon = [\n          [s, w],\n          [n, w],\n          [n, e],\n          [s, e],\n          [s, w]\n        ].map(([lng, lat]) => {\n          const [x, y] = degrees2meters(lng, lat);\n          return x + ' ' + y;\n        });\n        return `POLYGON((${polygon.join(', ')}))`;\n      }\n    }\n  };\n}\n","import { Feature } from 'geojson';\nimport { ResourceItem } from '@nextgis/ngw-connector';\nimport { create } from '@nextgis/dom';\n\nexport function createPopupContent(\n  feature: Feature,\n  item?: ResourceItem\n): HTMLElement | string {\n  const element = create('div');\n  if (item) {\n    item.feature_layer?.fields.forEach(x => {\n      if (x.grid_visibility) {\n        const value = feature.properties && feature.properties[x.keyname];\n        if (value) {\n          const propElem = create('div', null, element);\n          propElem.innerHTML = `<span>${x.display_name}</span>: ${value}<span></span>`;\n        }\n      }\n    });\n  } else if (feature.properties) {\n    for (const p in feature.properties) {\n      const propElem = create('div', null, element);\n      propElem.innerHTML = `<span>${p}</span>: ${feature.properties[p]}<span></span>`;\n    }\n  }\n\n  return element;\n}\n","import WebMap from '@nextgis/webmap';\n\nimport { NgwLayerOptions, ResourceIdNgwLayerOptions } from '../interfaces';\nimport { updateImageParams } from './utils';\n\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string\n) {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n\n  if (resourceId) {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          updateWmsParams: (params: any) =>\n            updateImageParams(params, resourceId)\n        };\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'WMS') {\n      url = `${baseUrl}/api/resource/${resourceId}/wms`;\n      return {\n        url,\n        format: 'image/png',\n        version: '1.1.1',\n        layers: options.layers,\n        headers: options.headers\n      };\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url\n      };\n    }\n    if (adapter === 'TERRAIN') {\n      url = baseUrl + `/api/resource/${resourceId}/terrain_provider`;\n      // `/api/resource/${resourceId}/terrain_provider/{z}/{x}/{y}.terrain`;\n      return { url, adapter };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId;\n      return { url, adapter };\n    }\n  } else {\n    console.log('Options `resourceId` not set');\n  }\n}\n","import {\n  NgwLayerOptions,\n  ResourceAdapter,\n  NgwLayerAdapterType\n} from './interfaces';\nimport WebMap, {\n  BaseLayerAdapter,\n  Type,\n  ImageAdapterOptions,\n  TileAdapterOptions\n} from '@nextgis/webmap';\nimport { getLayerAdapterOptions } from './utils/getLayerAdapterOptions';\nimport NgwConnector, {\n  ResourceItem,\n  ResourceCls\n} from '@nextgis/ngw-connector';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createRasterAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector,\n  resourceCls?: ResourceCls\n): Promise<Type<BaseLayerAdapter> | undefined> {\n  const clsAdapterAlias: { [key in ResourceCls]?: NgwLayerAdapterType } = {\n    wmsserver_service: 'WMS',\n    terrain_provider: 'TERRAIN'\n  };\n  let adapter =\n    options.adapter || (resourceCls && clsAdapterAlias[resourceCls]) || 'IMAGE';\n  if (adapter !== undefined) {\n    options.adapter = adapter;\n  }\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n\n  const adapterClass = webMap.mapAdapter.layerAdapters[adapter] as Type<\n    BaseLayerAdapter\n  >;\n  if (adapterClass) {\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    return class Adapter extends adapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = getLayerAdapterOptions(options, webMap, baseUrl);\n        if (opt) {\n          if (opt.resourceId) {\n            const layerAdapterOptions: ImageAdapterOptions = {\n              ...opt,\n              layers: String(opt.resourceId),\n              resourceId: opt.resourceId\n            };\n            this.options = { ...this.options, ...layerAdapterOptions };\n          } else {\n            const tileAdapterOptions: TileAdapterOptions = opt;\n            this.options = { ...this.options, ...tileAdapterOptions };\n          }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (id) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport Item, { ItemOptions } from '@nextgis/item';\n\nimport WebMap, { LayerAdaptersOptions, LayerAdapter } from '@nextgis/webmap';\nimport { TreeGroup, TreeLayer } from './interfaces';\nimport { setScaleRatio } from './utils/utils';\n\nexport class WebMapLayerItem extends Item<ItemOptions> {\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: WebMapLayerItem) {\n          if (item) {\n            if (item.item.item_type === 'group') {\n              return true;\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            } else if (item.item.item_type === 'root') {\n              return true;\n            }\n          }\n          return false;\n        },\n        onSet(value: boolean, options?: any, item?: WebMapLayerItem) {\n          if (item && item.layer && item.item.item_type === 'layer') {\n            if (value) {\n              item.webMap.showLayer(item.layer);\n            } else {\n              item.webMap.hideLayer(item.layer);\n            }\n            item.item['layer_enabled'] = value;\n          }\n        }\n      }\n    ]\n  };\n\n  item: TreeGroup | TreeLayer;\n  layer?: LayerAdapter;\n\n  _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    parent?: WebMapLayerItem\n  ) {\n    super({ ...WebMapLayerItem.options, ...options });\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n\n    this.initProperties();\n    this._init(item);\n  }\n\n  async initItem(item: TreeGroup | TreeLayer) {\n    let newLayer = item._layer;\n    const i = item;\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        item.children.reverse().forEach(x => {\n          const children = new WebMapLayerItem(\n            this.webMap,\n            x,\n            this.options,\n            this\n          );\n          this.tree.addChild(children);\n        });\n      }\n    } else if (item.item_type === 'layer') {\n      const adapter = (item.adapter ||\n        item.layer_adapter.toUpperCase()) as keyof LayerAdaptersOptions;\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      const options: any = {\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n        ...item,\n        headers: this.options.headers\n      };\n      if (this.options.order) {\n        const subOrder = this.options.drawOrderEnabled\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n        options.order = Number((this.options.order | 0) + '.' + subOrder);\n      }\n      newLayer = await this.webMap.addLayer(adapter, options);\n    }\n    if (newLayer) {\n      i._layer = newLayer;\n      this.layer = newLayer;\n      if (this.properties && item.item_type === 'layer' && item.layer_enabled) {\n        this.properties.property('visibility').set(true);\n      }\n      const transparency =\n        item.item_type === 'layer' && item.layer_transparency;\n      if (typeof transparency === 'number') {\n        const opacity = (100 - transparency) / 100;\n        this.webMap.setLayerOpacity(newLayer, opacity);\n      }\n    } else {\n      // this.properties.get('visibility').set(true);\n    }\n  }\n\n  bringToFront() {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      console.log(this.item);\n    }\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private async _init(item: TreeGroup | TreeLayer) {\n    await this.initItem(item);\n    this.emitter.emit('init');\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import WebMap, { LngLatBoundsArray, MapClickEvent } from '@nextgis/webmap';\nimport { ResourceItem } from '@nextgis/ngw-connector';\nimport CancelablePromise from '@nextgis/cancelable-promise';\n\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  getLayerAdapterOptions,\n  updateImageParams,\n  sendIdentifyRequest,\n  getWebMapExtent\n} from './utils/utils';\nimport { WebMapLayerItem } from './WebMapLayerItem';\nimport { ItemOptions } from '@nextgis/item';\n\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport {\n  TreeGroup,\n  TreeLayer,\n  NgwLayerAdapterType,\n  WebMapAdapterOptions,\n  WebMapLayerAdapterEvents,\n  ResourceAdapter\n} from './interfaces';\n\nexport class WebMapLayerAdapter implements ResourceAdapter {\n  layer?: WebMapLayerItem;\n\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    WebMapLayerAdapterEvents\n  > = new EventEmitter();\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  private $$onMapClick?: (ev: MapClickEvent) => void;\n\n  constructor(public map: any, public options: WebMapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: WebMapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n\n    this.layer = await this._getWebMapLayerItem();\n\n    if (this.options.identification) {\n      const ids = await this._getWebMapIds();\n      if (ids) {\n        this._webmapLayersIds = ids;\n        this.$$onMapClick = (ev: MapClickEvent) => this._onMapClick(ev);\n        this.options.webMap.emitter.on('click', this.$$onMapClick);\n      }\n    }\n    return this.layer;\n  }\n\n  removeLayer() {\n    const mapAdapter = this.options.webMap.mapAdapter;\n    if (this.$$onMapClick) {\n      this.options.webMap.emitter.off('click', this.$$onMapClick);\n    }\n    this.getDependLayers().forEach(x => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    this.$$onMapClick = undefined;\n    delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getWebMapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<WebMapLayerItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  async getIdentificationIds() {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => a.id - b.id);\n      deps.forEach(x => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  private async _getWebMapLayerItem(): Promise<WebMapLayerItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<WebMapLayerItem>(resolve => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.order = this.options.order;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new WebMapLayerItem(\n            this.options.webMap,\n            webmap.root_item,\n            options\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    try {\n      const data = await this.options.connector.get('resource.item', null, {\n        id\n      });\n      this.response = data;\n      const webmap = data.webmap;\n      if (webmap) {\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    } catch (er) {\n      throw er;\n    }\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map(x =>\n            this._updateItemsParams(x, webMap, data)\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.baseUrl + '/api/component/render/image'\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = params => updateImageParams(params, resourceId);\n        item = {\n          ...item,\n          ...getLayerAdapterOptions(\n            {\n              adapter: item.layer_adapter.toUpperCase() as NgwLayerAdapterType,\n              resourceId\n            },\n            webMap,\n            this.options.baseUrl\n          )\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: WebMapLayerItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector\n            .get('resource.item', {}, { id })\n            .then(y => {\n              if (y) {\n                const parentId = Number(y.resource.parent.id);\n                item.parentId = parentId;\n                return parentId;\n              }\n            });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter(x => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n\n  private _sendIdentifyRequest(ev: MapClickEvent) {\n    if (this._webmapLayersIds) {\n      return sendIdentifyRequest(ev, {\n        layers: this._webmapLayersIds,\n        connector: this.options.connector,\n        radius: this.pixelRadius\n      }).then(resp => {\n        this.emitter.emit('identify', { ev, data: resp });\n        return resp;\n      });\n    }\n  }\n\n  private _onMapClick(ev: MapClickEvent) {\n    this._sendIdentifyRequest(ev);\n  }\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { getNgwResourceExtent } from './utils/utils';\nimport { LngLatBoundsArray } from '@nextgis/webmap';\n\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  private _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await getNgwResourceExtent(\n        this.item,\n        this.connector\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem\n} from '@nextgis/ngw-connector';\nimport WebMap, { LayerAdapter, Type } from '@nextgis/webmap';\nimport QmsKit from '@nextgis/qms-kit';\nimport { ResourceAdapter, NgwLayerOptions } from './interfaces';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createWebMapAdapter';\nimport { applyMixins } from './utils/utils';\nimport { NgwResource } from './NgwResource';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nconst styles: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'wmsserver_service',\n  'raster_style',\n  'terrain_provider'\n];\n\nasync function createAdapterFromFirstStyle(\n  parent: number,\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n) {\n  const childrenStyles = await connector.get('resource.collection', null, {\n    parent\n  });\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...options, resourceId: firstStyle.resource.id },\n      webMap,\n      baseUrl,\n      connector\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: Promise<Type<LayerAdapter> | undefined> | undefined;\n  let item: ResourceItem | undefined;\n  try {\n    const adapterType = options.adapter;\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    if (resourceId) {\n      item = await connector.get('resource.item', null, { id: resourceId });\n\n      if (item) {\n        const _options: NgwLayerOptions = { ...options, resourceId };\n        if (item.webmap) {\n          adapter = createWebMapAdapter(_options, webMap, baseUrl, connector);\n        } else if (styles.indexOf(item.resource.cls) !== -1) {\n          if (adapterType === 'GEOJSON') {\n            const parentOptions: NgwLayerOptions = {\n              ...options,\n              resourceId: item.resource.parent.id\n            };\n            adapter = createGeoJsonAdapter(\n              parentOptions as NgwLayerOptions<'GEOJSON'>,\n              webMap,\n              connector,\n              item\n            );\n          } else {\n            adapter = createRasterAdapter(\n              _options,\n              webMap,\n              baseUrl,\n              connector,\n              item.resource.cls\n            );\n          }\n        } else if (item.resource.cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(\n                _options,\n                webMap,\n                baseUrl,\n                connector,\n                item.resource.cls\n              );\n            } else {\n              return createAdapterFromFirstStyle(\n                item.resource.id,\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            }\n          } else {\n            adapter = createGeoJsonAdapter(\n              _options as NgwLayerOptions<'GEOJSON'>,\n              webMap,\n              connector,\n              item\n            );\n          }\n        } else if (item.resource.cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(\n            item.resource.id,\n            _options,\n            webMap,\n            baseUrl,\n            connector\n          );\n        } else if (item.basemap_layer && item.basemap_layer.qms) {\n          adapter = Promise.resolve(QmsKit.utils.createQmsAdapter(webMap));\n          adapter.then(x => {\n            if (x && item && item.basemap_layer && item.basemap_layer.qms) {\n              const qms = JSON.parse(item.basemap_layer.qms);\n              x.prototype.qms = qms;\n              x.prototype.baseLayer = true;\n            }\n          });\n        }\n      } else {\n        throw new Error(\n          \"Can't add NGW layer because Resource item is not found\"\n        );\n      }\n    }\n  } catch (er) {\n    // if (options.adapter === 'GEOJSON') {\n    //   adapter = createGeoJsonAdapter(options, webMap, connector);\n    // } else {\n    //   adapter = createRasterAdapter(options, webMap, baseUrl);\n    // }\n  }\n  if (adapter) {\n    return adapter.then(x => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        resourceAdapter.prototype.item = item;\n        resourceAdapter.prototype.resourceId = item?.resource.id;\n        resourceAdapter.prototype.connector = connector;\n\n        applyMixins(resourceAdapter, [NgwResource]);\n\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, { Type } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createWebMapAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<WebMapLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class Adapter extends WebMapLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        webMap,\n        resourceId,\n        baseUrl,\n        connector\n      });\n    }\n  };\n}\n","import WebMap, {\n  Type,\n  LngLatBoundsArray,\n  MapClickEvent,\n  VectorAdapterLayerType\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  WebmapResource,\n  ResourceItem,\n  FeatureLayersIdentify,\n  GeometryType\n} from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../createAsyncAdapter';\nimport {\n  NgwLayerOptions,\n  WebMapAdapterOptions,\n  IdentifyRequestOptions,\n  ResourceAdapter\n} from '../interfaces';\nimport { WebMapLayerAdapter } from '../WebMapLayerAdapter';\nimport { getLayerAdapterOptions as getLayerAdapterOptions_ } from './getLayerAdapterOptions';\n\nexport function updateImageParams(params: any, resourceId: number) {\n  const { bbox, width, height } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now()\n  };\n}\n\nexport const vectorLayerGeomToPaintTypeAlias: Record<\n  GeometryType,\n  VectorAdapterLayerType\n> = {\n  POINT: 'circle',\n  LINESTRING: 'line',\n  POLYGON: 'fill',\n  MULTIPOINT: 'circle',\n  MULTILINESTRING: 'line',\n  MULTIPOLYGON: 'fill',\n  POINTZ: 'circle',\n  LINESTRINGZ: 'line',\n  POLYGONZ: 'fill',\n  MULTIPOINTZ: 'circle',\n  MULTILINESTRINGZ: 'line',\n  MULTIPOLYGONZ: 'fill'\n};\n\n/** @deprecated */\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string\n) {\n  return getLayerAdapterOptions_(options, webMap, baseUrl);\n}\n\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, baseUrl, connector);\n}\n\nexport function getWebMapExtent(\n  webmap: WebmapResource\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function getNgwLayerExtent(\n  id: number,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  return connector.get('layer.extent', name, { id }).then(resp => {\n    if (resp) {\n      const { maxLat, maxLon, minLat, minLon } = resp.extent;\n      const extenrArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n      return extenrArray;\n    }\n  });\n}\n\nexport async function getNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return getWebMapExtent(item.webmap);\n  } else {\n    const resource = item.resource;\n    if (resource.cls.indexOf('style') !== -1) {\n      return connector\n        .get('resource.item', null, {\n          id: resource.parent.id\n        })\n        .then(res => {\n          return getNgwLayerExtent(res.resource.id, connector);\n        });\n    } else {\n      return getNgwLayerExtent(resource.id, connector);\n    }\n  }\n}\n\ninterface FeatureIdentifyRequestOptions {\n  /**\n   * WKT Polygon geometry\n   */\n  geom: string;\n  srs: 3857;\n  layers: number[];\n}\n\nconst d2r = Math.PI / 180; // degrees to radians\nconst r2d = 180 / Math.PI; // radians to degrees\nconst earthsradius = 3963; // 3963 is the radius of the earth in miles\n\nexport function getCirclePoly(\n  lng: number,\n  lat: number,\n  radius = 10,\n  points = 6\n) {\n  // find the radius in lat/lon\n  const rlat = (radius / earthsradius) * r2d;\n  const rlng = rlat / Math.cos(lat * d2r);\n\n  const extp = [];\n  for (let i = 0; i < points + 1; i++) {\n    // one extra here makes sure we connect the\n\n    const theta = Math.PI * (i / (points / 2));\n    const ex = lng + rlng * Math.cos(theta); // center a + radius x * cos(theta)\n    const ey = lat + rlat * Math.sin(theta); // center b + radius y * sin(theta)\n    extp.push([ex, ey]);\n  }\n\n  // add the circle to the map\n  return extp;\n}\n\nexport function degrees2meters(lng: number, lat: number): [number, number] {\n  lat = lat > 85.06 ? 85.06 : lat < -85.06 ? -85.06 : lat;\n\n  const x = (lng * 20037508.34) / 180;\n  let y = Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);\n  y = (y * 20037508.34) / 180;\n  return [x, y];\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions\n  // webMap: WebMap\n): Promise<FeatureLayersIdentify> {\n  // webMap.emitter.emit('start-identify', { ev });\n  const geom = getCirclePoly(ev.latLng.lng, ev.latLng.lat, options.radius);\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  // webMap.addLayer('GEOJSON', {\n  //   visibility: true,\n  //   data: {\n  //     type: 'Feature',\n  //     geometry: {\n  //       type: 'Polygon',\n  //       coordinates: [geom]\n  //     }\n  //   }\n  // })\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\ninterface ExtendWebMapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendWebMapLayerAdapter(\n  opt: ExtendWebMapLayerAdapterOptions\n): Type<WebMapLayerAdapter> {\n  class A extends WebMapLayerAdapter {\n    constructor(map: any, options: WebMapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth() {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        baseCtor.prototype,\n        name\n      );\n      if (descriptor) {\n        Object.defineProperty(derivedCtor.prototype, name, descriptor);\n      }\n    });\n  });\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number) {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 104) {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n  if (lat) {\n    const centerLat = lat;\n    const crsScale =\n      (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n    const zoom = getZoomFromScale(crsScale);\n    return zoom;\n  }\n  return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import { LayerFeature } from '@nextgis/ngw-connector';\nimport { getNgwLayerFeature, createGeoJsonFeature } from './featureLayerUtils';\nimport { GetIdentifyGeoJsonOptions, NgwIdentify } from '../interfaces';\nimport { Geometry } from 'geojson';\n\nexport function getIdentifyGeoJsonParams(\n  identify: NgwIdentify,\n  multiple = false\n) {\n  let params: { resourceId: number; featureId: number } | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort(function(a, b) {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const layerFeatures = identify[l].features;\n    const resourceId = Number(l);\n    const f: LayerFeature | undefined = layerFeatures[0];\n    if (f) {\n      params = {\n        featureId: f.id,\n        resourceId\n      };\n      paramsList.push(params);\n      if (!multiple) {\n        break;\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function getIdentifyGeoJson(options: GetIdentifyGeoJsonOptions) {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      const withGeom = item.features.find(x => x.geom);\n\n      if (withGeom && withGeom.geom) {\n        const geom = withGeom.geom as Geometry;\n        return createGeoJsonFeature({\n          ...withGeom,\n          geom\n        });\n      }\n    }\n  }\n\n  const params = getIdentifyGeoJsonParams(identify);\n  if (params) {\n    return getNgwLayerFeature({ connector, ...params[0] });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport WebMap, { StarterKit, Type } from '@nextgis/webmap';\nimport {\n  getNgwResourceExtent,\n  sendIdentifyRequest,\n  pixelsInMeterWidth,\n  updateImageParams,\n  getLayerAdapterOptions,\n  addNgwLayer,\n  extendWebMapLayerAdapter,\n  setScaleRatio\n} from './utils/utils';\n\nimport {\n  getIdentifyGeoJson,\n  getIdentifyGeoJsonParams\n} from './utils/identifyUtils';\n\nimport {\n  getNgwLayerItems,\n  getNgwLayerItem,\n  getNgwLayerFeatures,\n  getNgwLayerFeature,\n  createGeoJsonFeature\n} from './utils/featureLayerUtils';\n\nimport { NgwKitOptions, WebMapAdapterOptions } from './interfaces';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\n\nexport class NgwKit implements StarterKit {\n  static utils = {\n    addNgwLayer,\n    getNgwResourceExtent,\n    sendIdentifyRequest,\n    pixelsInMeterWidth,\n    getNgwLayerFeature,\n    getNgwLayerFeatures,\n    getNgwLayerItems,\n    getNgwLayerItem,\n    getIdentifyGeoJson,\n    getIdentifyGeoJsonParams,\n    createGeoJsonFeature,\n    setScaleRatio\n  };\n\n  static updateWmsParams = updateImageParams;\n\n  static getLayerAdapterOptions = getLayerAdapterOptions;\n\n  static addNgwLayer = addNgwLayer;\n\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl;\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth\n      });\n    }\n  }\n\n  async onLoadSync(webMap: WebMap) {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: WebMapAdapterOptions = {\n            resourceId: r,\n            connector: this.connector,\n            baseUrl: this.url,\n            webMap\n          };\n          const layer = (await webMap.addLayer(WebMapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            identification: this.options.identification,\n            pixelRadius: this.options.pixelRadius,\n            ...options\n          })) as WebMapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap))\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<WebMapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendWebMapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl\n    });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport { NgwKit } from './NgwKit';\n\nexport * from './interfaces';\nexport * from './WebMapLayerAdapter';\nexport * from './WebMapLayerItem';\n\nexport { NgwKit };\nexport default NgwKit;\n","// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\nimport { RequestOptions, RequestMethods } from '../interfaces';\n\ntype LoadJSON = (\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) => void;\n\nlet loadJSON: LoadJSON;\n\nconst isBrowser = new Function(\n  'try {return this===window;}catch(e){ return false;}'\n)();\nif (isBrowser) {\n  loadJSON = require('./loadJsonBrowser').default;\n} else {\n  loadJSON = require('./loadJsonNode').default;\n}\nexport { loadJSON };\n","// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }) {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","/**\n * @module ngw-connector\n */\nimport CancelablePromise from '@nextgis/cancelable-promise';\nimport { EventEmitter } from 'events';\n\nimport { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport {\n  NgwConnectorOptions,\n  Router,\n  GetRequestItemsResponseMap,\n  RequestOptions,\n  Params,\n  LoadingQueue,\n  UserInfo,\n  Credentials,\n  PyramidRoute,\n  RequestHeaders,\n  PostRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  RequestItemKeys,\n  DeleteRequestItemsResponseMap,\n  PutRequestItemsResponseMap,\n  RequestItemsParams\n} from './interfaces';\nimport { loadJSON } from './utils/loadJson';\nimport { template } from './utils/template';\nimport { ResourceItem } from './types/ResourceItem';\n\nexport class NgwConnector {\n  emitter = new EventEmitter();\n  user?: UserInfo;\n  private routeStr = '/api/component/pyramid/route';\n  private route?: PyramidRoute;\n  private _loadingQueue: { [name: string]: LoadingQueue } = {};\n  private _loadingStatus: { [url: string]: boolean } = {};\n  private _keynames: Record<string, ResourceItem> = {};\n\n  constructor(public options: NgwConnectorOptions) {\n    if (this.options.route) {\n      this.routeStr = this.options.route;\n    }\n  }\n\n  setNextGisWeb(url: string) {\n    this.logout();\n    this.options.baseUrl = url;\n  }\n\n  async connect(): CancelablePromise<Router> {\n    if (this.route) {\n      return Promise.resolve(this.route);\n    } else {\n      if (this.options.auth) {\n        const { login, password } = this.options.auth;\n        if (login && password) {\n          await this.getUserInfo({ login, password });\n        }\n      }\n\n      return await this.makeQuery(this.routeStr, {}, {}).then(\n        (route: PyramidRoute) => {\n          this.route = route;\n          return route;\n        }\n      );\n    }\n  }\n\n  async login(credentials: Credentials) {\n    this.logout();\n    return this.getUserInfo(credentials);\n  }\n\n  logout() {\n    this._rejectLoadingQueue();\n    this._loadingStatus = {};\n    this.options.auth = undefined;\n    this.route = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n  }\n\n  getUserInfo(credentials: Credentials): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials)\n      // withCredentials: true\n    };\n\n    // Do not use request('auth.current_user') to avoid circular-references\n    return this.makeQuery('/api/component/auth/current_user', {}, options)\n      .then((data: UserInfo) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch(er => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  getAuthorizationHeaders(\n    credentials?: Credentials\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials) {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      return window.btoa(unescape(encodeURIComponent(`${login}:${password}`)));\n    }\n  }\n\n  async getResourceByKeyname(keyname: string) {\n    let resource: ResourceItem = this._keynames['keyname'];\n    if (!resource) {\n      const resources = await this.get('resource.search', null, { keyname });\n      resource = resources[0];\n      if (resource) {\n        this._keynames[keyname] = resource;\n      }\n    }\n    return resource;\n  }\n\n  async getResourceChildren(opt: {\n    keyname?: string;\n    resourceId?: number;\n  }): Promise<ResourceItem[]> {\n    let parent = opt.resourceId;\n    if (!opt.keyname && !opt.resourceId) {\n      throw new Error('No keyname or resourceId is set');\n    }\n    if (opt.keyname) {\n      const item = await this.getResourceByKeyname(opt.keyname);\n      parent = item.resource.id;\n    }\n    return await this.get('resource.collection', null, {\n      parent\n    });\n  }\n\n  async request<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys\n  >(\n    name: K,\n    params: RequestItemsParams<K> = {},\n    options?: RequestOptions\n  ): CancelablePromise<P[K]> {\n    const apiItems = await this.connect();\n    let apiItem = apiItems && apiItems[name];\n    if (apiItem) {\n      apiItem = [...apiItem];\n      let url = apiItem.shift();\n      if (apiItem.length) {\n        const replaceParams: {\n          [num: number]: string;\n        } = {};\n        for (let fry = 0; fry < apiItem.length; fry++) {\n          const arg = apiItem[fry];\n          replaceParams[fry] = '{' + arg + '}';\n          if (params[arg] === undefined) {\n            throw new Error(\n              '`' + arg + '`' + ' url api argument is not specified'\n            );\n          }\n        }\n        if (url) {\n          url = template(url, replaceParams);\n        }\n      }\n      // Transfer part of the parameters from `params` to the URL string\n      if (params) {\n        const paramArray = [];\n        const paramList = params.paramList;\n        if (Array.isArray(paramList)) {\n          delete params.paramList;\n          paramList.forEach(x => {\n            paramArray.push(`${x[0]}=${x[1]}`);\n          });\n        }\n        for (const p in params) {\n          if (apiItem.indexOf(p) === -1) {\n            paramArray.push(`${p}=${params[p]}`);\n          }\n        }\n        if (paramArray.length) {\n          url = url + '?' + paramArray.join('&');\n        }\n      }\n      if (url) {\n        return this.makeQuery(url, params, options);\n      } else {\n        throw new Error('request url is not set');\n      }\n    }\n    return CancelablePromise.resolve({} as P[K]);\n  }\n\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    options.nocache = true;\n    return this.request<K, PostRequestItemsResponseMap>(name, params, options);\n  }\n\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    options.nocache = true;\n    return this.request<K, GetRequestItemsResponseMap>(name, params, options);\n  }\n\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    options.nocache = true;\n    return this.request<K, PatchRequestItemsResponseMap>(name, params, options);\n  }\n\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    options.nocache = true;\n    return this.request<K, PutRequestItemsResponseMap>(name, params, options);\n  }\n\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    options.nocache = true;\n    return this.request<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options\n    );\n  }\n\n  makeQuery(\n    url: string,\n    params?: Params,\n    options: RequestOptions = {}\n  ): CancelablePromise<any> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      // remove double slash\n      url = url.replace(/([^:]\\/)\\/+/g, '$1');\n      if (!this._loadingStatus[url] || options.nocache) {\n        this._loadingStatus[url] = true;\n\n        return this._getJson(url, options)\n          .then(data => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, data);\n            return data;\n          })\n          .catch(er => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, er, true);\n            this.emitter.emit('error', er);\n            throw er;\n          });\n      } else {\n        this._loadingStatus[url] = false;\n        return new CancelablePromise((resolve, reject) => {\n          this._setLoadingQueue(url, resolve, reject);\n        });\n      }\n    } else {\n      throw new Error('No `url` parameter set for option ' + name);\n    }\n  }\n\n  protected _setLoadingQueue(\n    name: string,\n    resolve: (...args: any[]) => any,\n    reject: (...args: any[]) => any\n  ) {\n    this._loadingQueue[name] = this._loadingQueue[name] || {\n      name,\n      waiting: []\n    };\n    this._loadingQueue[name].waiting.push({\n      resolve,\n      reject,\n      timestamp: new Date()\n    });\n  }\n\n  protected _rejectLoadingQueue() {\n    for (const q in this._loadingQueue) {\n      const queue = this._loadingQueue[q];\n      queue.waiting.forEach(x => {\n        x.reject();\n      });\n      delete this._loadingQueue[q];\n    }\n  }\n\n  protected _executeLoadingQueue(name: string, data: any, isError?: boolean) {\n    const queue = this._loadingQueue[name];\n    if (queue) {\n      for (let fry = 0; fry < queue.waiting.length; fry++) {\n        const wait = queue.waiting[fry];\n        if (isError) {\n          if (wait.reject) {\n            wait.reject();\n          }\n        } else {\n          wait.resolve(data);\n        }\n      }\n      queue.waiting = [];\n    }\n  }\n\n  protected _getJson(\n    url: string,\n    options: RequestOptions\n  ): CancelablePromise<any> {\n    const onCancel: (() => void)[] = [];\n    options.responseType = options.responseType || 'json';\n    return new CancelablePromise(\n      (resolve, reject) => {\n        if (this.user) {\n          options = options || {};\n          // options.withCredentials = true;\n          options.headers = {\n            ...this.getAuthorizationHeaders(),\n            ...options.headers\n          };\n        }\n        loadJSON(url, resolve, options, reject, onCancel);\n      },\n      () => {\n        onCancel.forEach(x => x());\n      }\n    );\n  }\n}\n","/**\n * @module ngw-connector\n */\n\nimport { NgwConnector } from './NgwConnector';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\n// for backward compatibility\n// TODO: safe remove backward compatibility\nimport CancelablePromise from '@nextgis/cancelable-promise';\nexport { CancelablePromise };\n\nexport { NgwConnector };\nexport default NgwConnector;\n"],"sourceRoot":""}