{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/qms-kit/src/utils/utils.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/utils/createQmsAdapter.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/QmsKit.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/utils/src/CancelablePromise.ts","webpack:///./nextgisweb_frontend/packages/utils/src/Clipboard.ts","webpack:///./nextgisweb_frontend/packages/utils/src/dom.ts","webpack:///./nextgisweb_frontend/packages/utils/src/events.ts","webpack:///./nextgisweb_frontend/packages/utils/src/propertiesFilter.ts","webpack:///./nextgisweb_frontend/packages/utils/src/sleep.ts","webpack:///./nextgisweb_frontend/packages/utils/src/applyMixins.ts","webpack:///./nextgisweb_frontend/packages/utils/src/deepmerge.ts","webpack:///./nextgisweb_frontend/packages/utils/src/debounce.ts","webpack:///./nextgisweb_frontend/packages/utils/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/decorators.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/NgwMap.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/loadJsonBrowser.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/loadJsonNode.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createGeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createRasterAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerItem.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwResource.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createAsyncAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createWebMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/identifyUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwKit.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/loadJson.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils/template.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/NgwConnector.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/index.ts"],"names":["alias","tms","loadJSON","url","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","JSON","parse","er","open","send","createQmsAdapter","webMap","map","options","this","baseLayer","addLayer","qms","qmsId","type","webMapAdapter","mapAdapter","layerAdapters","QmsAdapter","maxZoom","minZoom","protocol","location","replace","name","attribution","copyright_text","z_max","z_min","updateQmsOptions","getLayerAdapters","createAdapter","webmap","_createAdapter","utils","handleCallback","callback","r","e","executor","onCancel","_canceled","_promise","value","CancelablePromise","all","values","then","catch","onfulfilled","onrejected","p","cancel","undefined","errorCallback","_destroy","finally","onfinally","text","copy","navigator","clipboard","writeText","window","clipboardData","setData","copyToClipboard","console","log","input","document","createElement","body","appendChild","copyNodeContentsToClipboard","removeChild","select","setSelectionRange","execCommand","Clipboard","create","tagName","className","container","el","emitter","_eventsStatus","setEventStatus","event","onLoad","promises","Array","isArray","x","res","getEventStatus","once","_eventName","like","a","b","iLike","String","toUpperCase","re","RegExp","exec","operationsAliases","gt","lt","ge","le","eq","ne","in","indexOf","notin","ilike","checkIfPropertyFilter","filter","pf","length","featureFilter","feature","filters","properties","$id","id","propertiesFilter","logic","filterFunction","field","operation","operationExec","filters_","some","every","sleep","delay","setTimeout","mixinProperties","derivedCtor","baseCtor","forEach","descriptor","Object","getOwnPropertyDescriptor","prototype","defineProperty","deepmerge","target","src","mergeArray","array","dst","concat","i","push","keys","key","debounce","cb","wait","h","clearTimeout","args","fixUrlStr","onMapLoad","decorators","appendNgwResources","resource","defOptions","overwriteOptions","Number","resourceId","OPTIONS","baseUrl","controls","controlsOptions","ZOOM","position","ATTRIBUTION","customAttribution","pixelRadius","kits","connector","auth","opt","identification","starterKits","runtimeParams","prepareWebMapOptions","_ngwLayers","_createWebMap","getContainer","classList","add","_addControls","fit","center","zoom","bounds","setCenter","setZoom","fitBounds","addControl","controlDef","addNgwLayer","keyname","Error","adapter","visibility","adapterOptions","layer","getLayerId","getActiveBaseLayer","error","getNgwLayerItem","getNgwLayerItems","getNgwLayerFeature","getNgwLayerFeatures","getIdentifyGeoJson","identify","multiple","getNgwLayers","getNgwLayerByResourceId","mem","n","getIdentificationIds","ids","getDependLayers","dependLayers","dependFit","find","item","parentId","zoomToLayer","layerDef","ngwLayer","getExtent","extent","get","getNgwResourceExtent","removeLayer","getLayer","layerId","enableSelection","__selectFromNgwRaster","ev","_selectFromNgwRaster","__selectFromNgwVector","_selectFromNgwVector","on","disableSelection","off","_isFitFromResource","params","_initMapState","qmsLayerName","qmsLayerOptions","addBaseLayer","showLayer","resources","layerFitAllowed","webmapId","_emitStatusEvent","controlAdapterName","controlOptions","control","featureId","identifyFeature","fields","label","parent","geom","geometry","featureCount","features","sourceType","nl","selectable","getIds","y","getCenter","getZoom","metresPerPixel","Math","abs","cos","PI","pow","radius","sendIdentifyRequest","layers","resp","getIcon","loadJSONBrowser","method","xhr","responseType","processingResponce","forError","response","message","statusText","onerror","upload","onprogress","lengthComputable","percentComplete","loaded","total","onProgress","data","headers","header","setRequestHeader","withCredentials","file","FormData","append","d","stringify","abort","eval","http","https","adapterFor","inputUrl","loadJSONNode","chunk","err","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","fid","idFilterWorkAround","filterById","featureIds","split","getNgwLayerItemsRequest","limit","intersects","paramList","join","createFeatureFieldFilterQueries","_queries","_parentAllParams","createParam","f","itemsParts","items","reduce","splice","resourceIdFromLayerOptions","getResourceByKeyname","resourceItem","createGeoJsonAdapter","GEOJSON","_fullDataLoad","geoJsonAdapterCb","_lastFilterArgs","_dataPromise","geoJsonOptions","updateGeoJsonAdapterOptions","_opt","addLayerOptions","beforeRemove","updateLayer","clearLayer","removeFilter","createRasterAdapter","IMAGE","adapterClass","_options","getLayerAdapterOptions","layerAdapterOptions","tileAdapterOptions","addOptions","WebMapLayerItem","_rootDescendantsCount","tree","setParent","item_type","_sumUp","children","root","getRoot","initProperties","_init","initItem","newLayer","_layer","reverse","addChild","layer_adapter","layer_max_scale_denom","_mapScaleToZoomLevel","layer_min_scale_denom","minScale","maxScale","order","subOrder","drawOrderEnabled","draw_order_position","layer_enabled","property","set","transparency","layer_transparency","opacity","setLayerOpacity","bringToFront","scale","setScaleRatio","emit","totalValue","child","getProperty","onSet","hideLayer","_getWebMapLayerItem","_getWebMapIds","_webmapLayersIds","$$onMapClick","_onMapClick","getWebMapExtent","getDescendants","visibleLayers","sort","visible","isBlocked","getWebMapConfig","root_item","getAuthorizationHeaders","draw_order_enabled","_updateItemsParams","display_name","layer_style_id","updateWmsParams","webMapItem","promise","_sendIdentifyRequest","_extent","styles","createAdapterFromFirstStyle","childrenStyles","firstStyle","createAsyncAdapter","adapterType","createWebMapAdapter","cls","parentOptions","basemap_layer","resourceAdapter","getOwnPropertyNames","bbox","size","width","height","timestamp","Date","now","isImageAllowed","simplification","bottom","left","top","right","getNgwLayerExtent","maxLat","maxLon","minLat","minLon","_pixelsInMeter","d2r","r2d","lng","lat","points","rlat","rlng","extp","theta","ex","ey","sin","getCirclePoly","latLng","polygon","tan","post","pixelsInMeterWidth","div","style","cssText","px","offsetWidth","centerLat","LN2","getZoomFromScale","getMapWidthForLanInMeters","round","getIdentifyGeoJsonParams","paramsList","l","isNaN","sortingArr","fry","layerFeatures","withGeom","onLoadSync","resourceIds","_getLayerAdapter","isBrowser","Function","default","templateRe","template","str","s","routeStr","_loadingQueue","_loadingStatus","_keynames","route","setNextGisWeb","logout","connect","login","password","getUserInfo","makeQuery","credentials","_rejectLoadingQueue","user","client","makeClientId","Authorization","btoa","unescape","encodeURIComponent","getResourceChildren","request","apiItems","apiItem","shift","replaceParams","arg","nocache","patch","put","delete","_getJson","_executeLoadingQueue","_setLoadingQueue","waiting","q","isError","queue"],"mappings":"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","file":"main~640af231-65fc1e3.js","sourcesContent":["import { LayerAdaptersOptions, AdapterOptions } from '@nextgis/webmap';\nimport { fixUrlStr } from '@nextgis/utils';\nimport { QmsBasemap, QmsLayerType } from '../interfaces';\n\nexport const alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE'\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  const serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min\n  };\n}\n\nexport function loadJSON<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n","import { WebMap, BaseLayerAdapter } from '@nextgis/webmap';\nimport { Type, mixinProperties } from '@nextgis/utils';\nimport { QmsAdapterOptions, QmsBasemap, QmsAdapter as QA } from '../interfaces';\nimport { loadJSON, alias, updateQmsOptions } from './utils';\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = 'https://qms.nextgis.com'\n): Type<BaseLayerAdapter> {\n  class QmsAdapter<M = any> implements BaseLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      this.options = options;\n      this.options.baseLayer = true;\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        this.qms = await loadJSON<QmsBasemap>(\n          url + '/api/v1/geoservices/' + options.qmsId\n        );\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const webMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (webMapAdapter) {\n          mixinProperties(QmsAdapter, webMapAdapter, [\n            'showLayer',\n            'hideLayer'\n          ]);\n          if (type === 'TILE') {\n            options = {\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms)\n            };\n            this.options = options;\n            const adapter = new webMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","/**\n * @module qms-kit\n */\n\nimport WebMap, { StarterKit, Type, BaseLayerAdapter } from '@nextgis/webmap';\nimport { QmsOptions } from './interfaces';\nimport { createQmsAdapter } from './utils/createQmsAdapter';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com'\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap))\n      }\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<BaseLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n","/**\n * @module qms-kit\n */\n\nimport { QmsKit } from './QmsKit';\n\nexport * from './interfaces';\n\nexport { QmsKit };\nexport default QmsKit;\n","/**\n * @module ngw-utils\n */\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nexport class CancelablePromise<T> implements Promise<T> {\n  readonly [Symbol.toStringTag]: string;\n\n  private _canceled = false;\n\n  private _promise?: Promise<T>;\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void\n    ) => void,\n    private onCancel?: (...args: any[]) => void\n  ) {\n    this._promise = new Promise(executor);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise(resolve => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values)\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise(\n      (resolve, reject) => {\n        if (this._promise) {\n          this._promise.then(\n            r => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onfulfilled && !this._canceled) {\n                handleCallback(resolve, reject, onfulfilled, r);\n              } else {\n                resolve(r);\n              }\n            },\n            r => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onrejected && !this._canceled) {\n                handleCallback(resolve, reject, onrejected, r);\n              } else {\n                reject(r);\n              }\n            }\n          );\n        }\n      },\n      () => {\n        this.cancel();\n      }\n    );\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null\n  ): CancelablePromise<T | TResult> {\n    return this.then(undefined, onrejected);\n  }\n\n  cancel(errorCallback?: (...args: any[]) => void) {\n    this._canceled = true;\n    if (errorCallback && this._promise) {\n      this._promise.catch(errorCallback);\n    }\n    if (this.onCancel) {\n      this.onCancel();\n    }\n    this._destroy();\n    return this;\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  private _destroy() {\n    this.onCancel = undefined;\n    this._promise = undefined;\n  }\n}\n","export class Clipboard {\n  constructor(text: string) {\n    if (text) {\n      this.copy(text);\n    }\n  }\n\n  static copy = (text: string) => {\n    return new Clipboard(text);\n  };\n\n  copy(text: string) {\n    try {\n      if ((navigator as any).clipboard) {\n        (navigator as any).clipboard.writeText(text);\n      } else if ((window as any).clipboardData) {\n        (window as any).clipboardData.setData('text', text);\n      } else {\n        this.copyToClipboard(text);\n      }\n      console.log('Copied to Clipboard');\n    } catch (e) {\n      console.log('Please copy coupon manually');\n    }\n  }\n\n  private copyToClipboard(text: string) {\n    const input = document.createElement('input') as HTMLInputElement;\n    input.value = text;\n    try {\n      document.body.appendChild(input);\n      this.copyNodeContentsToClipboard(input);\n    } finally {\n      document.body.removeChild(input);\n    }\n  }\n\n  private copyNodeContentsToClipboard(input: HTMLInputElement) {\n    input.select();\n    input.setSelectionRange(0, 99999); /*For mobile devices*/\n    document.execCommand('copy');\n  }\n}\n","/**\n * @module utils\n */\nexport function create(\n  tagName: string,\n  className?: string,\n  container?: HTMLElement\n): HTMLElement {\n  const el = window.document.createElement(tagName);\n  if (className !== undefined) el.className = className;\n  if (container) container.appendChild(el);\n  return el;\n}\n","import { EventEmitter } from 'events';\n\nexport class Events<E = any> {\n  private readonly _eventsStatus: { [key in keyof E]?: boolean } = {};\n\n  constructor(private emitter: EventEmitter) {}\n\n  setEventStatus(event: keyof E, status: boolean) {\n    this._eventsStatus[event] = status;\n  }\n\n  onLoad(event: keyof E | (keyof E)[]): Promise<this> {\n    const events: (keyof E)[] = Array.isArray(event) ? event : [event];\n    const promises = events.map(\n      x =>\n        new Promise(res => {\n          if (this.getEventStatus(x)) {\n            res(this);\n          } else {\n            const e = x as string | symbol;\n            this.emitter.once(e, () => {\n              this.setEventStatus(x, true);\n              res(this);\n            });\n          }\n        })\n    );\n    return Promise.all(promises).then(() => this);\n  }\n\n  getEventStatus(event: keyof E): boolean {\n    // ugly hack to disable type checking error\n    const _eventName = event as keyof E;\n    const status = this._eventsStatus[_eventName];\n    return status !== undefined ? !!status : false;\n  }\n}\n","import { Feature, GeoJsonProperties } from 'geojson';\n\n/**\n * gt - greater (>)\n * lt - lower (<)\n * ge - greater or equal (>=)\n * le - lower or equal (<=)\n * eq - equal (=)\n * ne - not equal (!=)\n * like - LIKE SQL statement (for strings compare)\n * ilike - ILIKE SQL statement (for strings compare)\n */\nexport type Operations =\n  | 'gt'\n  | 'lt'\n  | 'ge'\n  | 'le'\n  | 'eq'\n  | 'ne'\n  | 'in'\n  | 'notin'\n  | 'like'\n  | 'ilike';\n\n/**\n * field, operation, value\n * ['foo', 'eq', 'bar']\n * ['count', 'ge', 20]\n */\nexport type PropertyFilter<T extends any = any> = [string, Operations, T];\n\nexport type PropertiesFilter<T extends any = any> = (\n  | 'all'\n  | 'any'\n  | PropertyFilter<T>\n  | PropertiesFilter<T>\n)[];\n\nfunction like(a: string, b: string, iLike?: boolean) {\n  a = String(a);\n  b = String(b);\n  if (a === b) return true;\n  if (iLike && a.toUpperCase() === b.toUpperCase()) return true;\n  const re = `^${a}$`.replace(/%/g, '.*').replace('_', '.');\n  return new RegExp(re, iLike ? 'i' : '').exec(b) !== null;\n}\n\nexport const operationsAliases: {\n  [key in Operations]: (a: any, b: any) => boolean;\n} = {\n  // greater(>)\n  gt: (a: any, b: any) => a > b,\n  // lower(<)\n  lt: (a: any, b: any) => a < b,\n  // greater or equal(>=)\n  ge: (a: any, b: any) => a >= b,\n  // lower or equal(<=)\n  le: (a: any, b: any) => a <= b,\n  // equal(=)\n  eq: (a: any, b: any) => a === b,\n  //  not equal(!=)\n  ne: (a: any, b: any) => a !== b,\n\n  in: (a: any, b: any[]) => b.indexOf(a) !== -1,\n  notin: (a: any, b: any[]) => b.indexOf(a) === -1,\n  // LIKE SQL statement(for strings compare)\n  like: (a: string, b: string) => {\n    return like(a, b);\n  },\n  // ILIKE SQL statement(for strings compare)\n  ilike: (a: string, b: string) => {\n    return like(a, b, true);\n  }\n};\n\nexport function checkIfPropertyFilter(\n  filter: PropertyFilter | PropertiesFilter | string\n): filter is PropertyFilter {\n  const pf = filter as PropertyFilter;\n  if (\n    pf.length === 3 &&\n    typeof pf[0] === 'string' &&\n    typeof pf[1] === 'string'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function featureFilter(feature: Feature, filters: PropertiesFilter) {\n  const properties: GeoJsonProperties = { ...feature.properties };\n  if (properties) {\n    // workaround to filter by feature id\n    properties.$id = feature.id;\n    return propertiesFilter(properties, filters);\n  }\n  return false;\n}\n\nexport function propertiesFilter(\n  properties: { [field: string]: any },\n  filters: PropertiesFilter\n): boolean {\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n  const filterFunction = (p: PropertyFilter | PropertiesFilter) => {\n    if (checkIfPropertyFilter(p)) {\n      const [field, operation, value] = p;\n      const operationExec = operationsAliases[operation];\n      if (operationExec) {\n        const property = properties[field];\n        return operationExec(property, value);\n      }\n      return true;\n    } else {\n      return propertiesFilter(properties, p);\n    }\n  };\n  const filters_ = filters.filter(x => Array.isArray(x)) as (\n    | PropertyFilter\n    | PropertiesFilter\n  )[];\n  return logic === 'any'\n    ? filters_.some(filterFunction)\n    : filters_.every(filterFunction);\n}\n","export function sleep(delay = 0): Promise<void> {\n  return new Promise<void>(resolve => setTimeout(resolve, delay));\n}\n","export function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        baseCtor.prototype,\n        name\n      );\n      if (descriptor) {\n        Object.defineProperty(derivedCtor.prototype, name, descriptor);\n      }\n    });\n  });\n}\n\nexport function mixinProperties(\n  derivedCtor: any,\n  baseCtor: any,\n  properties: string[]\n) {\n  properties.forEach(name => {\n    const descriptor = Object.getOwnPropertyDescriptor(\n      baseCtor.prototype,\n      name\n    );\n    if (descriptor) {\n      Object.defineProperty(derivedCtor.prototype, name, descriptor);\n    }\n  });\n}\n","export function deepmerge(target: any, src: any, mergeArray = false): any {\n  const array = Array.isArray(src);\n  let dst: any = (array && []) || {};\n\n  if (array) {\n    if (mergeArray) {\n      target = target || [];\n      dst = dst.concat(target);\n      src.forEach(function(e: any, i: any) {\n        if (typeof dst[i] === 'undefined') {\n          dst[i] = e;\n        } else if (typeof e === 'object') {\n          dst[i] = deepmerge(target[i], e, mergeArray);\n        } else {\n          if (target.indexOf(e) === -1) {\n            dst.push(e);\n          }\n        }\n      });\n    } else {\n      // Replace array. Do not merge by default\n      dst = src;\n    }\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(function(key) {\n        dst[key] = target[key];\n      });\n    }\n    Object.keys(src).forEach(function(key) {\n      if (typeof src[key] !== 'object' || !src[key]) {\n        dst[key] = src[key];\n      } else {\n        if (typeof target[key] === 'object' && typeof src[key] === 'object') {\n          dst[key] = deepmerge(target[key], src[key], mergeArray);\n        } else {\n          dst[key] = src[key];\n        }\n      }\n    });\n  }\n  return dst;\n}\n","export function debounce<T extends Function>(cb: T, wait = 10) {\n  let h = 0;\n  const callable = (...args: any) => {\n    clearTimeout(h);\n    h = window.setTimeout(() => cb(...args), wait);\n  };\n  return (callable as any) as T;\n}\n","/**\n * @module utils\n */\n\nexport * from './CancelablePromise';\nexport * from './Clipboard';\n\nimport * as Dom from './dom';\nexport const dom = Dom;\n\nexport * from './events';\nexport * from './array';\nexport * from './propertiesFilter';\nexport * from './sleep';\nexport * from './typeHelpers';\nexport * from './applyMixins';\nexport { deepmerge } from './deepmerge';\nexport { debounce } from './debounce';\n/**\n * Given an array of member function names as strings, replace all of them\n * with bound versions that will always refer to `context` as `this`. This\n * is useful for classes where otherwise event bindings would reassign\n * `this` to the evented object or some other value: this lets you ensure\n * the `this` value always.\n * Taken from: https://github.com/mapbox/mapbox-gl-js/blob/v1.0.0/src/util/util.js#L243\n */\nexport function bindAll(\n  fns: string[],\n  context: { [method: string]: (...args: any[]) => any }\n): void {\n  fns.forEach(fn => {\n    if (!context[fn]) {\n      return;\n    }\n    context[fn] = context[fn].bind(context);\n  });\n}\n\nexport function fixUrlStr(url: string): string {\n  // remove double slash\n  return url.replace(/([^:]\\/)\\/+/g, '$1');\n}\n","import WebMap from '@nextgis/webmap';\nimport { NgwMapEvents } from './interfaces';\n\n/**\n * Decorator to run action only after map is created\n */\nexport function onMapLoad() {\n  return WebMap.decorators.onLoad<NgwMapEvents>('build-map');\n}\n","import { NgwResourceDefinition, NgwLayerOptions } from './interfaces';\nimport { NgwLayerOptionsAdditional } from '@nextgis/ngw-kit';\n\nimport { deepmerge } from '@nextgis/utils';\nimport { MapAdapter, StarterKit } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport QmsKit from '@nextgis/qms-kit';\nimport NgwKit from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from './interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: NgwLayerOptionsAdditional,\n  overwriteOptions?: NgwLayerOptionsAdditional\n) {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resourceId: resource\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({ ...defOptions, resourceId, id, ...overwriteOptions });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"http://nextgis.ru\" target=\"_blank\">NextGIS</a>'\n      ]\n    }\n  },\n  pixelRadius: 10\n};\n\nexport function prepareWebMapOptions(\n  mapAdapter: MapAdapter,\n  options: NgwMapOptions\n) {\n  const kits: StarterKit[] = [new QmsKit()];\n\n  if (!options.connector && options.baseUrl) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl,\n      auth: options.auth\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  const opt: NgwMapOptions = deepmerge(OPTIONS, options);\n  if (opt.connector) {\n    kits.push(\n      new NgwKit({\n        connector: opt.connector,\n        auth: opt.auth,\n        identification: opt.identification\n      })\n    );\n  }\n  return {\n    mapAdapter,\n    starterKits: kits,\n    runtimeParams: options.runtimeParams\n  };\n}\n","/**\n * @module ngw-map\n */\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport { fixUrlStr, deepmerge, CancelablePromise } from '@nextgis/utils';\nimport WebMap, {\n  MapAdapter,\n  ControlPositions,\n  MapControls,\n  WebMapEvents,\n  LayerDef,\n  MapClickEvent,\n  LayerAdapter,\n  PropertiesFilter,\n  FilterOptions,\n  OnLayerClickOptions\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureItem,\n  FeatureLayersIdentifyItems,\n  LayerFeature\n} from '@nextgis/ngw-connector';\nimport { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport NgwKit, {\n  NgwLayerOptions,\n  ResourceAdapter,\n  WebMapLayerItem,\n  NgwLayerOptionsAdditional,\n  NgwIdentify,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions,\n  ResourceNgwLayerOptions\n} from '@nextgis/ngw-kit';\nimport { getIcon } from '@nextgis/icons';\n\nimport { onMapLoad } from './decorators';\nimport { appendNgwResources, prepareWebMapOptions, OPTIONS } from './utils';\n\nimport {\n  NgwMapOptions,\n  ControlOptions,\n  NgwMapEvents,\n  NgwLayers\n} from './interfaces';\nimport { Geometry, Feature, FeatureCollection } from 'geojson';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import NgwMap from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap(new MapAdapter(), {\n *   target: 'map',\n *   qmsId: 487,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<M = any, L = any, C = any, O = {}> extends WebMap<\n  M,\n  L,\n  C,\n  NgwMapEvents\n> {\n  static utils = {\n    ...WebMap.utils,\n    ...NgwKit.utils,\n    fixUrlStr,\n    deepmerge\n  };\n  static decorators = { onMapLoad, ...WebMap.decorators };\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwMapEvents\n  > = new EventEmitter();\n\n  options: NgwMapOptions<C> & O = {} as NgwMapOptions<C> & O;\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private __selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private __selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n\n  /**\n   * @param mapAdapter #noapi\n   * @param options\n   */\n  constructor(mapAdapter: MapAdapter, options: NgwMapOptions<C> & O) {\n    super(prepareWebMapOptions(mapAdapter, options));\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this.options = deepmerge(OPTIONS, options);\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      this._addControls();\n    });\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit() {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param [options] - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  @WebMap.decorators.onLoad<NgwMapEvents>('controls:create')\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPositions,\n    options?: MapControls[K]\n  ) {\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource id.\n   * @param options - set layer identification parameters and render method.\n   * @param [adapterOptions] - parameters for the selected adapter\n   *\n   * @example\n   * ```javascript\n   * var ngwMap = new NgwMap({ baseUrl: 'https://demo.nextgis.com', target: 'map' });\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resourceId: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resourceId: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  @onMapLoad()\n  async addNgwLayer(\n    options: NgwLayerOptions\n  ): Promise<ResourceAdapter | undefined> {\n    const keyname = (options as KeynamedNgwLayerOptions).keyname;\n    const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n    const resource = (options as ResourceNgwLayerOptions).resource;\n    if (!keyname && !resourceId && !resource) {\n      throw new Error(\n        'resourceId or keyname is required parameter to add NGW layer'\n      );\n    }\n    if (this.options.baseUrl || this.options.baseUrl === '') {\n      try {\n        const adapter = NgwKit.utils.addNgwLayer(\n          options,\n          this,\n          this.options.baseUrl,\n          this.connector\n        );\n\n        const layer = (await this.addLayer(adapter, {\n          visibility: true,\n          // TODO: all options into one object\n          ...options,\n          ...options.adapterOptions\n        })) as ResourceAdapter;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n\n          if (layer.options.baseLayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n\n        return layer;\n      } catch (er) {\n        console.error(\"can't add ngw layer\", er);\n      }\n    }\n  }\n\n  async getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return NgwKit.utils.getNgwLayerItem({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureItem[]> {\n    return NgwKit.utils.getNgwLayerItems({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeature<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return NgwKit.utils.getNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return NgwKit.utils.getNgwLayerFeatures({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false\n  ): CancelablePromise<Feature | undefined> {\n    return NgwKit.utils.getIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple\n    });\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some(x => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as WebMapLayerItem[];\n        const dependFit = dependLayers.find(x => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   * @param layerDef\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.zoomToLayer(ngwLayer);\n   * ngwMap.zoomToLayer('ngw_layer_name');\n   * ```\n   */\n  async zoomToLayer(layerDef: string | ResourceAdapter) {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent);\n        }\n      } else {\n        let item: ResourceItem;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.get('resource.item', null, {\n            id: resourceId\n          });\n        }\n\n        NgwKit.utils.getNgwResourceExtent(item, this.connector).then(extent => {\n          if (extent) {\n            this.fitBounds(extent);\n          }\n        });\n      }\n    }\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection() {\n    if (!this.__selectFromNgwRaster) {\n      this.__selectFromNgwRaster = (ev: MapClickEvent) =>\n        this._selectFromNgwRaster(ev);\n      this.__selectFromNgwVector = (ev: OnLayerClickOptions) =>\n        this._selectFromNgwVector(ev);\n      this.emitter.on('click', this.__selectFromNgwRaster);\n      this.emitter.on('layer:click', this.__selectFromNgwVector);\n    }\n  }\n\n  disableSelection() {\n    if (this.__selectFromNgwRaster) {\n      this.emitter.off('click', this.__selectFromNgwRaster);\n      this.emitter.off('click', this._selectFromNgwVector);\n      this.__selectFromNgwRaster = undefined;\n      this.__selectFromNgwVector = undefined;\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create({ ...this.options });\n    if (this.options.qmsId) {\n      let qmsId: number;\n      let qmsLayerName: string | undefined;\n      if (Array.isArray(this.options.qmsId)) {\n        qmsId = this.options.qmsId[0];\n        qmsLayerName = this.options.qmsId[1];\n      } else {\n        qmsId = Number(this.options.qmsId);\n      }\n      const qmsLayerOptions: QmsAdapterOptions = {\n        qmsId\n      };\n      if (qmsLayerName) {\n        qmsLayerOptions.id = qmsLayerName;\n      }\n\n      await this.addBaseLayer('QMS', qmsLayerOptions).then(layer => {\n        this.showLayer(layer);\n      });\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach(x => {\n        const overwriteOptions = {} as NgwLayerOptionsAdditional;\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n\n    for (const r of resources) {\n      await this.addNgwLayer(r);\n    }\n\n    this._emitStatusEvent('ngw-map:create', this);\n\n    this.enableSelection();\n  }\n\n  private _addControls() {\n    if (this.options.controls) {\n      this.options.controls.forEach(x => {\n        let controlAdapterName = x;\n        let controlOptions: ControlOptions = {};\n        if (typeof x === 'string' && this.options.controlsOptions) {\n          if (this.options.controlsOptions[x]) {\n            controlOptions = this.options.controlsOptions[x];\n            if (controlOptions.control !== undefined) {\n              controlAdapterName = controlOptions.control;\n            }\n          }\n        }\n        const { position, ...options } = controlOptions;\n        this.addControl(controlAdapterName, position || 'top-left', options);\n      });\n    }\n    this._emitStatusEvent('controls:create');\n  }\n\n  private async _selectFromNgwVector(\n    ev: OnLayerClickOptions\n  ): Promise<FeatureLayersIdentify | undefined> {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties,\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature]\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items\n        };\n        this._emitStatusEvent('ngw:select', {\n          ...identify,\n          resources: [id],\n          sourceType: 'vector'\n        });\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    for (const nl in this._ngwLayers) {\n      const layer = this._ngwLayers[nl].layer;\n      if (layer.getIdentificationIds && layer.options.selectable) {\n        promises.push(layer.getIdentificationIds());\n      }\n    }\n    const getIds = await Promise.all(promises);\n    const ids: number[] = [];\n    getIds.forEach(x => {\n      if (x) {\n        x.forEach(y => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    const zoom = this.getZoom();\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const metresPerPixel =\n      (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n      Math.pow(2, zoom + 8);\n    // FIXME: understand the circle creation function\n    const radius = pixelRadius * metresPerPixel * 0.0005;\n    return NgwKit.utils\n      .sendIdentifyRequest(ev, {\n        layers: ids,\n        connector: this.connector,\n        radius\n      })\n      .then(resp => {\n        this._emitStatusEvent('ngw:select', {\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev\n        });\n        return resp;\n      });\n  }\n}\n","/**\n * @module ngw-map\n */\n\nimport { NgwMap } from './NgwMap';\n\nexport * from '@nextgis/webmap';\nexport * from './interfaces';\n\nexport { NgwMap };\nexport default NgwMap;\n","import { RequestOptions } from '../interfaces';\n\nexport default function loadJSONBrowser(\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions = {},\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) {\n  options.method = options.method || 'GET';\n\n  const xhr = new XMLHttpRequest();\n  xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n  if (options.responseType === 'blob') {\n    xhr.responseType = options.responseType;\n  }\n\n  const processingResponce = (forError = false) => {\n    const cb = forError ? error : callback;\n    if (options.responseType === 'blob') {\n      cb(xhr.response);\n    } else {\n      if (xhr.responseText) {\n        try {\n          cb(JSON.parse(xhr.responseText));\n        } catch (er) {\n          cb(xhr.responseText);\n        }\n      } else {\n        error({ message: '' });\n      }\n    }\n  };\n\n  xhr.onreadystatechange = () => {\n    if (\n      (xhr.readyState === 4 && xhr.status === 200) ||\n      (xhr.readyState === 3 && xhr.status === 201)\n    ) {\n      processingResponce();\n    } else if (xhr.readyState === 3 && xhr.status === 400) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 500) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 401) {\n      error(xhr.statusText);\n    } else if (xhr.readyState === 4) {\n      error('request error');\n    }\n  };\n\n  xhr.onerror = er => {\n    error(er);\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      const percentComplete = (e.loaded / e.total) * 100;\n      if (options.onProgress) {\n        options.onProgress(percentComplete);\n      }\n      // console.log(percentComplete + '% uploaded');\n    }\n  };\n\n  const headers = options.headers;\n  if (headers) {\n    for (const h in headers) {\n      const header = headers[h];\n      if (typeof header === 'string') {\n        xhr.setRequestHeader(h, header);\n      }\n    }\n  }\n  if (options.withCredentials !== undefined) {\n    xhr.withCredentials = options.withCredentials;\n  }\n\n  let data: FormData | any;\n  if (options.file) {\n    data = new FormData();\n    data.append('file', options.file);\n    if (options.data) {\n      for (const d in data) {\n        data.append(d, data[d]);\n      }\n    }\n  } else {\n    data = options.data\n      ? typeof options.data === 'string'\n        ? options.data\n        : JSON.stringify(options.data)\n      : null;\n  }\n  if (onCancel) {\n    onCancel.push(() => {\n      xhr.abort();\n    });\n  }\n  xhr.send(data);\n}\n","import { RequestOptions, RequestMethods } from '../interfaces';\n\n// the 'eval' is used to exclude packages from the webpack bundle for browser\nconst url = eval('require(\"url\")');\nconst http = eval('require(\"http\")');\nconst https = eval('require(\"https\")');\n\nconst adapterFor = (inputUrl: string) => {\n  const adapters: Record<string, any> = {\n    'http:': http,\n    'https:': https\n  };\n  return adapters[url.parse(inputUrl).protocol];\n};\n\nexport default function loadJSONNode(\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) {\n  const request = new Promise((resolve, reject) => {\n    adapterFor(url)\n      .get(url, (resp: any) => {\n        let data = '';\n        resp.on('data', (chunk: any) => {\n          data += chunk;\n        });\n        resp.on('end', () => {\n          resolve(JSON.parse(data));\n        });\n      })\n      .on('error', (err: any) => {\n        reject(err);\n      });\n  });\n  return request\n    .then(data => {\n      if (callback) {\n        callback(data);\n      }\n      return data;\n    })\n    .catch(er => {\n      if (error) {\n        error(er);\n      }\n      throw new Error(er);\n    });\n}\n","import { Geometry, Feature, FeatureCollection } from 'geojson';\nimport {\n  PropertiesFilter,\n  FilterOptions,\n  PropertyFilter\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  FeatureItem,\n  RequestItemAdditionalParams\n} from '@nextgis/ngw-connector';\nimport {\n  propertiesFilter,\n  checkIfPropertyFilter,\n  CancelablePromise\n} from '@nextgis/utils';\n\nexport interface FeatureRequestParams {\n  srs?: number;\n  fields?: string;\n  geom_format?: string;\n  limit?: number;\n  intersects?: string;\n}\n\nexport interface GetNgwLayerItemsOptions {\n  resourceId: number;\n  connector: NgwConnector;\n  filters?: PropertiesFilter;\n}\n\nconst FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson'\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry\n  };\n  return feature;\n}\n\nexport function getNgwLayerItem<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<FeatureItem> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  return options.connector.get('feature_layer.feature.item', null, {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params\n  });\n}\n\nexport function getNgwLayerFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<Feature<G, P>> {\n  return getNgwLayerItem(options).then(item => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n\nfunction idFilterWorkAround<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(options: { filterById: any; resourceId: number; connector: NgwConnector }) {\n  const value = options.filterById[2];\n  const featureIds: number[] =\n    typeof value === 'number'\n      ? [value]\n      : value.split(',').map((x: string) => Number(x));\n  if (options.filterById[1] !== 'eq' && options.filterById[1] !== 'in') {\n    throw new Error(\n      'Unable to filter by object id. Except `eq` or `in` operator'\n    );\n  }\n  const promises: Promise<FeatureItem>[] = featureIds.map(featureId => {\n    return getNgwLayerItem<G, P>({\n      connector: options.connector,\n      resourceId: options.resourceId,\n      featureId\n    });\n  });\n  return CancelablePromise.all(promises);\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nfunction createFeatureFieldFilterQueries(\n  opt: Required<GetNgwLayerItemsOptions> & FilterOptions,\n  _queries: CancelablePromise<FeatureItem[]>[] = [],\n  _parentAllParams: [string, any][] = []\n): CancelablePromise<FeatureItem[]> {\n  const { filters, connector, resourceId } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter(x => Array.isArray(x)) as PropertyFilter[];\n\n  const createParam = (pf: PropertyFilter): [string, any] => {\n    const [field, operation, value] = pf;\n    return [`fld_${field}__${operation}`, value];\n  };\n\n  if (logic === 'any') {\n    filters_.forEach(f => {\n      if (f[0] === 'id') {\n        _queries.push(\n          idFilterWorkAround({ filterById: f, connector, resourceId })\n        );\n      }\n      if (checkIfPropertyFilter(f)) {\n        _queries.push(\n          getNgwLayerItemsRequest({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)]\n          })\n        );\n      } else {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: f\n          },\n          _queries,\n          [..._parentAllParams]\n        );\n      }\n    });\n  } else if (logic === 'all') {\n    const filterById = filters_.find(x => x[0] === 'id');\n    if (filterById) {\n      _queries.push(idFilterWorkAround({ filterById, connector, resourceId }));\n    } else {\n      const filters: [string, any][] = [];\n      const propertiesFilterList: PropertiesFilter[] = [];\n      filters_.forEach(f => {\n        if (checkIfPropertyFilter(f)) {\n          filters.push(createParam(f));\n        } else {\n          propertiesFilterList.push(f);\n        }\n      });\n\n      if (propertiesFilterList.length) {\n        propertiesFilterList.forEach(x => {\n          createFeatureFieldFilterQueries(\n            {\n              ...opt,\n              filters: x\n            },\n            _queries,\n            [..._parentAllParams, ...filters]\n          );\n        });\n      } else {\n        _queries.push(\n          getNgwLayerItemsRequest({\n            ...opt,\n            paramList: [..._parentAllParams, ...filters]\n          })\n        );\n      }\n    }\n  }\n\n  return CancelablePromise.all(_queries).then((itemsParts: FeatureItem[][]) => {\n    const items = itemsParts.reduce((a, b) => a.concat(b), []);\n    if (opt.limit) {\n      return items.splice(0, opt.limit);\n    }\n    return items;\n  });\n}\n\nfunction getNgwLayerItemsRequest<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: GetNgwLayerItemsOptions &\n    FilterOptions & { paramList?: [string, any][] }\n): CancelablePromise<FeatureItem[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  const {\n    connector,\n    limit,\n    fields,\n    intersects,\n    resourceId,\n    paramList\n  } = options;\n  if (limit) {\n    params.limit = limit;\n  }\n  if (fields) {\n    params.fields = fields.join();\n  }\n  if (intersects) {\n    params.intersects = intersects;\n  }\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  return connector.get('feature_layer.feature.collection', null, {\n    id: resourceId,\n    ...params\n  });\n}\n\nexport function getNgwLayerItems<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: GetNgwLayerItemsOptions & FilterOptions\n): CancelablePromise<FeatureItem[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({ ...options, filters });\n  } else {\n    return getNgwLayerItemsRequest(options).then(data => {\n      if (filters) {\n        // control\n        return data.filter(y => {\n          const fields = y.fields;\n          if (fields) {\n            propertiesFilter(fields, filters);\n          }\n        });\n      }\n      return data;\n    });\n  }\n}\n\nexport function getNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & FilterOptions\n): CancelablePromise<FeatureCollection<G, P>> {\n  return getNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach(y => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features\n    };\n    return featureCollection;\n  });\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport {\n  NgwLayerOptions,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions,\n  ResourceNgwLayerOptions\n} from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector\n) {\n  const resource = (options as ResourceNgwLayerOptions).resource;\n  let keyname = (options as KeynamedNgwLayerOptions).keyname;\n  let resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n  if (resource) {\n    if (typeof resource === 'string') {\n      keyname = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = resource;\n    } else {\n      resourceId = await resourceIdFromLayerOptions(resource, connector);\n    }\n  }\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResourceByKeyname(keyname);\n    resourceId = resourceItem.resource.id;\n  }\n  return resourceId;\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, {\n  VectorLayerAdapter,\n  Type,\n  GeoJsonAdapterOptions,\n  PropertiesFilter,\n  FilterOptions\n} from '@nextgis/webmap';\nimport { CancelablePromise } from '@nextgis/utils';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { GeoJsonObject } from 'geojson';\nimport { getNgwLayerFeatures } from './utils/featureLayerUtils';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createGeoJsonAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector\n) {\n  const adapter = webMap.mapAdapter.layerAdapters.GEOJSON as Type<\n    VectorLayerAdapter\n  >;\n\n  let _dataPromise: CancelablePromise<any> | undefined;\n  const _fullDataLoad = false;\n  let _lastFilterArgs:\n    | { filters?: PropertiesFilter; options?: FilterOptions }\n    | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  const geoJsonAdapterCb = async (\n    filters?: PropertiesFilter,\n    opt?: FilterOptions\n  ) => {\n    _lastFilterArgs = { filters, options: opt };\n    _dataPromise = getNgwLayerFeatures({\n      resourceId,\n      filters,\n      connector,\n      ...opt\n    });\n    return await _dataPromise;\n  };\n\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  const onLoad = (data: GeoJsonObject) => {\n    const geoJsonOptions: GeoJsonAdapterOptions = {\n      data\n    };\n    if (options.id) {\n      geoJsonOptions.id = options.id;\n    }\n    return WebMap.utils.updateGeoJsonAdapterOptions(geoJsonOptions);\n  };\n  return class Adapter extends adapter {\n    async addLayer(_opt: GeoJsonAdapterOptions) {\n      let data = {} as GeoJsonObject;\n      if (!_opt.data) {\n        data = await geoJsonAdapterCb(_opt.propertiesFilter, {\n          limit: _opt.limit\n        });\n      }\n      const opt = onLoad(data);\n      const addLayerOptions = { ..._opt, ...opt };\n      if (\n        addLayerOptions.data &&\n        Object.keys(addLayerOptions.data).length === 0\n      ) {\n        addLayerOptions.data = undefined;\n      }\n      return super.addLayer(addLayerOptions);\n    }\n\n    beforeRemove() {\n      abort();\n    }\n\n    async updateLayer() {\n      const { filters, options } = _lastFilterArgs || {};\n      const data = await geoJsonAdapterCb(filters, options);\n      if (this.setData) {\n        this.setData(data);\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter(e => {\n          if (e.feature && e.feature.properties) {\n            return WebMap.utils.propertiesFilter(e.feature.properties, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await geoJsonAdapterCb(filters, opt);\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(function() {\n          return true;\n        });\n      }\n    }\n  };\n}\n","import { NgwLayerOptions, ResourceAdapter } from './interfaces';\nimport WebMap, {\n  BaseLayerAdapter,\n  Type,\n  ImageAdapterOptions,\n  TileAdapterOptions\n} from '@nextgis/webmap';\nimport { getLayerAdapterOptions } from './utils/utils';\nimport NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createRasterAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<BaseLayerAdapter> | undefined> {\n  let adapter = options.adapter || 'IMAGE';\n\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n  if (adapter === 'IMAGE' || adapter === 'TILE' || adapter === 'MVT') {\n    const adapterClass = webMap.mapAdapter.layerAdapters[adapter] as Type<\n      BaseLayerAdapter\n    >;\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    return class Adapter extends adapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = getLayerAdapterOptions(options, webMap, baseUrl);\n        if (opt) {\n          if (opt.resourceId) {\n            const layerAdapterOptions: ImageAdapterOptions = {\n              ...opt,\n              resourceId: opt.resourceId\n            };\n            this.options = { ...this.options, ...layerAdapterOptions };\n          } else {\n            const tileAdapterOptions: TileAdapterOptions = opt;\n            this.options = { ...this.options, ...tileAdapterOptions };\n          }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (id) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport Item, { ItemOptions } from '@nextgis/item';\n\nimport WebMap, { LayerAdaptersOptions, LayerAdapter } from '@nextgis/webmap';\nimport { TreeGroup, TreeLayer } from './interfaces';\nimport { setScaleRatio } from './utils/utils';\n\nexport class WebMapLayerItem extends Item<ItemOptions> {\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: WebMapLayerItem) {\n          if (item) {\n            if (item.item.item_type === 'group') {\n              return true;\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            } else if (item.item.item_type === 'root') {\n              return true;\n            }\n          }\n          return false;\n        },\n        onSet(value: boolean, options?: any, item?: WebMapLayerItem) {\n          if (item && item.layer && item.item.item_type === 'layer') {\n            if (value) {\n              item.webMap.showLayer(item.layer);\n            } else {\n              item.webMap.hideLayer(item.layer);\n            }\n            item.item['layer_enabled'] = value;\n          }\n        }\n      }\n    ]\n  };\n\n  item: TreeGroup | TreeLayer;\n  layer?: LayerAdapter;\n\n  _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    parent?: WebMapLayerItem\n  ) {\n    super({ ...WebMapLayerItem.options, ...options });\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n\n    this.initProperties();\n    this._init(item);\n  }\n\n  async initItem(item: TreeGroup | TreeLayer) {\n    let newLayer = item._layer;\n    const i = item;\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        item.children.reverse().forEach(x => {\n          const children = new WebMapLayerItem(\n            this.webMap,\n            x,\n            this.options,\n            this\n          );\n          this.tree.addChild(children);\n        });\n      }\n    } else if (item.item_type === 'layer') {\n      const adapter = (item.adapter ||\n        item.layer_adapter.toUpperCase()) as keyof LayerAdaptersOptions;\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      const options: any = {\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n        ...item,\n        headers: this.options.headers\n      };\n      if (this.options.order) {\n        const subOrder = this.options.drawOrderEnabled\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n        options.order = Number((this.options.order | 0) + '.' + subOrder);\n      }\n      newLayer = await this.webMap.addLayer(adapter, options);\n    }\n    if (newLayer) {\n      i._layer = newLayer;\n      this.layer = newLayer;\n      if (this.properties && item.item_type === 'layer' && item.layer_enabled) {\n        this.properties.property('visibility').set(true);\n      }\n      const transparency =\n        item.item_type === 'layer' && item.layer_transparency;\n      if (typeof transparency === 'number') {\n        const opacity = (100 - transparency) / 100;\n        this.webMap.setLayerOpacity(newLayer, opacity);\n      }\n    } else {\n      // this.properties.get('visibility').set(true);\n    }\n  }\n\n  bringToFront() {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      console.log(this.item);\n    }\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private async _init(item: TreeGroup | TreeLayer) {\n    await this.initItem(item);\n    this.emitter.emit('init');\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import WebMap, { LngLatBoundsArray, MapClickEvent } from '@nextgis/webmap';\nimport { ResourceItem } from '@nextgis/ngw-connector';\nimport { fixUrlStr, CancelablePromise } from '@nextgis/utils';\nimport {\n  getLayerAdapterOptions,\n  updateWmsParams,\n  sendIdentifyRequest,\n  getWebMapExtent\n} from './utils/utils';\nimport { WebMapLayerItem } from './WebMapLayerItem';\nimport { ItemOptions } from '@nextgis/item';\n\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport {\n  TreeGroup,\n  TreeLayer,\n  NgwLayerAdapterType,\n  WebMapAdapterOptions,\n  WebMapLayerAdapterEvents,\n  ResourceAdapter\n} from './interfaces';\n\nexport class WebMapLayerAdapter implements ResourceAdapter {\n  layer?: WebMapLayerItem;\n\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    WebMapLayerAdapterEvents\n  > = new EventEmitter();\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  private $$onMapClick?: (ev: MapClickEvent) => void;\n\n  constructor(public map: any, public options: WebMapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: WebMapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n\n    this.layer = await this._getWebMapLayerItem();\n\n    if (this.options.identification) {\n      const ids = await this._getWebMapIds();\n      if (ids) {\n        this._webmapLayersIds = ids;\n        this.$$onMapClick = (ev: MapClickEvent) => this._onMapClick(ev);\n        this.options.webMap.emitter.on('click', this.$$onMapClick);\n      }\n    }\n    return this.layer;\n  }\n\n  removeLayer() {\n    const mapAdapter = this.options.webMap.mapAdapter;\n    if (this.$$onMapClick) {\n      this.options.webMap.emitter.off('click', this.$$onMapClick);\n    }\n    this.getDependLayers().forEach(x => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    this.$$onMapClick = undefined;\n    delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getWebMapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<WebMapLayerItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  async getIdentificationIds() {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => a.id - b.id);\n      deps.forEach(x => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  private async _getWebMapLayerItem(): Promise<WebMapLayerItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<WebMapLayerItem>(resolve => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.order = this.options.order;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new WebMapLayerItem(\n            this.options.webMap,\n            webmap.root_item,\n            options\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    try {\n      const data = await this.options.connector.get('resource.item', null, {\n        id\n      });\n      this.response = data;\n      const webmap = data.webmap;\n      if (webmap) {\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    } catch (er) {\n      throw er;\n    }\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map(x =>\n            this._updateItemsParams(x, webMap, data)\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.baseUrl + '/api/component/render/image'\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = params => updateWmsParams(params, resourceId);\n        item = {\n          ...item,\n          ...getLayerAdapterOptions(\n            {\n              adapter: item.layer_adapter.toUpperCase() as NgwLayerAdapterType,\n              resourceId\n            },\n            webMap,\n            this.options.baseUrl\n          )\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: WebMapLayerItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector\n            .get('resource.item', {}, { id })\n            .then(y => {\n              if (y) {\n                const parentId = Number(y.resource.parent.id);\n                item.parentId = parentId;\n                return parentId;\n              }\n            });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter(x => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n\n  private _sendIdentifyRequest(ev: MapClickEvent) {\n    if (this._webmapLayersIds) {\n      return sendIdentifyRequest(ev, {\n        layers: this._webmapLayersIds,\n        connector: this.options.connector,\n        radius: this.pixelRadius\n      }).then(resp => {\n        this.emitter.emit('identify', { ev, data: resp });\n        return resp;\n      });\n    }\n  }\n\n  private _onMapClick(ev: MapClickEvent) {\n    this._sendIdentifyRequest(ev);\n  }\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { getNgwResourceExtent } from './utils/utils';\nimport { LngLatBoundsArray } from '@nextgis/webmap';\n\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  private _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await getNgwResourceExtent(\n        this.item,\n        this.connector\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem\n} from '@nextgis/ngw-connector';\nimport WebMap, { LayerAdapter, Type } from '@nextgis/webmap';\nimport QmsKit from '@nextgis/qms-kit';\nimport { ResourceAdapter, NgwLayerOptions } from './interfaces';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createWebMapAdapter';\nimport { applyMixins } from './utils/utils';\nimport { NgwResource } from './NgwResource';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nconst styles: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'raster_style'\n];\n\nasync function createAdapterFromFirstStyle(\n  parent: number,\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n) {\n  const childrenStyles = await connector.get('resource.collection', null, {\n    parent\n  });\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...options, resourceId: firstStyle.resource.id },\n      webMap,\n      baseUrl,\n      connector\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: Promise<Type<LayerAdapter> | undefined> | undefined;\n  let item: ResourceItem | undefined;\n  try {\n    const adapterType = options.adapter;\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    if (resourceId) {\n      item = await connector.get('resource.item', null, { id: resourceId });\n\n      if (item) {\n        const _options: NgwLayerOptions = { ...options, resourceId };\n        if (item.webmap) {\n          adapter = createWebMapAdapter(_options, webMap, baseUrl, connector);\n        } else if (styles.indexOf(item.resource.cls) !== -1) {\n          if (adapterType === 'GEOJSON') {\n            const parentOptions: NgwLayerOptions = {\n              ...options,\n              resourceId: item.resource.parent.id\n            };\n            adapter = createGeoJsonAdapter(parentOptions, webMap, connector);\n          } else {\n            adapter = createRasterAdapter(_options, webMap, baseUrl, connector);\n          }\n        } else if (item.resource.cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            } else {\n              return createAdapterFromFirstStyle(\n                item.resource.id,\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            }\n          } else {\n            adapter = createGeoJsonAdapter(_options, webMap, connector);\n          }\n        } else if (item.resource.cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(\n            item.resource.id,\n            _options,\n            webMap,\n            baseUrl,\n            connector\n          );\n        } else if (item.basemap_layer && item.basemap_layer.qms) {\n          adapter = Promise.resolve(QmsKit.utils.createQmsAdapter(webMap));\n          adapter.then(x => {\n            if (x && item && item.basemap_layer && item.basemap_layer.qms) {\n              const qms = JSON.parse(item.basemap_layer.qms);\n              x.prototype.qms = qms;\n              x.prototype.baseLayer = true;\n            }\n          });\n        }\n      } else {\n        throw new Error(\n          \"Can't add NGW layer because Resource item is not found\"\n        );\n      }\n    }\n  } catch (er) {\n    // if (options.adapter === 'GEOJSON') {\n    //   adapter = createGeoJsonAdapter(options, webMap, connector);\n    // } else {\n    //   adapter = createRasterAdapter(options, webMap, baseUrl);\n    // }\n  }\n  if (adapter) {\n    return adapter.then(x => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        resourceAdapter.prototype.item = item;\n        resourceAdapter.prototype.resourceId = item?.resource.id;\n        resourceAdapter.prototype.connector = connector;\n\n        applyMixins(resourceAdapter, [NgwResource]);\n\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, { Type } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createWebMapAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<WebMapLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class Adapter extends WebMapLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        webMap,\n        resourceId,\n        baseUrl,\n        connector\n      });\n    }\n  };\n}\n","import WebMap, {\n  Type,\n  LngLatBoundsArray,\n  MapClickEvent\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  WebmapResource,\n  ResourceItem,\n  FeatureLayersIdentify\n} from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../createAsyncAdapter';\nimport {\n  NgwLayerOptions,\n  WebMapAdapterOptions,\n  IdentifyRequestOptions,\n  ResourceAdapter,\n  ResourceIdNgwLayerOptions\n} from '../interfaces';\nimport { WebMapLayerAdapter } from '../WebMapLayerAdapter';\n\nexport function updateWmsParams(params: any, resourceId: number) {\n  const { bbox, width, height } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now()\n  };\n}\n\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string\n) {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  // const keyname = (options as KeynamedNgwLayerOptions).keyname;\n  const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n  // if (!resourceId && keyname) {\n  //   const resourceItem = await connector.getResourceByKeyname(keyname);\n  //   resourceId = resourceItem.resource.id;\n  // }\n  if (resourceId) {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          updateWmsParams: (params: any) => updateWmsParams(params, resourceId)\n        };\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url\n      };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId;\n      return { url, adapter };\n    }\n  } else {\n    console.log('Options `resourceId` not set');\n  }\n}\n\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, baseUrl, connector);\n}\n\nexport function getWebMapExtent(\n  webmap: WebmapResource\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function getNgwLayerExtent(\n  id: number,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  return connector.get('layer.extent', name, { id }).then(resp => {\n    if (resp) {\n      const { maxLat, maxLon, minLat, minLon } = resp.extent;\n      const extenrArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n      return extenrArray;\n    }\n  });\n}\n\nexport async function getNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return getWebMapExtent(item.webmap);\n  } else {\n    const resource = item.resource;\n    if (resource.cls.indexOf('style') !== -1) {\n      return connector\n        .get('resource.item', null, {\n          id: resource.parent.id\n        })\n        .then(res => {\n          return getNgwLayerExtent(res.resource.id, connector);\n        });\n    } else {\n      return getNgwLayerExtent(resource.id, connector);\n    }\n  }\n}\n\ninterface FeatureIdentifyRequestOptions {\n  /**\n   * WKT Polygon geometry\n   */\n  geom: string;\n  srs: 3857;\n  layers: number[];\n}\n\nconst d2r = Math.PI / 180; // degrees to radians\nconst r2d = 180 / Math.PI; // radians to degrees\nconst earthsradius = 3963; // 3963 is the radius of the earth in miles\n\nexport function getCirclePoly(\n  lng: number,\n  lat: number,\n  radius = 10,\n  points = 6\n) {\n  // find the radius in lat/lon\n  const rlat = (radius / earthsradius) * r2d;\n  const rlng = rlat / Math.cos(lat * d2r);\n\n  const extp = [];\n  for (let i = 0; i < points + 1; i++) {\n    // one extra here makes sure we connect the\n\n    const theta = Math.PI * (i / (points / 2));\n    const ex = lng + rlng * Math.cos(theta); // center a + radius x * cos(theta)\n    const ey = lat + rlat * Math.sin(theta); // center b + radius y * sin(theta)\n    extp.push([ex, ey]);\n  }\n\n  // add the circle to the map\n  return extp;\n}\n\nexport function degrees2meters(lng: number, lat: number): [number, number] {\n  const x = (lng * 20037508.34) / 180;\n  let y = Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);\n  y = (y * 20037508.34) / 180;\n  return [x, y];\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions\n  // webMap: WebMap\n): Promise<FeatureLayersIdentify> {\n  // webMap.emitter.emit('start-identify', { ev });\n  const geom = getCirclePoly(ev.latLng.lng, ev.latLng.lat, options.radius);\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  // webMap.addLayer('GEOJSON', {\n  //   visibility: true,\n  //   data: {\n  //     type: 'Feature',\n  //     geometry: {\n  //       type: 'Polygon',\n  //       coordinates: [geom]\n  //     }\n  //   }\n  // })\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\ninterface ExtendWebMapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendWebMapLayerAdapter(\n  opt: ExtendWebMapLayerAdapterOptions\n): Type<WebMapLayerAdapter> {\n  class A extends WebMapLayerAdapter {\n    constructor(map: any, options: WebMapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth() {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        baseCtor.prototype,\n        name\n      );\n      if (descriptor) {\n        Object.defineProperty(derivedCtor.prototype, name, descriptor);\n      }\n    });\n  });\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number) {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 104) {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n  if (lat) {\n    const centerLat = lat;\n    const crsScale =\n      (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n    const zoom = getZoomFromScale(crsScale);\n    return zoom;\n  }\n  return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import { LayerFeature } from '@nextgis/ngw-connector';\nimport { getNgwLayerFeature, createGeoJsonFeature } from './featureLayerUtils';\nimport { GetIdentifyGeoJsonOptions, NgwIdentify } from '../interfaces';\nimport { Geometry } from 'geojson';\n\nexport function getIdentifyGeoJsonParams(\n  identify: NgwIdentify,\n  multiple = false\n) {\n  let params: { resourceId: number; featureId: number } | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort(function(a, b) {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const layerFeatures = identify[l].features;\n    const resourceId = Number(l);\n    const f: LayerFeature | undefined = layerFeatures[0];\n    if (f) {\n      params = {\n        featureId: f.id,\n        resourceId\n      };\n      paramsList.push(params);\n      if (!multiple) {\n        break;\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function getIdentifyGeoJson(options: GetIdentifyGeoJsonOptions) {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      const withGeom = item.features.find(x => x.geom);\n\n      if (withGeom && withGeom.geom) {\n        const geom = withGeom.geom as Geometry;\n        return createGeoJsonFeature({\n          ...withGeom,\n          geom\n        });\n      }\n    }\n  }\n\n  const params = getIdentifyGeoJsonParams(identify);\n  if (params) {\n    return getNgwLayerFeature({ connector, ...params[0] });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport WebMap, { StarterKit, Type } from '@nextgis/webmap';\nimport {\n  getNgwResourceExtent,\n  sendIdentifyRequest,\n  pixelsInMeterWidth,\n  updateWmsParams,\n  getLayerAdapterOptions,\n  addNgwLayer,\n  extendWebMapLayerAdapter,\n  setScaleRatio\n} from './utils/utils';\n\nimport {\n  getIdentifyGeoJson,\n  getIdentifyGeoJsonParams\n} from './utils/identifyUtils';\n\nimport {\n  getNgwLayerItems,\n  getNgwLayerItem,\n  getNgwLayerFeatures,\n  getNgwLayerFeature,\n  createGeoJsonFeature\n} from './utils/featureLayerUtils';\n\nimport { NgwKitOptions, WebMapAdapterOptions } from './interfaces';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\n\nexport class NgwKit implements StarterKit {\n  static utils = {\n    addNgwLayer,\n    getNgwResourceExtent,\n    sendIdentifyRequest,\n    pixelsInMeterWidth,\n    getNgwLayerFeature,\n    getNgwLayerFeatures,\n    getNgwLayerItems,\n    getNgwLayerItem,\n    getIdentifyGeoJson,\n    getIdentifyGeoJsonParams,\n    createGeoJsonFeature,\n    setScaleRatio\n  };\n\n  static updateWmsParams = updateWmsParams;\n\n  static getLayerAdapterOptions = getLayerAdapterOptions;\n\n  static addNgwLayer = addNgwLayer;\n\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl;\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth\n      });\n    }\n  }\n\n  async onLoadSync(webMap: WebMap) {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: WebMapAdapterOptions = {\n            resourceId: r,\n            connector: this.connector,\n            baseUrl: this.url,\n            webMap\n          };\n          const layer = (await webMap.addLayer(WebMapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            identification: this.options.identification,\n            pixelRadius: this.options.pixelRadius,\n            ...options\n          })) as WebMapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap))\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<WebMapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendWebMapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl\n    });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport { NgwKit } from './NgwKit';\n\nexport * from './interfaces';\nexport * from './WebMapLayerAdapter';\nexport * from './WebMapLayerItem';\n\nexport { NgwKit };\nexport default NgwKit;\n","// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\nimport { RequestOptions, RequestMethods } from '../interfaces';\n\ntype LoadJSON = (\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions<RequestMethods> | undefined,\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) => void;\n\nlet loadJSON: LoadJSON;\n\nconst isBrowser = new Function(\n  'try {return this===window;}catch(e){ return false;}'\n)();\nif (isBrowser) {\n  loadJSON = require('./loadJsonBrowser').default;\n} else {\n  loadJSON = require('./loadJsonNode').default;\n}\nexport { loadJSON };\n","// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }) {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","/**\n * @module ngw-connector\n */\nimport { CancelablePromise } from '@nextgis/utils';\nimport { EventEmitter } from 'events';\n\nimport { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport {\n  NgwConnectorOptions,\n  Router,\n  GetRequestItemsResponseMap,\n  RequestOptions,\n  Params,\n  LoadingQueue,\n  UserInfo,\n  Credentials,\n  PyramidRoute,\n  RequestHeaders,\n  PostRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  RequestItemKeys,\n  DeleteRequestItemsResponseMap,\n  PutRequestItemsResponseMap,\n  RequestItemsParams\n} from './interfaces';\nimport { loadJSON } from './utils/loadJson';\nimport { template } from './utils/template';\nimport { ResourceItem } from './types/ResourceItem';\n\nexport class NgwConnector {\n  emitter = new EventEmitter();\n  user?: UserInfo;\n  private routeStr = '/api/component/pyramid/route';\n  private route?: PyramidRoute;\n  private _loadingQueue: { [name: string]: LoadingQueue } = {};\n  private _loadingStatus: { [url: string]: boolean } = {};\n  private _keynames: Record<string, ResourceItem> = {};\n\n  constructor(public options: NgwConnectorOptions) {\n    if (this.options.route) {\n      this.routeStr = this.options.route;\n    }\n  }\n\n  setNextGisWeb(url: string) {\n    this.logout();\n    this.options.baseUrl = url;\n  }\n\n  async connect(): CancelablePromise<Router> {\n    if (this.route) {\n      return Promise.resolve(this.route);\n    } else {\n      if (this.options.auth) {\n        const { login, password } = this.options.auth;\n        if (login && password) {\n          await this.getUserInfo({ login, password });\n        }\n      }\n\n      return await this.makeQuery(this.routeStr, {}, {}).then(\n        (route: PyramidRoute) => {\n          this.route = route;\n          return route;\n        }\n      );\n    }\n  }\n\n  async login(credentials: Credentials) {\n    this.logout();\n    return this.getUserInfo(credentials);\n  }\n\n  logout() {\n    this._rejectLoadingQueue();\n    this._loadingStatus = {};\n    this.options.auth = undefined;\n    this.route = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n  }\n\n  getUserInfo(credentials: Credentials): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials)\n      // withCredentials: true\n    };\n\n    // Do not use request('auth.current_user') to avoid circular-references\n    return this.makeQuery('/api/component/auth/current_user', {}, options)\n      .then((data: UserInfo) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch(er => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  getAuthorizationHeaders(\n    credentials?: Credentials\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials) {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      return window.btoa(unescape(encodeURIComponent(`${login}:${password}`)));\n    }\n  }\n\n  async getResourceByKeyname(keyname: string) {\n    let resource: ResourceItem = this._keynames['keyname'];\n    if (!resource) {\n      const resources = await this.get('resource.search', null, { keyname });\n      resource = resources[0];\n      if (resource) {\n        this._keynames[keyname] = resource;\n      }\n    }\n    return resource;\n  }\n\n  async getResourceChildren(opt: {\n    keyname?: string;\n    resourceId?: number;\n  }): Promise<ResourceItem[]> {\n    let parent = opt.resourceId;\n    if (!opt.keyname && !opt.resourceId) {\n      throw new Error('No keyname or resourceId is set');\n    }\n    if (opt.keyname) {\n      const item = await this.getResourceByKeyname(opt.keyname);\n      parent = item.resource.id;\n    }\n    return await this.get('resource.collection', null, {\n      parent\n    });\n  }\n\n  async request<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys\n  >(\n    name: K,\n    params: RequestItemsParams<K> = {},\n    options?: RequestOptions\n  ): CancelablePromise<P[K]> {\n    const apiItems = await this.connect();\n    let apiItem = apiItems && apiItems[name];\n    if (apiItem) {\n      apiItem = [...apiItem];\n      let url = apiItem.shift();\n      if (apiItem.length) {\n        const replaceParams: {\n          [num: number]: string;\n        } = {};\n        for (let fry = 0; fry < apiItem.length; fry++) {\n          const arg = apiItem[fry];\n          replaceParams[fry] = '{' + arg + '}';\n          if (params[arg] === undefined) {\n            throw new Error(\n              '`' + arg + '`' + ' url api argument is not specified'\n            );\n          }\n        }\n        if (url) {\n          url = template(url, replaceParams);\n        }\n      }\n      // Transfer part of the parameters from `params` to the URL string\n      if (params) {\n        const paramArray = [];\n        const paramList = params.paramList;\n        if (Array.isArray(paramList)) {\n          delete params.paramList;\n          paramList.forEach(x => {\n            paramArray.push(`${x[0]}=${x[1]}`);\n          });\n        }\n        for (const p in params) {\n          if (apiItem.indexOf(p) === -1) {\n            paramArray.push(`${p}=${params[p]}`);\n          }\n        }\n        if (paramArray.length) {\n          url = url + '?' + paramArray.join('&');\n        }\n      }\n      if (url) {\n        return this.makeQuery(url, params, options);\n      } else {\n        throw new Error('request url is not set');\n      }\n    }\n    return CancelablePromise.resolve({} as P[K]);\n  }\n\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    options.nocache = true;\n    return this.request<K, PostRequestItemsResponseMap>(name, params, options);\n  }\n\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    options.nocache = true;\n    return this.request<K, GetRequestItemsResponseMap>(name, params, options);\n  }\n\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    options.nocache = true;\n    return this.request<K, PatchRequestItemsResponseMap>(name, params, options);\n  }\n\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    options.nocache = true;\n    return this.request<K, PutRequestItemsResponseMap>(name, params, options);\n  }\n\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    options.nocache = true;\n    return this.request<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options\n    );\n  }\n\n  makeQuery(\n    url: string,\n    params?: Params,\n    options: RequestOptions = {}\n  ): CancelablePromise<any> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      // remove double slash\n      url = url.replace(/([^:]\\/)\\/+/g, '$1');\n      if (!this._loadingStatus[url] || options.nocache) {\n        this._loadingStatus[url] = true;\n\n        return this._getJson(url, options)\n          .then(data => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, data);\n            return data;\n          })\n          .catch(er => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, er, true);\n            this.emitter.emit('error', er);\n            throw er;\n          });\n      } else {\n        this._loadingStatus[url] = false;\n        return new CancelablePromise((resolve, reject) => {\n          this._setLoadingQueue(url, resolve, reject);\n        });\n      }\n    } else {\n      throw new Error('No `url` parameter set for option ' + name);\n    }\n  }\n\n  protected _setLoadingQueue(\n    name: string,\n    resolve: (...args: any[]) => any,\n    reject: (...args: any[]) => any\n  ) {\n    this._loadingQueue[name] = this._loadingQueue[name] || {\n      name,\n      waiting: []\n    };\n    this._loadingQueue[name].waiting.push({\n      resolve,\n      reject,\n      timestamp: new Date()\n    });\n  }\n\n  protected _rejectLoadingQueue() {\n    for (const q in this._loadingQueue) {\n      const queue = this._loadingQueue[q];\n      queue.waiting.forEach(x => {\n        x.reject();\n      });\n      delete this._loadingQueue[q];\n    }\n  }\n\n  protected _executeLoadingQueue(name: string, data: any, isError?: boolean) {\n    const queue = this._loadingQueue[name];\n    if (queue) {\n      for (let fry = 0; fry < queue.waiting.length; fry++) {\n        const wait = queue.waiting[fry];\n        if (isError) {\n          if (wait.reject) {\n            wait.reject();\n          }\n        } else {\n          wait.resolve(data);\n        }\n      }\n      queue.waiting = [];\n    }\n  }\n\n  protected _getJson(\n    url: string,\n    options: RequestOptions\n  ): CancelablePromise<any> {\n    const onCancel: (() => void)[] = [];\n    options.responseType = options.responseType || 'json';\n    return new CancelablePromise(\n      (resolve, reject) => {\n        if (this.user) {\n          options = options || {};\n          // options.withCredentials = true;\n          options.headers = {\n            ...this.getAuthorizationHeaders(),\n            ...options.headers\n          };\n        }\n        loadJSON(url, resolve, options, reject, onCancel);\n      },\n      () => {\n        onCancel.forEach(x => x());\n      }\n    );\n  }\n}\n","/**\n * @module ngw-connector\n */\n\nimport { NgwConnector } from './NgwConnector';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\n// for backward compatibility\n// TODO: safe remove backward compatibility\nimport { CancelablePromise } from '@nextgis/utils';\nexport { CancelablePromise };\n\nexport { NgwConnector };\nexport default NgwConnector;\n"],"sourceRoot":""}