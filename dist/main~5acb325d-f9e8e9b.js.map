{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/vue-ngw-map/src/components/VueNgwControl.ts","webpack:///./nextgisweb_frontend/packages/vue-ngw-map/src/components/VueNgwMap.ts","webpack:///./nextgisweb_frontend/packages/vue-ngw-map/src/components/VueNgwResource.ts","webpack:///./nextgisweb_frontend/packages/vue-ngw-mapbox/src/components/VueNgwMapbox.ts","webpack:///./nextgisweb_frontend/packages/vue-ngw-mapbox/src/index.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/util/preparePaint.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/util/geometryTypes.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/util/updateGeoJsonAdapterOptions.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/components/controls/ToggleControl.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/components/keys/KeysCodes.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/components/keys/Keys.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/util/decorators.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/util/getBoundsPolygon.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/components/mapStates/StateItem.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/components/mapStates/CenterState.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/components/mapStates/ZoomState.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/BaseWebMap.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/util/clearObject.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/WebMapLayers.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/WebMap.ts","webpack:///./nextgisweb_frontend/packages/webmap/src/index.ts","webpack:///./nextgisweb_frontend/packages/vue-ngw-map/src/utils.ts"],"names":["name","beforeDestroy","this","parentContainer","ngwMap","control","removeControl","undefined","setControl","element","adControlOptions","$props","controlOptions","controlObject","onAdd","onRemove","createControl","_control","addControl","position","mounted","$parent","$el","$nextTick","$emit","render","h","staticClass","staticStyle","attrs","$slots","default","type","String","Boolean","Object","VueNgwControl","ready","_setNgwMap","destroy","zIndex","fullFilling","width","height","data","mapAdapter","mapOptions","target","Number","VueNgwMap","layer","removeLayer","setResourceId","resourceId","oldId","order","options","adapterOptions","fit","addNgwLayer","adapter","VueNgwResource","VueNgwMapbox","preparePaint","paint","defaultPaint","getPaintFunctions","newPaint","opt","getPaint","from","updatePaintOptionFromCallback","fill","stroke","strokeColor","strokeOpacity","color","fillColor","opacity","fillOpacity","findMostFrequentGeomType","arr","maxName","counts","fry","length","c","count","detectGeometryType","geojson","geometry","features","map","f","geometries","g","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","updateGeoJsonAdapterOptions","geomType","p","createToggleControl","createButtonControl","link","document","createElement","status","getStatus","title","html","setTitle","on","off","setAttribute","_setHtml","htmlDef","HTMLElement","innerHTML","appendChild","setHtml","_setClass","addClass","impact","split","forEach","x","classList","add","remove","setClass","addClassOn","addClassOff","changeStatus","status_","onClick","afterClick","Promise","resolve","then","catch","buttonControl","keyCodeAlias","KeyCodes","keys","_windowOnFocus","windowOnFocus","bind","_keysPressed","keysPressed","_keysReleased","keysReleased","addKeyboardEventsListener","pressed","keyName","code","window","addEventListener","removeKeyboardEventsListener","removeEventListener","e","stopPropagation","keyCode","onLoad","event","_target","_propertyKey","descriptor","originalMethod","value","reject","_resolve","origin","apply","args","getEventStatus","emitter","once","getBoundsPolygon","b","westNorth","properties","coordinates","webMap","setValue","getValue","val","getCenter","setCenter","toString","d","toFixed","parse","str","StateItem","getZoom","setZoom","OPTIONS","minZoom","maxZoom","radius","weight","selectedPaint","appOptions","BaseWebMap","runtimeParams","mapState","CenterState","ZoomState","_initMapState","_mapState","_eventsStatus","_mapEvents","_starterKits","starterKits","_addEventsListeners","create","_setInitMapState","_setupMap","_emitStatusEvent","setRuntimeParams","params","push","_removeEventsListeners","obj","member","clearObject","getState","state","getRuntimeParams","get","getContainer","getElementById","setCursor","cursor","lngLat","getBounds","bounds","zoom","setView","fitBounds","_eventName","res","onMapLoad","cb","isLoaded","getLayerAdapters","layerAdapters","getLayerAdapter","locate","events","stop","eventName","emit","_addLayerProviders","_onLoadSync","_zoomToInitialExtent","center","_extent","states","X","find","y","r","set","entries","utils","propertiesFilter","decorators","_layersIdCounter","_layersOrderCounter","_baseLayers","_layers","_layersOrderList","_selectedLayers","fitLayer","layerDef","getLayer","getExtent","extent","isBaseLayer","id","indexOf","getBaseLayers","getLayerId","Error","getLayers","allLayers","findLayer","filter","l","layerAdapter","isLayerVisible","visibility","addBaseLayer","addLayer","baseLayer","_order","adapterEngine","geoJsonOptions","_updateGeoJsonOptions","onBeforeAddLayer","modified","_adapter","layerId","filterLayer","showLayer","setLayerOpacity","addLayerFromAsyncAdapter","removeLayers","allowCb","allow","removeOverlays","beforeRemove","index","splice","addGeoJsonLayer","multiselect","unselectOnSecondClick","toggleLayer","hideLayer","onMap","toStatus","silent","action","source","preEventName","anotherVisibleLayerBaseLayer","call","setLayerOrder","updateLayer","selectLayer","findFeatureFun","select","unSelectLayer","unselect","filters","feature","removeLayerFilter","removeFilter","setLayerData","setData","clearLayer","addData","addLayerData","clearLayerData","getAttributions","attributions","layerMem","onlyVisible","attr","attribution","getActiveBaseLayer","visibleLayerBaseLayer","_onLayerClick","onLayerClickFromOpt","onLayerClick","nativePaint","WebMap","controlDef","getControl","engine","controlAdapters","createFun","controls","kit","adapters","createAdapter","newAdapter","onLoadSync","console","error","CONTROL","BUTTON","TOGGLE","propsBinder","vueElement","props","key","setMethodName","charAt","toUpperCase","slice","prop","deepValue","Array","isArray","$watch","newVal","oldVal","deep","findNgwMapParent","firstVueParent","found"],"mappings":"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","file":"main~5acb325d-f9e8e9b.js","sourcesContent":["import Vue, { CreateElement, VNode, VNodeData } from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop } from 'vue-property-decorator';\nimport {\n  MapControl,\n  CreateControlOptions,\n  ControlPositions\n} from '@nextgis/webmap';\nimport { findNgwMapParent, propsBinder } from '../utils';\nimport VueNgwMap from './VueNgwMap';\n\n@Component\nexport class VueNgwControl extends Vue {\n  name = 'vue-ngw-control';\n\n  @Prop({ type: String }) position!: ControlPositions;\n  @Prop({ type: Boolean }) bar!: boolean;\n  @Prop({ type: Boolean }) margin!: boolean;\n  @Prop({ type: String }) addClass!: string;\n  @Prop({ type: Object, default: () => ({}) })\n  controlOptions!: CreateControlOptions;\n\n  parentContainer!: VueNgwMap;\n\n  control?: unknown;\n\n  beforeDestroy() {\n    if (this.parentContainer.ngwMap && this.control) {\n      this.parentContainer.ngwMap.removeControl(this.control);\n      this.control = undefined;\n    }\n  }\n\n  async setControl(element: HTMLElement) {\n    const ngwMap = this.parentContainer.ngwMap;\n    const control = this.control;\n    if (ngwMap) {\n      if (control) {\n        ngwMap.removeControl(control);\n      }\n      const adControlOptions: CreateControlOptions = {\n        ...this.$props,\n        ...this.$props.controlOptions\n      };\n      const controlObject: MapControl = {\n        onAdd: () => {\n          return element;\n        },\n        onRemove: () => {\n          // ignore\n        }\n      };\n      const _control = await ngwMap.createControl(\n        controlObject,\n        adControlOptions\n      );\n      this.control = ngwMap.addControl(_control, this.position);\n    }\n  }\n\n  async mounted() {\n    this.parentContainer = findNgwMapParent(this.$parent);\n\n    await this.setControl(this.$el as HTMLElement);\n\n    propsBinder(this, this.$props);\n\n    this.$nextTick(() => {\n      this.$emit('ready', this.control);\n    });\n  }\n\n  render(h: CreateElement): VNode {\n    const staticStyle: { [param: string]: string } = {\n      // zIndex: '0'\n    };\n\n    const data: VNodeData = {\n      staticClass: 'vue-ngw-control',\n      staticStyle,\n      // 'class': this.classes,\n      attrs: { 'data-app': true }\n      // domProps: { id: this.id }\n    };\n\n    return h('div', data, this.$slots.default);\n  }\n}\n\nexport default VueNgwControl;\n","import Vue, { VNode, VNodeData, CreateElement } from 'vue';\nimport { Prop } from 'vue-property-decorator';\nimport Component from 'vue-class-component';\nimport NgwMap, { NgwMapOptions, MapAdapter } from '@nextgis/ngw-map';\n\nimport NgwConnector from '@nextgis/ngw-connector';\n\n@Component\nexport class VueNgwMap<M = any> extends Vue {\n  @Prop({ type: Object }) mapAdapter!: MapAdapter;\n  @Prop({ type: Boolean }) fullFilling!: boolean;\n  @Prop({ type: NgwConnector }) connector!: NgwConnector;\n  @Prop({ type: String }) baseUrl!: string;\n  @Prop({ type: Number }) qmsId!: string;\n  @Prop({ type: String }) webMapId!: string;\n  @Prop({ type: Object }) mapOptions!: NgwMapOptions;\n  name = 'vue-ngw-map';\n  ngwMap!: NgwMap<M>;\n  ready = false;\n\n  mounted() {\n    this._setNgwMap();\n  }\n\n  beforeDestroy() {\n    this.ngwMap.destroy();\n  }\n\n  render(h: CreateElement): VNode {\n    const staticStyle: { [param: string]: string } = {\n      zIndex: '0'\n    };\n    if (this.fullFilling) {\n      staticStyle.width = '100%';\n      staticStyle.height = '100%';\n    }\n\n    const data: VNodeData = {\n      staticClass: 'vue-ngw-map',\n      staticStyle,\n      // 'class': this.classes,\n      attrs: { 'data-app': true }\n      // domProps: { id: this.id }\n    };\n\n    return this.ready ? h('div', data, this.$slots.default) : h('div', data);\n  }\n\n  private _setNgwMap() {\n    this.ngwMap = new NgwMap(this.mapAdapter, {\n      ...this.$props,\n      ...this.mapOptions,\n      target: this.$el as HTMLElement\n    });\n    this.ready = true;\n  }\n}\n\nexport default VueNgwMap;\n","import Vue, { VNode, CreateElement } from 'vue';\nimport Component from 'vue-class-component';\nimport { Prop } from 'vue-property-decorator';\nimport { findNgwMapParent, propsBinder } from '../utils';\nimport { ResourceAdapter, NgwLayerAdapterType } from '@nextgis/ngw-kit';\nimport VueNgwMap from './VueNgwMap';\nimport { AdapterOptions } from '@nextgis/webmap';\n\n@Component\nexport class VueNgwResource extends Vue {\n  name = 'vue-ngw-resource';\n\n  @Prop({ type: Number }) resourceId!: string;\n  @Prop({ type: Boolean, default: false }) fit!: boolean;\n  @Prop({ type: String }) adapter!: NgwLayerAdapterType;\n  @Prop({ type: Object, default: () => ({}) }) adapterOptions!: AdapterOptions;\n\n  parentContainer!: VueNgwMap;\n\n  layer?: ResourceAdapter;\n\n  beforeDestroy() {\n    if (this.parentContainer.ngwMap && this.layer) {\n      this.parentContainer.ngwMap.removeLayer(this.layer);\n      this.layer = undefined;\n    }\n  }\n\n  async setResourceId(resourceId: string, oldId?: number) {\n    const ngwMap = this.parentContainer.ngwMap;\n    const layer = this.layer;\n    let order: number | undefined;\n    if (ngwMap) {\n      if (layer) {\n        order = layer.options.order;\n        ngwMap.removeLayer(layer);\n      }\n      const adapterOptions: AdapterOptions = { ...this.$props.adapterOptions };\n      if (order) {\n        adapterOptions.order = order;\n      }\n      if (resourceId) {\n        const fit = this.$props.fit ? !oldId : false;\n        this.layer = await ngwMap.addNgwLayer({\n          resourceId: Number(resourceId),\n          adapter: this.$props.adapter,\n          fit,\n          adapterOptions\n        });\n      }\n    }\n  }\n\n  async mounted() {\n    this.parentContainer = findNgwMapParent(this.$parent);\n\n    await this.setResourceId(this.$props.resourceId);\n\n    propsBinder(this, this.$props);\n\n    this.$nextTick(() => {\n      this.$emit('ready', this.layer);\n    });\n  }\n\n  render(h: CreateElement): VNode {\n    return h('div', {});\n  }\n}\n\nexport default VueNgwResource;\n","import 'mapbox-gl/dist/mapbox-gl.css';\n\nimport { Map } from 'mapbox-gl';\nimport { Mixins, Prop } from 'vue-property-decorator';\nimport Component from 'vue-class-component';\nimport { VueNgwMap } from '@nextgis/vue-ngw-map';\n\nimport MapAdapter from '@nextgis/mapboxgl-map-adapter';\n\n@Component\nexport class VueNgwMapbox extends Mixins<VueNgwMap<Map>>(VueNgwMap) {\n  @Prop({ type: Object, default: () => new MapAdapter() })\n  mapAdapter!: MapAdapter;\n}\n","/**\n * @module vue-ngw-mapbox\n */\nimport { VueNgwMapbox } from './components/VueNgwMapbox';\n\nexport { VueNgwMapbox };\nexport default VueNgwMapbox;\n","import {\n  Paint,\n  VectorAdapterLayerPaint,\n  GeometryPaint,\n  GetPaintFunction,\n  GetCustomPaintOptions\n} from '../interfaces/LayerAdapter';\n\nfunction updatePaintOptionFromCallback(\n  paint: GetCustomPaintOptions,\n  getPaintFunctions: { [name: string]: GetPaintFunction }\n): VectorAdapterLayerPaint | undefined {\n  if (typeof paint.from === 'function') {\n    return paint.from(paint.options);\n  } else if (typeof paint.from === 'string' && getPaintFunctions) {\n    const from = getPaintFunctions[paint.from];\n    if (from) {\n      return from(paint.options);\n    }\n  }\n}\n\nexport function preparePaint(\n  paint: Paint,\n  defaultPaint: GeometryPaint,\n  getPaintFunctions: { [name: string]: GetPaintFunction }\n): Paint {\n  let newPaint: Paint | undefined;\n  if (typeof paint === 'function') {\n    return (opt: any) => {\n      return preparePaint(\n        paint(opt),\n        defaultPaint,\n        getPaintFunctions\n      ) as VectorAdapterLayerPaint;\n    };\n  } else if (paint.type === 'get-paint') {\n    const getPaint = updatePaintOptionFromCallback(paint, getPaintFunctions);\n    if (getPaint) {\n      newPaint = preparePaint(getPaint, defaultPaint, getPaintFunctions);\n    }\n  } else if (paint.type === 'icon') {\n    return paint;\n  } else {\n    newPaint = { ...paint };\n    newPaint.fill = newPaint.fill !== undefined ? newPaint.fill : true;\n    newPaint.stroke =\n      newPaint.stroke !== undefined\n        ? newPaint.stroke\n        : !newPaint.fill || !!(newPaint.strokeColor || newPaint.strokeOpacity);\n  }\n  if (newPaint) {\n    if (typeof newPaint === 'function') {\n      return newPaint;\n    } else {\n      newPaint = { ...defaultPaint, ...newPaint };\n    }\n  } else {\n    newPaint = { ...defaultPaint };\n  }\n\n  if ('color' in newPaint) {\n    if (!newPaint.strokeColor) {\n      newPaint.strokeColor = newPaint.color;\n    }\n    if (!newPaint.fillColor) {\n      newPaint.fillColor = newPaint.color;\n    }\n  }\n  if ('opacity' in newPaint) {\n    if (newPaint.strokeOpacity === undefined) {\n      newPaint.strokeOpacity = newPaint.opacity;\n    }\n    if (newPaint.fillOpacity === undefined) {\n      newPaint.fillOpacity = newPaint.opacity;\n    }\n  }\n\n  return newPaint;\n}\n","import {\n  GeoJsonObject,\n  GeoJsonGeometryTypes,\n  FeatureCollection,\n  GeometryCollection,\n  Feature\n} from 'geojson';\n\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[]\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName;\n  for (const c in counts) {\n    const count = maxName !== undefined ? counts[maxName] : 0;\n    if (counts[c] > (count || 0)) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectGeometryType(\n  geojson: GeoJsonObject\n): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      f => f.geometry.type\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      g => g.type\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n","import {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType\n} from '../interfaces/LayerAdapter';\nimport { detectGeometryType } from './geometryTypes';\n\nexport const typeAlias: { [x: string]: VectorAdapterLayerType } = {\n  Point: 'circle',\n  LineString: 'line',\n  MultiPoint: 'circle',\n  Polygon: 'fill',\n  MultiLineString: 'line',\n  MultiPolygon: 'fill'\n};\n\nexport function updateGeoJsonAdapterOptions(\n  opt: GeoJsonAdapterOptions\n): GeoJsonAdapterOptions {\n  if (opt.data) {\n    const geomType = typeAlias[detectGeometryType(opt.data)];\n    const p = opt.paint;\n    if (typeof p === 'object') {\n      // define parameter if not specified\n      p.type = p.type\n        ? p.type\n        : geomType === 'fill' || geomType === 'line'\n        ? 'path'\n        : 'html' in p || 'className' in p\n        ? 'icon'\n        : geomType;\n    }\n    opt.type = opt.type || geomType;\n  }\n  return opt;\n}\n","import {\n  ToggleControlOptions,\n  ToggleControl,\n  ButtonControlOptions\n} from '../../interfaces/MapControl';\n\nexport function createToggleControl<C = any>(\n  createButtonControl: (options: ButtonControlOptions) => C,\n  options: ToggleControlOptions\n): C & ToggleControl {\n  const link = document.createElement('div');\n\n  let status = false;\n  if (options.getStatus) {\n    status = options.getStatus();\n  } else if (options.status) {\n    status = options.status;\n  }\n\n  const title = options.title || '';\n  const html = options.html;\n\n  function setTitle() {\n    if (title) {\n      if (typeof title === 'string') {\n        link.title = title;\n      } else {\n        link.title = status ? title.on : title.off;\n      }\n      link.setAttribute('aria-label', link.title);\n    }\n  }\n  setTitle();\n\n  // DomEvent.disableClickPropagation(link);\n  // DomEvent.on(link, 'click', DomEvent.stop);\n\n  function _setHtml(htmlDef: string | HTMLElement) {\n    if (htmlDef instanceof HTMLElement) {\n      link.innerHTML = '';\n      link.appendChild(htmlDef);\n    } else if (typeof htmlDef === 'string') {\n      link.innerHTML = htmlDef;\n    }\n  }\n  function setHtml() {\n    if (html) {\n      if (typeof html === 'string' || html instanceof HTMLElement) {\n        _setHtml(html);\n      } else {\n        _setHtml(status ? html.on : html.off);\n      }\n      link.setAttribute('aria-label', link.title);\n    }\n  }\n  setHtml();\n\n  function _setClass(addClass: string, impact: boolean) {\n    addClass.split(' ').forEach(x => {\n      if (impact) {\n        link.classList.add(x);\n      } else {\n        link.classList.remove(x);\n      }\n    });\n  }\n\n  function setClass() {\n    if (options.addClassOn) {\n      _setClass(options.addClassOn, status);\n    }\n    if (options.addClassOff) {\n      _setClass(options.addClassOff, !status);\n    }\n  }\n\n  if (options.addClass) {\n    _setClass(options.addClass, true);\n  }\n  setClass();\n\n  const changeStatus = (status_?: boolean) => {\n    if (status_ !== undefined) {\n      status = status_;\n    }\n    setHtml();\n    setTitle();\n    setClass();\n  };\n\n  const onClick = (status_?: boolean) => {\n    status = status_ !== undefined ? status_ : !status;\n    if (options.onClick) {\n      const afterClick = options.onClick(status);\n      Promise.resolve(afterClick)\n        .then(() => changeStatus())\n        .catch(() => (status = !status));\n    } else {\n      changeStatus();\n    }\n  };\n\n  const buttonControl = createButtonControl({\n    html: link,\n    onClick\n  }) as C & ToggleControl;\n  buttonControl.onClick = onClick;\n  buttonControl.changeStatus = changeStatus;\n  return buttonControl;\n}\n","export class KeyCodes {\n  'backspace' = 8;\n  'tab' = 9;\n  'enter' = 13;\n  'shift' = 16;\n  'ctrl' = 17;\n  'alt' = 18;\n  'pause/break' = 19;\n  'caps_lock' = 20;\n  'escape' = 27;\n  'page_up' = 33;\n  'page_down' = 34;\n  'end' = 35;\n  'home' = 36;\n  'left_arrow' = 37;\n  'up_arrow' = 38;\n  'right_arrow' = 39;\n  'down_arrow' = 40;\n  'insert' = 45;\n  'delete' = 46;\n  'left_window_key' = 91;\n  'right_window_key' = 92;\n  'select_key' = 93;\n  'numpad_0' = 96;\n  'numpad_1' = 97;\n  'numpad_2' = 98;\n  'numpad_3' = 99;\n  'numpad_4' = 100;\n  'numpad_5' = 101;\n  'numpad_6' = 102;\n  'numpad_7' = 103;\n  'numpad_8' = 104;\n  'numpad_9' = 105;\n  'multiply' = 106;\n  'add' = 107;\n  'subtract' = 109;\n  'decimal_point' = 110;\n  'divide' = 111;\n  'f1' = 112;\n  'f2' = 113;\n  'f3' = 114;\n  'f4' = 115;\n  'f5' = 116;\n  'f6' = 117;\n  'f7' = 118;\n  'f8' = 119;\n  'f9' = 120;\n  'f10' = 121;\n  'f11' = 122;\n  'f12' = 123;\n  'num_lock' = 144;\n  'scroll_lock' = 145;\n  'semi-colon' = 186;\n  'equal_sign' = 187;\n  ',' = 188; // \"comma\";\n  '-' = 189; // \"dash\";\n  '.' = 190; // \"period\";\n  '/' = 191; // \"forward slash\";\n  '`' = 192; // \"grave accent\";\n  '[' = 219; // \"open bracket\";\n  '\\\\' = 220; // \"back slash\";\n  ']' = 221; // \"close braket\";\n  \"'\" = 222; // \"single quote\"\n}\n","import { KeyCodes } from './KeysCodes';\n\n/**\n * @param {string} key - key symbol\n * @param {string} func - action on key press\n * @param {number} [keyCode] - key code for special button like tab\n *\n * @export\n * @interface KeyControl\n */\nexport interface KeyControl {\n  key?: string;\n  keyCode?: number;\n  func: () => void;\n}\n\nexport class Keys {\n  keyCodeAlias = new KeyCodes();\n\n  keys: { [keyCode: number]: boolean } = {};\n\n  private _windowOnFocus: () => void;\n  private _keysPressed: (e: KeyboardEvent) => void;\n  private _keysReleased: (e: KeyboardEvent) => void;\n\n  constructor() {\n    this._windowOnFocus = this.windowOnFocus.bind(this);\n    this._keysPressed = this.keysPressed.bind(this);\n    this._keysReleased = this.keysReleased.bind(this);\n    this.addKeyboardEventsListener();\n  }\n\n  pressed(keyName: keyof KeyCodes): boolean {\n    const code = this.keyCodeAlias[keyName];\n    return !!code && this.keys[code];\n  }\n\n  addKeyboardEventsListener() {\n    window.addEventListener('focus', this._windowOnFocus, false);\n    window.addEventListener('keydown', this._keysPressed, false);\n    window.addEventListener('keyup', this._keysReleased, false);\n  }\n\n  removeKeyboardEventsListener() {\n    window.removeEventListener('focus', this._windowOnFocus, false);\n    window.removeEventListener('keydown', this._keysPressed, false);\n    window.removeEventListener('keyup', this._keysReleased, false);\n  }\n\n  private keysPressed(e: KeyboardEvent) {\n    e.stopPropagation();\n    if (!this.keys[e.keyCode]) {\n      this.keys[e.keyCode] = true;\n    }\n  }\n\n  private keysReleased(e: KeyboardEvent) {\n    e.stopPropagation();\n    this.keys[e.keyCode] = false;\n  }\n\n  private windowOnFocus() {\n    this.keys = {};\n  }\n}\n","import { WebMap } from '../WebMap';\nimport { WebMapEvents } from '../interfaces/Events';\n\nexport function onLoad<E extends WebMapEvents = WebMapEvents>(event: keyof E) {\n  return function(\n    _target: WebMap,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function(\n      this: WebMap<unknown, unknown, unknown, E>,\n      ...args: unknown[]\n    ) {\n      return new Promise((resolve, reject) => {\n        const _resolve = (): void => {\n          const origin = originalMethod.apply(this, args);\n          origin && origin.then\n            ? origin.then(resolve).catch(reject)\n            : resolve(origin);\n        };\n        const isLoaded = this.getEventStatus(event);\n        if (isLoaded) {\n          _resolve();\n        } else {\n          this.emitter.once(event as keyof WebMapEvents, () => {\n            _resolve();\n          });\n        }\n      });\n    };\n    return descriptor;\n  };\n}\n","import { LngLatBoundsArray } from '../interfaces/BaseTypes';\nimport { Feature, Polygon } from 'geojson';\n\nexport function getBoundsPolygon(b: LngLatBoundsArray): Feature<Polygon> {\n  const westNorth = [b[0], b[1]];\n  const eastNorth = [b[2], b[1]];\n  const eastSouth = [b[2], b[3]];\n  const westSouth = [b[0], b[3]];\n\n  const feature: Feature<Polygon> = {\n    type: 'Feature',\n    properties: {},\n    geometry: {\n      type: 'Polygon',\n      coordinates: [[westNorth, eastNorth, eastSouth, westSouth, westNorth]]\n    }\n  };\n  return feature;\n}\n","import { MapStateItem } from '../../interfaces/MapState';\nimport { WebMapEvents } from '../../interfaces/Events';\nimport { WebMap } from '../../WebMap';\nimport { MapOptions } from '../../interfaces/WebMapApp';\n\nexport abstract class StateItem<V extends any | undefined = any | undefined>\n  implements MapStateItem<V | undefined> {\n  name!: keyof MapOptions;\n  event!: keyof WebMapEvents;\n  protected value?: V;\n\n  constructor(\n    protected webMap: WebMap,\n    opt?: { name?: keyof MapOptions; event?: keyof WebMapEvents; value?: V }\n  ) {\n    if (opt) {\n      if (opt.value) {\n        this.setValue(opt.value);\n      }\n      if (opt.name) {\n        this.name = opt.name;\n      }\n      if (opt.event) {\n        this.event = opt.event;\n      }\n    }\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  setValue(val: V) {\n    this.value = val;\n  }\n\n  abstract toString(data: any): string;\n  abstract parse(str: string): V;\n}\n","import { StateItem } from './StateItem';\nimport { WebMapEvents } from '../../interfaces/Events';\nimport { LngLatArray } from '../../interfaces/BaseTypes';\nimport { MapOptions } from '../../interfaces/WebMapApp';\n\nexport class CenterState extends StateItem<LngLatArray> {\n  name: keyof MapOptions = 'center';\n  event: keyof WebMapEvents = 'moveend';\n\n  getValue() {\n    return this.webMap.getCenter();\n  }\n  setValue(val: LngLatArray) {\n    this.webMap.setCenter(val);\n  }\n  toString(data: LngLatArray) {\n    const d = data.map(x => x.toFixed(5));\n    return d[0] + '_' + d[1];\n  }\n  parse(str: string) {\n    const lngLat = str.split('_').map(Number) as LngLatArray;\n    return lngLat;\n  }\n}\n","import { StateItem } from './StateItem';\nimport { WebMapEvents } from '../../interfaces/Events';\nimport { MapOptions } from '../../interfaces/WebMapApp';\n\nexport class ZoomState extends StateItem<number> {\n  name: keyof MapOptions = 'zoom';\n  event: keyof WebMapEvents = 'zoomend';\n  getValue() {\n    return this.webMap.getZoom();\n  }\n  setValue(val: number) {\n    this.webMap.setZoom(val);\n  }\n  toString(val: number) {\n    return String(val);\n  }\n  parse(str: string) {\n    return Number(str);\n  }\n}\n","/**\n * @module webmap\n */\nimport { deepmerge } from '@nextgis/utils';\nimport { GetPaintFunction } from './interfaces/LayerAdapter';\nimport { LayerAdapter } from './interfaces/LayerAdapter';\nimport {\n  MapAdapter,\n  FitOptions,\n  LocateOptions,\n  LocationEvents,\n  Locate\n} from './interfaces/MapAdapter';\nimport { MapOptions, AppOptions } from './interfaces/WebMapApp';\nimport {\n  LngLatBoundsArray,\n  Type,\n  Cursor,\n  LngLatArray\n} from './interfaces/BaseTypes';\nimport { RuntimeParams } from './interfaces/RuntimeParams';\nimport { StarterKit } from './interfaces/StarterKit';\n\nimport { createToggleControl } from './components/controls/ToggleControl';\n\nimport { Keys } from './components/keys/Keys';\n\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\nimport { WebMapEvents, BaseMapEvents } from './interfaces/Events';\n\nimport { onLoad } from './util/decorators';\nimport { propertiesFilter } from './util/propertiesFilter';\nimport { clearObject } from './util/clearObject';\nimport { getBoundsPolygon } from './util/getBoundsPolygon';\n\nimport {\n  detectGeometryType,\n  findMostFrequentGeomType\n} from './util/geometryTypes';\nimport { updateGeoJsonAdapterOptions } from './util/updateGeoJsonAdapterOptions';\n\nimport { CenterState } from './components/mapStates/CenterState';\nimport { ZoomState } from './components/mapStates/ZoomState';\nimport { StateItem } from './components/mapStates/StateItem';\nimport { Feature, Polygon } from 'geojson';\n\nconst OPTIONS: MapOptions = {\n  minZoom: 0,\n  maxZoom: 21,\n  paint: {\n    color: 'blue',\n    opacity: 1,\n    radius: 8,\n    weight: 1\n  },\n  selectedPaint: {\n    color: 'darkblue',\n    opacity: 1,\n    radius: 12,\n    weight: 1\n  }\n};\n\n/**\n * @class WebMap\n */\nexport class BaseWebMap<\n  M = any,\n  L = any,\n  C = any,\n  E extends WebMapEvents = WebMapEvents\n> {\n  static keys: Keys = new Keys();\n  static utils = {\n    detectGeometryType,\n    findMostFrequentGeomType,\n    updateGeoJsonAdapterOptions,\n    propertiesFilter,\n    createToggleControl,\n    getBoundsPolygon\n  };\n  static getPaintFunctions: { [name: string]: GetPaintFunction };\n  static decorators = { onLoad };\n\n  options: MapOptions = OPTIONS;\n  // `WebMapEvents` must be `E` but its not work correct\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    WebMapEvents\n  > = new EventEmitter();\n  readonly keys = BaseWebMap.keys;\n\n  readonly mapAdapter: MapAdapter<M>;\n  readonly runtimeParams: RuntimeParams[] = [];\n\n  getPaintFunctions = BaseWebMap.getPaintFunctions;\n  mapState: Type<StateItem>[] = [CenterState, ZoomState];\n\n  /**\n   * From runtime params\n   */\n  protected _initMapState: Record<string, any> = {};\n  protected readonly _starterKits: StarterKit[];\n  private _mapState: StateItem[] = [];\n  private _extent?: LngLatBoundsArray;\n  private readonly _eventsStatus: { [key in keyof E]?: boolean } = {};\n\n  private readonly _mapEvents: Record<string, (...args: any[]) => void> = {};\n\n  constructor(appOptions: AppOptions) {\n    this.mapAdapter = appOptions.mapAdapter;\n    this._starterKits = appOptions.starterKits || [];\n    if (appOptions.mapOptions) {\n      this.options = deepmerge(OPTIONS || {}, appOptions.mapOptions);\n    }\n    if (appOptions.runtimeParams) {\n      this.runtimeParams = appOptions.runtimeParams;\n    }\n    this._addEventsListeners();\n    if (appOptions.create) {\n      this.create(this.options);\n    }\n  }\n\n  /**\n   * Manual way to create a map. On default\n   * @example\n   * ```javascript\n   * const webMap = new WebMap(options);\n   * webMap.create(mapOptions).then(() => doSomething());\n   * ```\n   */\n  async create(options?: MapOptions): Promise<this> {\n    if (!this.getEventStatus('create')) {\n      this.options = deepmerge(OPTIONS || {}, options);\n      await this._setInitMapState(this.mapState);\n      await this._setupMap();\n      this._emitStatusEvent('create', this);\n    }\n    return this;\n  }\n\n  setRuntimeParams(params: RuntimeParams) {\n    this.runtimeParams.push(params);\n  }\n\n  /**\n   * Destroys WebMap, MapAdapter, clears all layers and turn off all event listeners\n   */\n  destroy() {\n    this._removeEventsListeners();\n    clearObject(this._emitStatusEvent);\n    if (this.mapAdapter.destroy) {\n      this.mapAdapter.destroy();\n    }\n  }\n\n  getState(): Record<string, any> {\n    const state: Record<string, any> = {};\n    this._mapState.forEach(x => {\n      state[x.name] = x.getValue();\n    });\n    return state;\n  }\n\n  getRuntimeParams(): Record<string, any> {\n    const state: Record<string, any> = {};\n    this._mapState.forEach(x => {\n      for (const r of this.runtimeParams) {\n        const val = r.get(x.name);\n        if (val !== undefined) {\n          state[x.name] = x.parse(val);\n          break;\n        }\n      }\n    });\n    return state;\n  }\n\n  /**\n   * Returns the HTML element that contains the map.\n   * @returns The map's container\n   */\n  getContainer(): HTMLElement | undefined {\n    if (this.mapAdapter.getContainer) {\n      return this.mapAdapter.getContainer();\n    } else if (this.options.target) {\n      if (this.options.target instanceof HTMLElement) {\n        return this.options.target;\n      } else if (typeof this.options.target === 'string') {\n        const element = document.getElementById(this.options.target);\n        if (element) {\n          return element;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the cursor icon to be displayed when hover icon on the map container.\n   * @param cursor available cursor name from https://developer.mozilla.org/ru/docs/Web/CSS/cursor\n   */\n  setCursor(cursor: Cursor) {\n    if (this.mapAdapter.setCursor) {\n      this.mapAdapter.setCursor(cursor);\n    }\n  }\n\n  /**\n   * Set the center of the current view.\n   * @param lngLat Array of two numbers representing longitude and latitude of the center of the map view.\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27 59 17 N, 86 55 31 E\n   * webMap.setCenter([86.925278, 27.988056]);\n   * ```\n   */\n  setCenter(lngLat: LngLatArray): this {\n    this.mapAdapter.setCenter(lngLat);\n    return this;\n  }\n\n  /**\n   * Returns the map's geographical centerpoint.\n   * @return lngLat Array of two numbers representing longitude and latitude of the center of the map view.\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27 59 17 N, 86 55 31 E\n   * webMap.getCenter(); // [86.925278, 27.988056]\n   * ```\n   */\n  getCenter(): LngLatArray | undefined {\n    return this.mapAdapter.getCenter();\n  }\n\n  getBounds(): LngLatBoundsArray | undefined {\n    if (this.mapAdapter.getBounds) {\n      return this.mapAdapter.getBounds();\n    }\n  }\n\n  getBoundsPolygon(): Feature<Polygon> | undefined {\n    const bounds = this.getBounds();\n    if (bounds) {\n      const feature = getBoundsPolygon(bounds);\n      return feature;\n    }\n  }\n\n  /**\n   * Zoom to a specific zoom level.\n   * @param zoom The zoom level to set (0-24).\n   */\n  setZoom(zoom: number): this {\n    this.mapAdapter.setZoom(zoom);\n    return this;\n  }\n\n  /**\n   * Returns the map's current zoom level.\n   * @return The map's current zoom level (0-24).\n   */\n  getZoom(): number | undefined {\n    return this.mapAdapter.getZoom();\n  }\n\n  /**\n   * Sets the view of the map geographical center and zoom\n   * @param lngLat Array of two numbers representing longitude and latitude of the center of the map view.\n   * @param zoom The zoom level to set (0-24).\n   *\n   * @example\n   * ```javascript\n   * // Mount Everest 27 59 17 N, 86 55 31 E\n   * webMap.setView([86.925278, 27.988056], 12)\n   * ```\n   */\n  setView(lngLat?: LngLatArray, zoom?: number) {\n    if (this.mapAdapter.setView && lngLat && zoom) {\n      this.mapAdapter.setView(lngLat, zoom);\n    } else {\n      if (lngLat) {\n        this.mapAdapter.setCenter(lngLat);\n      }\n      if (zoom) {\n        this.mapAdapter.setZoom(zoom);\n      }\n    }\n  }\n\n  /**\n   * Sets a map view that contains the given geographical bounds.\n   * @param bounds Array of coordinates, measured in degrees, in [west, south, east, north] order.\n   * @param options\n   *\n   * @example\n   * ```javascript\n   * // Whall world\n   * webMap.fitBounds([0, -90, 180, 90]);\n   * ```\n   */\n  fitBounds(bounds: LngLatBoundsArray, options?: FitOptions): this {\n    this.mapAdapter.fitBounds(bounds, options);\n    return this;\n  }\n\n  /**\n   * Checking the status of any asynchronous operation\n   * @param event The name of the event whose status is checked\n   *\n   * @example\n   * ```javascript\n   * var webMap = new WebMap(options);\n   * webMap.getEventStatus('create'); // false\n   * webMap.emitter.on('create', function () {\n   *   webMap.getEventStatus('create'); // true\n   * })\n   * ```\n   */\n  getEventStatus(event: keyof E): boolean {\n    // ugly hack to disable type checking error\n    const _eventName = event as keyof WebMapEvents;\n    const status = this._eventsStatus[_eventName];\n    return status !== undefined ? status : false;\n  }\n\n  /**\n   * helper method to wait for events to load. By default, card creation is tracked\n   * @param event The name of the event whose status is checked\n   *\n   * @example\n   * ```javascript\n   * var webMap = new WebMap(options);\n   * webMap.onLoad().then(function () {\n   *   webMap.getEventStatus('create'); // true\n   * })\n   *\n   * // use async/await syntax\n   * async function () {\n   *   await webMap.onLoad();\n   *   doSomething();\n   * }\n   *\n   * ```\n   */\n  onLoad(event: keyof WebMapEvents = 'create'): Promise<this> {\n    return new Promise(res => {\n      if (this.getEventStatus(event)) {\n        res(this);\n      } else {\n        this.emitter.once(event, () => {\n          res(this);\n        });\n      }\n    });\n  }\n\n  onMapLoad(cb?: (mapAdapter: MapAdapter) => void): Promise<MapAdapter> {\n    return new Promise(res => {\n      const _resolve = () => {\n        const mapAdapter = this.mapAdapter;\n        if (cb) {\n          cb(mapAdapter);\n        }\n        if (mapAdapter) {\n          res(mapAdapter);\n        }\n      };\n      const isLoaded =\n        this.mapAdapter.isLoaded !== undefined\n          ? this.mapAdapter.isLoaded\n          : true;\n      if (this.mapAdapter.map && isLoaded) {\n        _resolve();\n      } else {\n        this.mapAdapter.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  getLayerAdapters(): { [name: string]: Type<LayerAdapter> } {\n    return this.mapAdapter.layerAdapters;\n  }\n\n  getLayerAdapter(name: string): Type<LayerAdapter> {\n    const adapter = this.mapAdapter.layerAdapters[name];\n    return adapter;\n  }\n\n  locate(opt: LocateOptions, events?: LocationEvents): Locate {\n    if (this.mapAdapter && this.mapAdapter.locate) {\n      return this.mapAdapter.locate(opt, events);\n    }\n    const stop = () => ({});\n    return { stop };\n  }\n\n  protected _emitStatusEvent(eventName: keyof E, data?: any) {\n    // ugly hack to disable type checking error\n    const _eventName = eventName as keyof WebMapEvents;\n    this._eventsStatus[_eventName] = true;\n    this.emitter.emit(_eventName, data);\n  }\n\n  protected async _addLayerProviders(): Promise<void> {\n    //\n  }\n\n  protected async _onLoadSync(): Promise<void> {\n    //\n  }\n\n  private async _setupMap() {\n    await this.mapAdapter.create(this.options);\n    this._zoomToInitialExtent();\n\n    await this._addLayerProviders();\n    await this._onLoadSync();\n\n    this._emitStatusEvent('build-map', this.mapAdapter);\n    return this;\n  }\n\n  private _zoomToInitialExtent() {\n    const { center, zoom, bounds } = this.options;\n    if (this._extent) {\n      this.fitBounds(this._extent);\n    } else if (center && zoom) {\n      this.setView(center, zoom);\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  private _setInitMapState(states: Type<StateItem>[]) {\n    for (const X of states) {\n      const state = new X(this);\n      this._mapState.push(state);\n      for (const r of this.runtimeParams) {\n        const str = r.get(state.name);\n        if (str !== undefined) {\n          const val = state.parse(str);\n          // state.setValue(val);\n          this._initMapState[state.name] = val;\n          this.options[state.name] = val;\n          break;\n        }\n      }\n    }\n  }\n\n  private _addEventsListeners(): void {\n    const events: (keyof BaseMapEvents)[] = [\n      'click',\n      'zoomstart',\n      'zoom',\n      'zoomend',\n      'movestart',\n      'move',\n      'moveend'\n    ];\n    events.forEach(x => {\n      this._mapEvents[x] = data => {\n        if (this.runtimeParams.length) {\n          const mapStatusEvent = this._mapState.find(y => y.event === x);\n          if (mapStatusEvent) {\n            const value = mapStatusEvent.toString(mapStatusEvent.getValue());\n            this.runtimeParams.forEach(r => {\n              r.set(mapStatusEvent.name, value);\n            });\n          }\n        }\n        if (this._eventsStatus) {\n          this.emitter.emit(x, data);\n        }\n      };\n      this.mapAdapter.emitter.on(x, this._mapEvents[x]);\n    });\n  }\n\n  private _removeEventsListeners(): void {\n    Object.entries(this._mapEvents).forEach(([x, event]) => {\n      this.mapAdapter.emitter.off(x, event);\n    });\n  }\n}\n","export function clearObject(obj: Record<any, any>): void {\n  for (const member in obj) {\n    delete obj[member];\n  }\n}\n","/**\n * @module webmap\n */\nimport {\n  LayerAdapter,\n  LayerAdapters,\n  AdapterConstructor,\n  LayerAdaptersOptions,\n  AdapterOptions,\n  GeoJsonAdapterOptions,\n  VectorLayerAdapter,\n  DataLayerFilter,\n  OnLayerClickOptions,\n  PropertiesFilter,\n  FilterOptions,\n  LayerDefinition\n} from './interfaces/LayerAdapter';\nimport { LayerDef, Type } from './interfaces/BaseTypes';\n\nimport { Feature, GeoJsonObject } from 'geojson';\nimport { preparePaint } from './util/preparePaint';\nimport { updateGeoJsonAdapterOptions } from './util/updateGeoJsonAdapterOptions';\nimport {\n  GetAttributionsOptions,\n  ToggleLayerOptions\n} from './interfaces/WebMapApp';\nimport { propertiesFilter } from './util/propertiesFilter';\nimport { BaseWebMap } from './BaseWebMap';\nimport { WebMapEvents } from './interfaces/Events';\n\nexport class WebMapLayers<\n  M = any,\n  L = any,\n  C = any,\n  E extends WebMapEvents = WebMapEvents\n> extends BaseWebMap<M, L, C, E> {\n  private _layersIdCounter = 1;\n  private _layersOrderCounter = 1;\n  private readonly _baseLayers: string[] = [];\n  private readonly _layers: { [id: string]: LayerAdapter } = {};\n  private readonly _layersOrderList: number[] = [];\n  private readonly _selectedLayers: string[] = [];\n\n  /**\n   * Try to fit map view by given layer bounds.\n   * But not all layers have borders\n   * @param layerDef\n   */\n  async fitLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    if (layer && layer.getExtent) {\n      const extent = await layer.getExtent();\n      if (extent) {\n        this.fitBounds(extent);\n      }\n    }\n  }\n\n  /**\n   * Check if given layer is baselayer\n   * @param layerName Check\n   */\n  isBaseLayer(layerDef: LayerDef): boolean | undefined {\n    const layer = this.getLayer(layerDef);\n    if (layer && layer.id) {\n      return this._baseLayers.indexOf(layer.id) !== -1;\n    }\n    return undefined;\n  }\n\n  getBaseLayers() {\n    return this._baseLayers;\n  }\n\n  /**\n   * Helper method to return added layer object by any definition type.\n   */\n  getLayer<LA extends LayerAdapter = LayerAdapter>(\n    layerDef: LayerDef\n  ): LA | undefined {\n    if (typeof layerDef === 'string') {\n      return this._layers[layerDef] as LA;\n    }\n    return layerDef as LA;\n  }\n\n  /**\n   * Helper method to return added layer identificator by any definition type.\n   */\n  getLayerId(layerDef: LayerDef): string | undefined {\n    const layer = this.getLayer(layerDef);\n    if (layer && layer.options) {\n      return layer.options.id;\n    } else {\n      throw new Error('No id for layer');\n    }\n  }\n\n  /**\n   * Return array of all added layer identifications.\n   */\n  getLayers(): string[] {\n    return Object.keys(this._layers);\n  }\n\n  // TODO: rename to getLayers, getLayers rename to getLayersIds\n  allLayers() {\n    return this._layers;\n  }\n\n  findLayer<T extends LayerAdapter = LayerAdapter>(\n    filter: (adapter: T) => boolean\n  ): T | undefined {\n    for (const l in this._layers) {\n      const layerAdapter = this._layers[l] as T;\n      const isFit = filter(layerAdapter);\n      if (isFit) {\n        return layerAdapter;\n      }\n    }\n  }\n\n  /**\n   * Check if the given layer on the map\n   */\n  isLayerVisible(layerDef: LayerDef): boolean {\n    const layer = this.getLayer(layerDef);\n    return layer && layer.options.visibility !== undefined\n      ? layer.options.visibility\n      : false;\n  }\n\n  /**\n   * Shortcut method to create base layer\n   * @param adapter\n   * @param options\n   */\n  async addBaseLayer<\n    K extends keyof LayerAdapters,\n    O extends AdapterOptions = AdapterOptions\n  >(\n    adapter: K | Type<LayerAdapters[K]>,\n    options: O | LayerAdaptersOptions[K]\n  ): Promise<LayerAdapter> {\n    const layer = await this.addLayer(adapter, {\n      ...options,\n      baseLayer: true\n    });\n\n    return layer;\n  }\n\n  /**\n   * Registration of map layer.\n   *\n   * @param adapter The name of layer adapter from [MapAdapter.layerAdapters](webmap#MapAdapter.layerAdapters).\n   *                May be custom object or class implemented by [BaseLayerAdapter](webmap#BaseLayerAdapter).\n   * @param options Specific options for given adapter\n   *\n   * @example\n   * ```javascript\n   * webMap.addLayer('TILE', options).then((layer) => webMap.showLayer(layer));\n   *\n   * webMap.addLayer(CustomLayerAdapter, options);\n   * ```\n   */\n  async addLayer<\n    K extends keyof LayerAdapters,\n    O extends AdapterOptions = AdapterOptions\n  >(\n    adapter:\n      | K\n      | Type<LayerAdapters[K]>\n      | Promise<Type<LayerAdapters[K]> | undefined>,\n    options: O | LayerAdaptersOptions[K],\n    order?: number\n  ): Promise<LayerAdapter> {\n    const id = this._layersIdCounter++;\n    const _order =\n      order !== undefined\n        ? order\n        : options.order !== undefined\n        ? options.order\n        : this._layersOrderCounter++;\n    let adapterEngine: Type<LayerAdapter> | undefined;\n    if (typeof adapter === 'string') {\n      adapterEngine = this.getLayerAdapter(adapter);\n    } else if (typeof adapter === 'function') {\n      adapterEngine = adapter as Type<LayerAdapter>;\n    } else if (\n      'then' in (adapter as Promise<Type<LayerAdapters[K]> | undefined>)\n    ) {\n      adapterEngine = (await adapter) as Type<LayerAdapters[K]>;\n    }\n\n    const geoJsonOptions = options as GeoJsonAdapterOptions;\n\n    this._updateGeoJsonOptions(geoJsonOptions);\n\n    const { maxZoom, minZoom } = this.options;\n\n    options = {\n      id: String(id),\n      order: _order,\n      maxZoom,\n      minZoom,\n      ...options\n    };\n    // options.visibility is a layer global state, but each layer on init is not visible\n    const visibility = options.visibility;\n    options.visibility = false;\n\n    // TODO: check usage in adapter constructor and safe remove\n    if (options.baseLayer) {\n      options.order = 0;\n    }\n    if (this.options.onBeforeAddLayer) {\n      const modified = this.options.onBeforeAddLayer({\n        options,\n        adapter: adapterEngine\n      });\n      if (modified) {\n        if (modified.options) {\n          options = modified.options;\n        }\n        if (modified.adapter) {\n          adapterEngine = modified.adapter;\n        }\n      }\n    }\n    if (adapterEngine !== undefined) {\n      const _adapter = new adapterEngine(this.mapAdapter.map, options);\n      if (_adapter.options.baseLayer) {\n        options.baseLayer = true;\n        options.order = 0;\n      }\n\n      let layerId = _adapter.options.id;\n      if (layerId) {\n        this._layers[layerId] = _adapter;\n      }\n      this.emitter.emit('layer:preadd', _adapter);\n      await this.onMapLoad();\n      const layer = await _adapter.addLayer(options);\n      // checking that the original layer was inserted into the adapter anyway\n      _adapter.layer = layer;\n      // think about how to move `id` to the adapter's constructor,\n      // but that it is not required in the options\n      _adapter.id = _adapter.options.id || String(id);\n      _adapter.order = _adapter.options.order || _order;\n\n      layerId = _adapter.options.id;\n      if (layerId) {\n        if (geoJsonOptions.filter) {\n          this.filterLayer(_adapter, geoJsonOptions.filter);\n        }\n        if (options.baseLayer) {\n          this._baseLayers.push(layerId);\n        }\n        this._layers[layerId] = _adapter;\n\n        if (visibility) {\n          this.showLayer(layerId);\n        }\n      }\n      const opacity = options.opacity;\n      if (opacity !== undefined && opacity <= 1) {\n        this.setLayerOpacity(_adapter, opacity);\n      }\n      if (options.fit && _adapter.getExtent) {\n        const extent = await _adapter.getExtent();\n        if (extent) {\n          await this.fitBounds(extent);\n        }\n      }\n      this.emitter.emit('layer:add', _adapter);\n      return _adapter;\n    }\n    return Promise.reject('No adapter');\n  }\n\n  async addLayerFromAsyncAdapter<\n    K extends keyof LayerAdapters,\n    O extends AdapterOptions = AdapterOptions\n  >(\n    adapter: AdapterConstructor,\n    options: O | LayerAdaptersOptions[K],\n    order?: number\n  ): Promise<LayerAdapter> {\n    const _order =\n      order || options.order !== undefined\n        ? options.order\n        : 0 || this._layersOrderCounter++;\n    const adapterConstructor = adapter as AdapterConstructor;\n    const adapterConstructorPromise = adapterConstructor();\n    const adapterEngine = await adapterConstructorPromise;\n    if (adapterEngine) {\n      return this.addLayer(adapterEngine, options, _order);\n    }\n    return Promise.reject('No adapter');\n  }\n\n  /**\n   * Remove all layer from map and memory.\n   */\n  removeLayers(allowCb?: (layer: string, adapter: LayerAdapter) => boolean) {\n    for (const l in this._layers) {\n      let allow = true;\n      if (allowCb) {\n        allow = allowCb(l, this._layers[l]);\n      }\n      if (allow) {\n        this.removeLayer(l);\n        delete this._layers[l];\n      }\n    }\n  }\n\n  /**\n   * Remove all layers but not remove basemap.\n   */\n  removeOverlays() {\n    this.removeLayers((layerId, layer) => !layer.options.baseLayer);\n  }\n\n  /**\n   * Remove specific layer from map and memory by its definition.\n   * @param layerDef\n   */\n  removeLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    const layerId = layer && this.getLayerId(layer);\n    if (layer && layerId) {\n      this.emitter.emit('layer:preremove', layer);\n      if (layer.beforeRemove) {\n        layer.beforeRemove();\n      }\n      if (layer.removeLayer) {\n        layer.removeLayer();\n      } else {\n        this.mapAdapter.removeLayer(layer.layer);\n      }\n      if (layer.options && layer.options.baseLayer) {\n        const index = this._baseLayers.indexOf(layerId);\n        if (index) {\n          this._baseLayers.splice(index, 1);\n        }\n      }\n      delete this._layers[layerId];\n      this.emitter.emit('layer:remove', layer);\n    }\n  }\n\n  /**\n   * Create layer from GeoJson data. Set style and behavior for selection.\n   *\n   * @example\n   * ```javascript\n   * // Add simple layer\n   * webMap.addGeoJsonLayer({ data: geojson, paint: { color: 'red' } });\n   *\n   * // Add styled by feature property layer with selection behavior\n   * webMap.addGeoJsonLayer({\n   *   data: geojson,\n   *   paint: function (feature) {\n   *     return { color: feature.properties.color, opacity: 0.5 }\n   *   },\n   *  selectedPaint: function (feature) {\n   *    return { color: feature.properties.selcolor, opacity: 1 }\n   *  },\n   *  selectable: true,\n   *  multiselect: true\n   * });\n   *\n   * // Add marker layer styled with use [Icons](icons)\n   * webMap.addGeoJsonLayer({ data: geojson, paint: webMap.getIcon({ color: 'orange' })});\n   *\n   * // work with added layer\n   * const layer = webMap.addGeoJsonLayer({ data: geojson, id: 'my_layer_name'});\n   * // access layer by id\n   * webMap.showLayer('my_layer_name');\n   * // or access layer by instance\n   * webMap.showLayer(layer);\n   * ```\n   */\n  // @onMapLoad()\n  async addGeoJsonLayer<K extends keyof LayerAdaptersOptions>(\n    opt: GeoJsonAdapterOptions,\n    adapter?: K | Type<LayerAdapter>\n  ) {\n    opt = opt || {};\n    opt.multiselect = opt.multiselect !== undefined ? opt.multiselect : false;\n    opt.unselectOnSecondClick =\n      opt.unselectOnSecondClick !== undefined\n        ? opt.unselectOnSecondClick\n        : true;\n    if (!adapter) {\n      opt = updateGeoJsonAdapterOptions(opt);\n    }\n    opt.paint = opt.paint || {};\n    const layer = await this.addLayer(adapter || 'GEOJSON', opt);\n    this.showLayer(layer);\n    return layer;\n  }\n\n  /**\n   * Show added layer on the map by it definition.\n   */\n  showLayer(layerDef: LayerDef, options: ToggleLayerOptions = {}) {\n    this.toggleLayer(layerDef, true, options);\n  }\n\n  /**\n   * Hide added layer on the map by it definition.\n   */\n  hideLayer(layerDef: LayerDef, options: ToggleLayerOptions = {}) {\n    this.toggleLayer(layerDef, false, options);\n  }\n\n  /**\n   * Change added layer visibility on the map by given status or inverse current status.\n   *\n   * @example\n   * ```javascript\n   * webMap.addLayer('TILE', {id: 'my_layer', url: ''}).then((layer) => {\n   *   webMap.toggleLayer(layer, true);\n   *   webMap.toggleLayer('my_layer', false);\n   *   webMap.toggleLayer('my_layer');\n   *   webMap.isLayerVisible(layer); // true\n   * });\n   * ```\n   */\n  toggleLayer(\n    layerDef: LayerDef,\n    status?: boolean,\n    options: ToggleLayerOptions = {}\n  ) {\n    const layer = this.getLayer(layerDef);\n    const onMap = layer && layer.options.visibility;\n    const toStatus = status !== undefined ? status : !onMap;\n    const silent = options.silent !== undefined ? options.silent : false;\n    const action = (source: any, l: LayerAdapter) => {\n      l.options.visibility = toStatus;\n\n      const preEventName = toStatus ? 'layer:preshow' : 'layer:prehide';\n      const eventName = toStatus ? 'layer:show' : 'layer:hide';\n      if (!silent) {\n        this.emitter.emit(preEventName, l);\n      }\n      if (toStatus && source) {\n        const order = l.options.baseLayer ? 0 : l.options.order;\n\n        // do not show baselayer if another on the map\n        if (order === 0 && this._baseLayers.length) {\n          const anotherVisibleLayerBaseLayer = this._baseLayers.find(x => {\n            return x !== l.id && this.isLayerVisible(x);\n          });\n          if (anotherVisibleLayerBaseLayer) {\n            this.hideLayer(anotherVisibleLayerBaseLayer);\n          }\n        }\n\n        if (l.showLayer) {\n          l.showLayer.call(l, l.layer);\n        } else {\n          this.mapAdapter.showLayer(l.layer);\n        }\n        if (order !== undefined) {\n          this.mapAdapter.setLayerOrder(l.layer, order, this._layers);\n        }\n      } else {\n        if (l.hideLayer) {\n          l.hideLayer.call(l, l.layer);\n        } else {\n          this.mapAdapter.hideLayer(l.layer);\n        }\n      }\n      if (!silent) {\n        this.emitter.emit(eventName, l);\n      }\n    };\n    if (layer && layer.options.visibility !== toStatus) {\n      if (this.mapAdapter.map) {\n        action(this.mapAdapter, layer);\n      } else {\n        this.mapAdapter.emitter.once('create', adapter => {\n          action(adapter.map, layer);\n        });\n      }\n    }\n  }\n\n  updateLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      if (layer.updateLayer) {\n        layer.updateLayer();\n      } else if (this.isLayerVisible(layer)) {\n        this.hideLayer(layer, { silent: true });\n        this.showLayer(layer, { silent: true });\n      }\n    }\n  }\n\n  /**\n   * Set transparency for a given layer by number from 0 to 1\n   */\n  setLayerOpacity(layerDef: LayerDef, value: number) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      if (this.mapAdapter.setLayerOpacity) {\n        if (layer) {\n          this.mapAdapter.setLayerOpacity(layer.layer, value);\n        }\n      }\n    }\n  }\n\n  // requestGeomString(pixel: Pixel, pixelRadius: number) {\n  //   if (this.mapAdapter.requestGeomString) {\n  //     return this.mapAdapter.requestGeomString(pixel, pixelRadius);\n  //   }\n  // }\n\n  /**\n   * Mark the layer as selected.\n   * If the adapter is a vector layer and supports data selection,\n   * you can pass a callback function to specify which data will be selected.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.selectLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n   * @param layerDef\n   * @param findFeatureFun\n   */\n  selectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const adapter = layer as VectorLayerAdapter;\n      if (adapter && adapter.select) {\n        adapter.select(findFeatureFun);\n      }\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        this._selectedLayers.push(layerId);\n      }\n    }\n  }\n\n  /**\n   * Unselect the given layer.\n   * If the adapter is a vector layer and supports data selection,\n   * you can pass a callback function to specify which data will be unselected.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.unSelectLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n   *\n   * @param layerDef\n   * @param findFeatureFun\n   */\n  unSelectLayer(layerDef: LayerDef, findFeatureFun?: DataLayerFilter) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const adapter = layer && (layer as VectorLayerAdapter);\n      if (adapter.unselect) {\n        adapter.unselect(findFeatureFun);\n      }\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        const index = this._selectedLayers.indexOf(layerId);\n        if (index !== -1) {\n          this._selectedLayers.splice(index, 1);\n        }\n      }\n    }\n  }\n\n  /**\n   * Hide features from a vector layer using a callback function.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.filterLayer(layer, ({feature}) => feature.id === '42');\n   * });\n   * ```\n   *\n   * @param layerDef\n   * @param filter\n   */\n  filterLayer(\n    layerDef: LayerDef,\n    filter: DataLayerFilter<Feature, L>\n  ): LayerDefinition<Feature, L>[] {\n    const layer = this.getLayer(layerDef);\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.filter) {\n      return adapter.filter(filter);\n    }\n    return [];\n  }\n\n  propertiesFilter(\n    layerDef: LayerDef,\n    filters: PropertiesFilter,\n    options?: FilterOptions\n  ) {\n    const layer = this.getLayer(layerDef);\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.propertiesFilter) {\n      adapter.propertiesFilter(filters, options);\n    } else if (adapter.filter) {\n      this.filterLayer(adapter, e => {\n        if (e.feature && e.feature.properties) {\n          return propertiesFilter(e.feature.properties, filters);\n        }\n        return true;\n      });\n    }\n  }\n\n  removeLayerFilter(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    const adapter = layer as VectorLayerAdapter;\n    if (adapter.removeFilter) {\n      adapter.removeFilter();\n    } else if (adapter.filter) {\n      adapter.filter(() => {\n        return true;\n      });\n    }\n  }\n\n  /**\n   * Sets the GeoJSON data for given vector layer.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON').then((layer) => {\n   *   webMap.setLayerData(layer, geojson);\n   * });\n   * ```\n   */\n  setLayerData(layerDef: LayerDef, data: GeoJsonObject) {\n    const vectorAdapter = this.getLayer(layerDef);\n    const adapter = vectorAdapter as VectorLayerAdapter;\n    if (adapter) {\n      if (adapter.setData) {\n        adapter.setData(data);\n      } else if (adapter.clearLayer && adapter.addData) {\n        adapter.clearLayer();\n        adapter.addData(data);\n      }\n    }\n  }\n\n  /**\n   * Push new the GeoJSON features into given vector layer.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson_features_5}).then((layer) => {\n   *   console.log(layer.getLayers().length) // > 5;\n   *   webMap.addLayerData(layer, geojson_features_3);\n   *   console.log(layer.getLayers().length) // > 8;\n   * });\n   * ```\n   */\n  addLayerData(layerDef: LayerDef, data: GeoJsonObject) {\n    const layerMem = this.getLayer(layerDef);\n    const adapter = layerMem as VectorLayerAdapter;\n    if (adapter.addData) {\n      adapter.addData(data);\n    }\n  }\n\n  /**\n   * Remove from vector layer all features.\n   * it is possible to remove only some objects if you specify a callback function.\n   *\n   * @example\n   * ```javascript\n   * const layer = webMap.addLayer('GEOJSON', {data: geojson}).then((layer) => {\n   *   webMap.clearLayerData(layer, (feture) => feture.id === 42);\n   *   webMap.clearLayerData(layer);\n   * });\n   * ```\n   */\n  clearLayerData(layerDef: LayerDef, cb?: (feature: Feature) => boolean) {\n    const layerMem = this.getLayer(layerDef);\n    const adapter = layerMem as VectorLayerAdapter;\n    if (adapter && adapter.clearLayer) {\n      adapter.clearLayer(cb);\n    }\n  }\n\n  getAttributions(options: GetAttributionsOptions): string[] {\n    const attributions: string[] = [];\n    for (const l in this._layers) {\n      const layerMem = this._layers[l];\n      const onlyVisible =\n        options.onlyVisible !== undefined ? options.onlyVisible : true;\n      const useLayerAttr = onlyVisible ? layerMem.options.visibility : true;\n      if (useLayerAttr) {\n        const attr = layerMem.options && layerMem.options.attribution;\n        if (attr) {\n          attributions.push(attr);\n        }\n      }\n    }\n\n    return attributions;\n  }\n\n  getActiveBaseLayer() {\n    const visibleLayerBaseLayer = this.getBaseLayers().find(x => {\n      return this.isLayerVisible(x);\n    });\n    if (visibleLayerBaseLayer) {\n      return this.getLayer(visibleLayerBaseLayer);\n    }\n  }\n\n  private async _onLayerClick(options: OnLayerClickOptions) {\n    this.emitter.emit('layer:click', options);\n    return Promise.resolve(options);\n  }\n\n  private _updateGeoJsonOptions(options: GeoJsonAdapterOptions) {\n    const onLayerClickFromOpt = options.onLayerClick;\n    options.onLayerClick = e => {\n      if (onLayerClickFromOpt) {\n        onLayerClickFromOpt(e);\n      }\n      return this._onLayerClick(e);\n    };\n    if (!options.nativePaint) {\n      if (this.options.paint) {\n        options.paint = preparePaint(\n          options.paint || {},\n          this.options.paint,\n          this.getPaintFunctions\n        );\n      }\n      if (options.selectedPaint && this.options.selectedPaint) {\n        options.selectedPaint = preparePaint(\n          options.selectedPaint,\n          this.options.selectedPaint,\n          this.getPaintFunctions\n        );\n      }\n    }\n  }\n}\n","/**\n * @module webmap\n *\n * Since it was not possible to split the code through mixins, inheritance was used.\n * The `ts-mixin` plugin worked fine, but led to errors in IE.\n *\n * Now inheritance is as follow:\n * BaseWebMap > WebMapLayers > WebMap\n *\n * Will need to be done this way:\n * class WebMap extend mixin(WebMapLayers, WebMapControls) {}\n *\n * This approach can also be considered\n *\n * class WebMap {\n *   layers: WebMapLayers;\n *   controls  WebMapControls\n * }\n *\n * and then\n *\n * const webMap = new WebMap(...);\n * webMap.layers.addLayer(...)\n *\n * looks good, but will add difficulty in inheriting from WebMap\n *\n * old:\n *\n * class NgwMap extends WebMap {\n *   addLayer(...) {\n *      super.addLayer(...)\n *   }\n * }\n *\n * new:\n *\n * class NgwLayers extends WebMapLayers {\n *   addLayer(...) {\n *     super.addLayer(...)\n *   }\n * }\n *\n * class NgwMap extends WebMap {\n *   layersClass = NgwLayers\n * }\n *\n * ...and there will be compatibility issues\n *\n */\n\nimport { WebMapEvents } from './interfaces/Events';\n\nimport {\n  MapControl,\n  CreateControlOptions,\n  ButtonControlOptions,\n  ToggleControlOptions,\n  ToggleControl,\n  MapControls\n} from './interfaces/MapControl';\n\nimport { ControlPositions } from './interfaces/MapAdapter';\nimport { WebMapLayers } from './WebMapLayers';\n\nexport class WebMap<\n  M = any,\n  L = any,\n  C = any,\n  E extends WebMapEvents = WebMapEvents\n> extends WebMapLayers<M, L, C, E> {\n  static controls: {\n    [name: string]: (webMap: WebMap, options?: any) => any;\n  } = {\n    CONTROL: (\n      webMap: WebMap,\n      options: {\n        control: MapControl;\n        options?: CreateControlOptions;\n      }\n    ) => {\n      return webMap.createControl(options.control, options.options);\n    },\n    BUTTON: (webMap: WebMap, options: ButtonControlOptions) => {\n      return webMap.createButtonControl(options);\n    },\n    TOGGLE: (webMap: WebMap, options: ToggleControlOptions) => {\n      return webMap.createToggleControl(options);\n    }\n  };\n\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPositions,\n    options?: MapControls[K]\n  ): Promise<any> {\n    let control: C | undefined;\n    if (typeof controlDef === 'string') {\n      control = this.getControl(controlDef, options);\n    } else {\n      control = controlDef as C;\n    }\n    if (control) {\n      const _control = await control;\n      return this.mapAdapter.addControl(_control, position);\n    }\n  }\n\n  /**\n   * Creating a universal map layout control element. Can be used with any map adapter.\n   *\n   * @example\n   * const control = webMap.createControl({\n   *   onAdd() {\n   *     return document.createElement('div');\n   *   }\n   * });\n   */\n  async createControl(\n    control: MapControl,\n    options?: CreateControlOptions\n  ): Promise<C | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createControl) {\n      return this.mapAdapter.createControl(control, options);\n    }\n  }\n\n  async createButtonControl(\n    options: ButtonControlOptions\n  ): Promise<C | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createButtonControl) {\n      return this.mapAdapter.createButtonControl(options);\n    }\n  }\n\n  async createToggleControl(\n    options: ToggleControlOptions\n  ): Promise<(C & ToggleControl) | undefined> {\n    await this.onLoad('build-map');\n    if (this.mapAdapter.createToggleControl) {\n      return this.mapAdapter.createToggleControl(options);\n    } else {\n      if (this.mapAdapter.createButtonControl) {\n        return WebMap.utils.createToggleControl<C>(\n          this.mapAdapter.createButtonControl,\n          options\n        );\n      }\n    }\n  }\n\n  removeControl(control: any) {\n    if (control.remove) {\n      control.remove();\n    } else if (this.mapAdapter.removeControl) {\n      this.mapAdapter.removeControl(control);\n    }\n  }\n\n  getControl<K extends keyof MapControls>(\n    control: K,\n    options?: MapControls[K]\n  ): C | undefined {\n    const engine = this.mapAdapter.controlAdapters[control];\n    if (engine) {\n      return new engine(options);\n    } else {\n      const createFun = WebMap.controls[control];\n      if (createFun) {\n        return createFun(this, options);\n      }\n    }\n  }\n\n  protected async _addLayerProviders(): Promise<void> {\n    try {\n      for await (const kit of this._starterKits) {\n        if (kit.getLayerAdapters) {\n          const adapters = await kit.getLayerAdapters.call(kit);\n          if (adapters) {\n            for await (const adapter of adapters) {\n              const newAdapter = await adapter.createAdapter(this);\n              if (newAdapter) {\n                this.mapAdapter.layerAdapters[adapter.name] = newAdapter;\n              }\n            }\n          }\n        }\n      }\n    } catch (er) {\n      throw new Error(er);\n    }\n  }\n\n  protected async _onLoadSync(): Promise<void> {\n    for await (const kit of this._starterKits) {\n      if (kit.onLoadSync) {\n        try {\n          await kit.onLoadSync.call(kit, this);\n        } catch (er) {\n          console.error(er);\n        }\n      }\n    }\n  }\n}\n","/**\n * @module webmap\n * @preferred\n */\n\nimport { WebMap } from './WebMap';\n\nexport * from './WebMap';\nexport * from './WebMapLayers';\nexport * from './interfaces/BaseTypes';\nexport * from './interfaces/WebMapApp';\nexport * from './interfaces/MapAdapter';\nexport * from './interfaces/DialogAdapter';\nexport * from './interfaces/MapControl';\nexport * from './interfaces/LayerAdapter';\nexport * from './interfaces/StarterKit';\nexport * from './interfaces/RuntimeParams';\nexport * from './interfaces/Events';\n\nexport { WebMap };\nexport default WebMap;\n","import Vue from 'vue';\nimport VueNgwMap from './components/VueNgwMap';\n\nexport const capitalizeFirstLetter = (str: string) => {\n  if (!str || typeof str.charAt !== 'function') {\n    return str;\n  }\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\ninterface VueElement extends Vue {\n  [prop: string]: any;\n}\n\nexport function propsBinder(\n  vueElement: VueElement,\n  props: Record<string, any>\n) {\n  for (const key in props) {\n    const setMethodName = 'set' + capitalizeFirstLetter(key);\n    if (key in props && vueElement[setMethodName]) {\n      const prop = props[key];\n      const deepValue =\n        (prop && prop.type === Object) ||\n        prop.type === Array ||\n        Array.isArray(prop.type);\n      vueElement.$watch(\n        key,\n        (newVal, oldVal) => {\n          vueElement[setMethodName](newVal, oldVal);\n        },\n        {\n          deep: deepValue\n        }\n      );\n    }\n  }\n}\n\nexport const findNgwMapParent = (\n  firstVueParent: Vue | VueNgwMap\n): VueNgwMap => {\n  let found = false;\n  while (firstVueParent && !found) {\n    if (!('ngwMap' in firstVueParent)) {\n      firstVueParent = firstVueParent.$parent;\n    } else {\n      found = true;\n    }\n  }\n  return firstVueParent as VueNgwMap;\n};\n"],"sourceRoot":""}