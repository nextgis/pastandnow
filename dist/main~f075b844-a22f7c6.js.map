{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/icons/src/index.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/utility.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/QmsKit.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/image_icons.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/BaseAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/util/geom_type.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/VectorAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/MvtAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/TileAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/OsmAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/ZoomControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/CompassControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/AttributionControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/layer-adapters/GeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/MapboxglMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/controls/createButtonControl.ts","webpack:///./nextgisweb_frontend/packages/mapboxgl-map-adapter/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/decorators.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/NgwMap.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/CancelablePromise.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/NgwConnector.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createGeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createRasterAdapter.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeUtil.ts","webpack:///./nextgisweb_frontend/packages/item/src/TreeHelper.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/BaseProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/Item.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/CheckProperty.ts","webpack:///./nextgisweb_frontend/packages/item/src/properties/ItemProperties.ts","webpack:///./nextgisweb_frontend/packages/item/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerItem.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwResource.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createAsyncAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createWebMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/identifyUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwKit.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/index.ts"],"names":["svgPath","brill","circle","rect","marker","cross","star","triangle","plus","minus","asterisk","getIcon","opt","shape","color","strokeColor","size","anchor","stroke","scale","pathAlias","svg","width","height","content","s","DOMParser","parseFromString","documentElement","insertSvg","fistChild","firstChild","transform","setAttribute","String","type","iconSize","iconAnchor","html","XMLSerializer","serializeToString","alias","tms","loadJSON","url","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","JSON","parse","er","open","send","createQmsAdapter","webMap","map","options","this","baseLayer","addLayer","qms","qmsId","webMapAdapter","mapAdapter","layerAdapters","maxZoom","minZoom","protocol","location","replace","name","attribution","copyright_text","z_max","z_min","updateQmsOptions","getLayerAdapters","createAdapter","webmap","_createAdapter","utils","canvg","getImageData","img","canvas","window","document","createElement","context","getContext","Error","HTMLImageElement","drawImage","Canvg","fromString","start","ID","_layerId","allowedByType","line","fill","icon","concat","typeAlias","Point","LineString","MultiPoint","Polygon","MultiLineString","MultiPolygon","GeometryCollection","typeAliasForFilter","backAliases","a","layerType","backAlias","push","findMostFrequentGeomType","arr","counts","fry","length","maxName","c","maxCount","geometryFilter","geometry","backType","indexOf","operationsAliases","gt","lt","ge","le","eq","ne","in","notin","like","ilike","reversOperations","PAINT","opacity","radius","selected","featureIdName","_types","_selectedFeatureIds","_sourceId","source","_selectionName","$onLayerClick","_onLayerClick","bind","layer","types","paint","_onAddLayer","t","geomType","_detectPaintType","_getLayerNameFromType","geomFilter","undefined","_addLayer","_getNativeFilter","selectedPaint","selectionLayer","_getSelectionLayerNameFromType","selectedLayout","_addEventsListeners","propertiesFilter","filters","_filterProperties","_updatePropertiesFilter","removeFilter","_updateFilter","select","properties","_selectProperties","unselect","removeLayer","forEach","layerId","_updateWithNativeFilter","filter","nativeFilter","layout","mType","layerOpt","id","visibility","_getAdditionalLayerOptions","minzoom","maxzoom","x","setFilter","sourceId","_updateLayerPaint","layerName","layers","selName","_paint","nativePaint","_createPaintForType","p","setLayoutProperty","setPaintProperty","mapboxPaint","_registerImage","allowed","allowedType","find","Array","isArray","paramName","duration","_getFeatureFilterId","feature","_featureFilterId","hasImage","svgStr","Image","crossOrigin","src","btoa","onload","imageData","image","addImage","_selectFeature","_unselectFeature","selLayerName","selectProperties","filterProperties","propertyFilters","_convertToMapboxFilter","reverse","_operationsAliases","field","operation","value","operationAlias","isFeatureSelected","filterId","e","preventDefault","reduce","b","features_","queryRenderedFeatures","point","isSelected","unselectOnSecondClick","onLayerClick","falsePaint","selectable","on","getCanvas","style","cursor","BaseAdapter","MvtAdapter","sources","includes","addSource","tiles","sourceLayer","subdomains","split","headers","transformRequests","resourceType","staticUrl","sourceOptions","tileSize","layerOptions","before","OPTIONS","Object","assign","TileAdapter","showCompass","_createButton","className","ariaLabel","fn","element","label","title","showZoom","_features","_sources","data","addData","getSource","removeSource","clearLayer","cb","features","setData","detectedType","geojson","f","geometries","g","detectType","filterGeometries","fid","_filterFun","_filter","getLayers","filtered","_filteredFeatureIds","_getFeatures","visible","fun","getSelected","_getPaintFromCallback","selectedFeatureIds","multiselect","index","splice","selectionArray","filteredArray","filter_","querySourceFeatures","ok","newFeatures","geomCollection","toSave","createControl","control","getDefaultPosition","onAdd","classList","add","bar","addClass","appendChild","_container","onRemove","parentNode","removeChild","remove","fitBoundsOptions","emitter","MapboxglMapAdapter","controlAdapters","isLoaded","_universalEvents","_sourceDataLoading","create","accessToken","target","mapOpt","container","attributionControl","bounds","fitOptions","transformRequest","transformed","_transformRequest","version","center","zoom","once","emit","destroy","getContainer","setView","jumpTo","setCenter","latLng","getCenter","lng","lat","setZoom","getZoom","fitBounds","linear","setRotation","angle","showLayer","layerIds","_toggleLayer","hideLayer","setLayerOrder","order","_sortTimerId","clearTimeout","setTimeout","_setLayerOrder","setLayerOpacity","_map","_onMapLoad","then","getLayer","createButtonControl","link","HTMLElement","innerHTML","child","firstElementChild","lineHeight","offsetHeight","onClick","stopPropagation","addEventListener","parent","removeEventListener","addControl","position","removeControl","onMapClick","evt","lngLat","y","pixel","top","left","_resolve","baseLayers","orderedLayers","l","sort","nextLayer","nextLayerId","mem","_getLayerIds","moveLayer","firstRealLayer","_layers","getDependLayers","_onMapSourceData","dataType","isSourceLoaded","_onDataLoad","_onMapError","keys","tile","params","r","TILE","MVT","OSM","OsmAdapter","GEOJSON","ZOOM","ZoomControl","COMPASS","CompassControl","ATTRIBUTION","AttributionControl","onMapLoad","decorators","onLoad","appendNgwResources","resource","defOptions","overwriteOptions","Number","resourceId","baseUrl","controls","controlsOptions","customAttribution","pixelRadius","kits","connector","auth","identification","starterKits","runtimeParams","prepareWebMapOptions","_ngwLayers","_createWebMap","_addControls","fit","controlDef","addNgwLayer","keyname","adapter","adapterOptions","getLayerId","getActiveBaseLayer","console","error","getNgwLayerItem","getNgwLayerItems","getNgwLayerFeature","getNgwLayerFeatures","getIdentifyGeoJson","identify","multiple","getNgwLayers","getNgwLayerByResourceId","n","getIdentificationIds","ids","some","dependLayers","dependFit","item","parentId","zoomToLayer","layerDef","ngwLayer","getExtent","extent","get","getNgwResourceExtent","event","enableSelection","__selectFromNgwRaster","ev","_selectFromNgwRaster","__selectFromNgwVector","_selectFromNgwVector","disableSelection","off","_isFitFromResource","_initMapState","qmsLayerName","qmsLayerOptions","addBaseLayer","resources","layerFitAllowed","webmapId","_emitStatusEvent","controlAdapterName","controlOptions","featureId","identifyFeature","fields","geom","featureCount","sourceType","nl","promises","all","getIds","metresPerPixel","Math","abs","cos","PI","pow","sendIdentifyRequest","resp","fixUrlStr","deepmerge","handleCallback","callback","executor","onCancel","_canceled","_promise","CancelablePromise","values","catch","onfulfilled","onrejected","cancel","errorCallback","_destroy","finally","onfinally","templateRe","template","str","key","routeStr","_loadingQueue","_loadingStatus","_keynames","route","setNextGisWeb","logout","connect","login","password","getUserInfo","makeQuery","credentials","_rejectLoadingQueue","user","getAuthorizationHeaders","client","makeClientId","Authorization","unescape","encodeURIComponent","getResourceByKeyname","getResourceChildren","request","apiItems","apiItem","shift","replaceParams","arg","paramArray","join","post","method","nocache","patch","put","delete","_getJson","_executeLoadingQueue","_setLoadingQueue","waiting","timestamp","Date","q","isError","queue","wait","responseType","xhr","processingResponce","forError","response","message","statusText","onerror","upload","onprogress","lengthComputable","percentComplete","loaded","total","onProgress","h","header","setRequestHeader","withCredentials","file","FormData","append","d","stringify","abort","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","limit","intersects","filters_","filterById","featureIds","idFilterWorkAround","resourceIdFromLayerOptions","resourceItem","createGeoJsonAdapter","_fullDataLoad","geoJsonAdapterCb","_lastFilterArgs","_dataPromise","geoJsonOptions","updateGeoJsonAdapterOptions","_opt","addLayerOptions","beforeRemove","updateLayer","createRasterAdapter","IMAGE","adapterClass","_options","getLayerAdapterOptions","layerAdapterOptions","tileAdapterOptions","addOptions","filterIn","filterFunc","relationFunc","_filtered","children","relChild","events","_children","setParent","_parent","addChild","getParent","getParents","tree","getRoot","toReturn","getChildren","getDescendants","EventEmitter","_blocked","_value","getProperty","call","isGroup","isBlocked","parents","parentProp","property","set","_prepareValue","update","_fireChangeEvent","getValue","_callOnSet","_removeEventsListener","onSet","prop","CheckProperty","bubble","unBlock","propagation","_turnOn","_turnOff","_propagation","getHierarchyValue","every","turnOff","hierarchy","blockChilds","turnOn","unblockChilds","block","_block","_unBlock","_blockChild","_unBlockChild","BaseProperty","propertiesList","_properties","_propertiesList","_setPropertyHandler","propOpt","handlers","ItemProperties","handler","list","initProperties","WebMapLayerItem","_rootDescendantsCount","item_type","_sumUp","root","_init","initItem","newLayer","_layer","i","layer_adapter","toUpperCase","layer_max_scale_denom","_mapScaleToZoomLevel","layer_min_scale_denom","minScale","maxScale","subOrder","drawOrderEnabled","draw_order_position","layer_enabled","transparency","layer_transparency","bringToFront","log","setScaleRatio","totalValue","_getWebMapLayerItem","_getWebMapIds","_webmapLayersIds","$$onMapClick","_onMapClick","getWebMapExtent","visibleLayers","getWebMapConfig","root_item","draw_order_enabled","_updateItemsParams","display_name","layer_style_id","updateWmsParams","webMapItem","promise","_sendIdentifyRequest","_extent","styles","createAdapterFromFirstStyle","childrenStyles","firstStyle","createAsyncAdapter","adapterType","createWebMapAdapter","cls","parentOptions","basemap_layer","prototype","resourceAdapter","derivedCtor","baseCtor","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","defineProperty","bbox","now","isImageAllowed","simplification","bottom","right","getNgwLayerExtent","maxLat","maxLon","minLat","minLon","res","_pixelsInMeter","d2r","r2d","points","rlat","rlng","extp","theta","ex","ey","sin","getCirclePoly","polygon","tan","pixelsInMeterWidth","div","cssText","body","px","offsetWidth","centerLat","LN2","getZoomFromScale","getMapWidthForLanInMeters","round","getIdentifyGeoJsonParams","paramsList","isNaN","sortingArr","layerFeatures","withGeom","onLoadSync","resourceIds","_getLayerAdapter"],"mappings":"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","file":"main~f075b844-a22f7c6.js","sourcesContent":["/**\n * @module icons\n */\n\n// tslint:disable:max-line-length\nimport { IconOptions as WebmapIcoOptions } from '@nextgis/webmap';\n\nconst svgPath: { [name: string]: string | GetPathCallback } = {\n  brill: '<path d=\"m6 0-5 6 5 6 5-6z\"/>',\n  circle: '<circle cx=\"6\" cy=\"6\" r=\"6\"/>',\n  rect: '<rect width=\"12\" height=\"12\"/>',\n  marker:\n    '<path d=\"m6 0c-1.85 0-4 1.19-4 4.22 0 2.05 3.08 6.59 4 7.78 0.821-1.19 4-5.62 4-7.78 0-3.03-2.15-4.22-4-4.22z\"/>',\n  cross:\n    '<path d=\"M 2.4,12 6,8.4 9.6,12 12,9.6 8.4,6 12,2.4 9.6,0 6,3.6 2.4,0 0,2.4 3.6,6 0,9.6 Z\"/>',\n  star:\n    '<path d=\"m6 0.25 1.71 4.18 4.29-1.04e-4 -3.43 3.14 0.857 4.18-3.43-3.14-3.43 3.14 0.857-4.18-3.43-3.14 4.29-0.209z\"/>',\n  triangle: '<path d=\"m12 11.7h-12l6-11.2z\"/>',\n  plus: '<path d=\"m7.5 12v-4.5h4.5v-3h-4.5v-4.5h-3v4.5h-4.5v3h4.5v4.5z\"/>',\n  minus: '<path d=\"m12 7.5v-3h-12v3z\"/>',\n  asterisk:\n    '<path d=\"m7.59 12v-3.27l2.83 1.64 1.58-2.74-2.85-1.64 2.83-1.64-1.56-2.74-2.83 1.64v-3.24h-3.17v3.24l-2.85-1.64-1.57 2.74 2.84 1.64-2.84 1.64 1.57 2.74 2.85-1.64v3.27z\"/>'\n};\n\nexport interface IconOptions {\n  shape?:\n    | 'circle'\n    | 'brill'\n    | 'rect'\n    | 'marker'\n    | 'star'\n    | 'asterisk'\n    | 'triangle'\n    | 'plus'\n    | 'minus';\n  color?: string;\n  size?: number;\n  stroke?: number;\n  strokeColor?: string;\n  rotate?: number;\n}\n\nconst STROKE = 0.8;\n\nfunction insertSvg(\n  width: number,\n  height: number,\n  stroke = 0,\n  content?: string\n) {\n  const s = stroke / 2;\n  const svg = `<svg\n    version=\"1.1\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${width}\"\n    height=\"${height}\"\n    viewBox=\"-${s} -${s} ${width + stroke} ${height + stroke}\"\n  >${content}</svg>`;\n  const oParser = new DOMParser();\n  const oDOM = oParser.parseFromString(svg, 'image/svg+xml');\n  return oDOM.documentElement;\n}\n\ntype GetPathCallback = (opt?: IconOptions) => string;\n\nexport function getIcon(opt: IconOptions = {}): WebmapIcoOptions {\n  // default values\n  const shape = opt.shape || 'circle';\n  const color = opt.color || 'blue';\n  const strokeColor = opt.strokeColor || 'white';\n  const size = opt.size || 12;\n\n  const anchor = size / 2;\n  const defSize = 12;\n  const stroke = typeof opt.stroke === 'number' ? opt.stroke : STROKE;\n  const scale = size / defSize;\n\n  const pathAlias = svgPath[shape] || 'circle';\n\n  const path = typeof pathAlias === 'string' ? pathAlias : pathAlias(opt);\n  const svg = insertSvg(size, size, stroke * scale, path);\n  const fistChild = svg.firstChild as SVGElement;\n\n  const transform = `scale(${scale})`;\n\n  fistChild.setAttribute('fill', color);\n  if (stroke) {\n    fistChild.setAttribute('stroke', strokeColor);\n    fistChild.setAttribute('stroke-width', String(stroke));\n  }\n  fistChild.setAttribute('transform', transform);\n  const s = new XMLSerializer();\n  return {\n    type: 'icon',\n    iconSize: [size, size],\n    iconAnchor: [anchor, anchor],\n    html: s.serializeToString(svg),\n    svg\n  };\n}\n","import {\n  WebMap,\n  BaseLayerAdapter,\n  LayerAdaptersOptions,\n  Type,\n  AdapterOptions\n} from '@nextgis/webmap';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  QmsAdapterOptions,\n  QmsBasemap,\n  QmsLayerType,\n  QmsAdapter as QA\n} from './interfaces';\n\nconst alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE'\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  const serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min\n  };\n}\n\nexport function loadJSON<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = 'https://qms.nextgis.com'\n): Type<BaseLayerAdapter> {\n  class QmsAdapter<M = any> implements BaseLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      this.options = options;\n      this.options.baseLayer = true;\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        this.qms = await loadJSON<QmsBasemap>(\n          url + '/api/v1/geoservices/' + options.qmsId\n        );\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const webMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (webMapAdapter) {\n          if (type === 'TILE') {\n            options = {\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms)\n            };\n            this.options = options;\n            const adapter = new webMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","/**\n * @module qms-kit\n */\n\nimport WebMap, { StarterKit, Type, BaseLayerAdapter } from '@nextgis/webmap';\nimport { QmsOptions } from './interfaces';\nimport { createQmsAdapter } from './utility';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com'\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap))\n      }\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<BaseLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n","/**\n * @module qms-kit\n */\n\nimport { QmsKit } from './QmsKit';\n\nexport * from './interfaces';\n\nexport { QmsKit };\nexport default QmsKit;\n","let canvg: any;\ntry {\n  canvg = require('canvg');\n} catch (er) {\n  // ignore\n}\ninterface GetImgOpt {\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  sdf?: string;\n  pixelRatio?: number;\n}\n\n// const defAddImgOpt = {\n//   width: 12,\n//   height: 12,\n//   x: 0,\n//   y: 0,\n//   sdf: undefined,\n//   pixelRatio: 2\n// };\n\n// // from /mapbox-gl/src/util/browser.js\nexport function getImageData(\n  img: string | HTMLImageElement,\n  opt: GetImgOpt\n): ImageData {\n  const canvas = window.document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  if (!context) {\n    throw new Error('failed to create canvas 2d context');\n  }\n  canvas.setAttribute('width', String(opt.width));\n  canvas.setAttribute('height', String(opt.height));\n  if (!canvg && img instanceof HTMLImageElement) {\n    context.drawImage(img, 0, 0, opt.width, opt.height);\n  } else if (typeof img === 'string') {\n    if (canvg.Canvg) {\n      // for canvg v.3.x.x\n      const v = canvg.Canvg.fromString(context, img);\n      v.start();\n    } else {\n      // for canvg v.2.x.x\n      canvg(canvas, img);\n    }\n  }\n  return context.getImageData(0, 0, opt.width, opt.height);\n}\n\nexport function getImage(svgStr: string, opt: GetImgOpt): Promise<ImageData> {\n  return new Promise(resolve => {\n    if (canvg) {\n      resolve(getImageData(svgStr, opt));\n    } else {\n      const svgImage = new Image();\n      svgImage.crossOrigin = 'Anonymous';\n      svgImage.src = 'data:image/svg+xml;base64,' + btoa(svgStr);\n\n      svgImage.onload = () => {\n        const imageData = getImageData(svgImage, opt);\n        resolve(imageData);\n      };\n    }\n  });\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map } from 'mapbox-gl';\nimport { BaseLayerAdapter, AdapterOptions } from '@nextgis/webmap';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nlet ID = 0;\n\nexport abstract class BaseAdapter<O extends AdapterOptions = AdapterOptions>\n  implements BaseLayerAdapter<Map, TLayer, O> {\n  layer?: TLayer;\n  protected readonly _layerId: string;\n\n  constructor(public map: Map, public options: O) {\n    this._layerId = `layer-${ID++}`;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  abstract addLayer(options: O): TLayer | Promise<TLayer> | undefined;\n}\n","import {\n  GeoJsonGeometryTypes,\n  GeoJsonObject,\n  FeatureCollection,\n  Feature,\n  GeometryCollection\n} from 'geojson';\nimport { VectorAdapterLayerType } from '@nextgis/webmap';\n\nexport const allowedParams: ([string, string] | string)[] = [\n  'color',\n  'opacity'\n];\nexport const allowedByType = {\n  circle: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity'],\n    ['strokeColor', 'stroke-color'],\n    ['strokeOpacity', 'stroke-opacity'],\n    ['weight', 'stroke-width'],\n    'radius'\n  ],\n  line: [\n    ['strokeColor', 'color'],\n    ['strokeOpacity', 'opacity'],\n    ['weight', 'width']\n  ],\n  fill: [\n    ['fillColor', 'color'],\n    ['fillOpacity', 'opacity']\n  ],\n  icon: allowedParams.concat([])\n};\n\nexport const typeAlias: {\n  [key in GeoJsonGeometryTypes]: VectorAdapterLayerType;\n} = {\n  Point: 'circle',\n  LineString: 'line',\n  MultiPoint: 'circle',\n  Polygon: 'fill',\n  MultiLineString: 'line',\n  MultiPolygon: 'fill',\n  GeometryCollection: 'fill'\n};\n\nexport const typeAliasForFilter: {\n  [key in VectorAdapterLayerType]: GeoJsonGeometryTypes;\n} = {\n  circle: 'Point',\n  line: 'LineString',\n  fill: 'Polygon',\n  icon: 'Point'\n};\n\nexport const backAliases: {\n  [key in VectorAdapterLayerType]?: GeoJsonGeometryTypes[];\n} = {\n  icon: ['Point']\n};\n\nfor (const a in typeAlias) {\n  const layerType = typeAlias[a as GeoJsonGeometryTypes];\n  const backAlias = backAliases[layerType] || [];\n  backAlias.push(a as GeoJsonGeometryTypes);\n  backAliases[layerType] = backAlias;\n}\n\nexport function findMostFrequentGeomType(\n  arr: GeoJsonGeometryTypes[]\n): GeoJsonGeometryTypes {\n  const counts: { [x: string]: number } = {};\n  for (let fry = 0; fry < arr.length; fry++) {\n    counts[arr[fry]] = 1 + (counts[arr[fry]] || 0);\n  }\n  let maxName = '';\n  for (const c in counts) {\n    const maxCount = maxName ? counts[maxName] : 0;\n    if (counts[c] > maxCount) {\n      maxName = c;\n    }\n  }\n  return maxName as GeoJsonGeometryTypes;\n}\n\nexport function detectType(geojson: GeoJsonObject): GeoJsonGeometryTypes {\n  let geometry: GeoJsonGeometryTypes;\n  if (geojson.type === 'FeatureCollection') {\n    const featuresTypes = (geojson as FeatureCollection).features.map(\n      f => f.geometry.type\n    );\n    geometry = findMostFrequentGeomType(featuresTypes);\n  } else if (geojson.type === 'GeometryCollection') {\n    const geometryTypes = (geojson as GeometryCollection).geometries.map(\n      g => g.type\n    );\n    geometry = findMostFrequentGeomType(geometryTypes);\n  } else if (geojson.type === 'Feature') {\n    geometry = (geojson as Feature).geometry.type;\n  } else {\n    geometry = geojson.type;\n  }\n  return geometry;\n}\n\n// Static functions\nexport function geometryFilter(\n  geometry: GeoJsonGeometryTypes,\n  type: VectorAdapterLayerType\n): boolean {\n  const backType = backAliases[type];\n  if (backType) {\n    return backType.indexOf(geometry) !== -1;\n  }\n  return false;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  IconOptions,\n  VectorLayerAdapter,\n  VectorAdapterOptions,\n  PropertiesFilter,\n  Operations,\n  DataLayerFilter,\n  PropertyFilter,\n  FilterOptions,\n  checkIfPropertyFilter\n} from '@nextgis/webmap';\nimport {\n  Feature as F,\n  GeometryObject,\n  Geometry,\n  GeoJsonProperties\n} from 'geojson';\nimport {\n  Map,\n  MapLayerMouseEvent,\n  AnySourceData,\n  AnyLayout,\n  Layer,\n  MapboxGeoJSONFeature\n  // BackgroundPaint, FillPaint, FillExtrusionPaint, LinePaint, SymbolPaint,\n  // RasterPaint, CirclePaint, HeatmapPaint, HillshadePaint,\n} from 'mapbox-gl';\n\n// type MapboxPaint = BackgroundPaint | FillPaint | FillExtrusionPaint | LinePaint | SymbolPaint |\n//   RasterPaint | CirclePaint | HeatmapPaint | HillshadePaint;\n\nimport { getImage } from '../util/image_icons';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { BaseAdapter } from './BaseAdapter';\nimport { typeAliasForFilter, allowedByType } from '../util/geom_type';\n\nexport const operationsAliases: { [key in Operations]: string } = {\n  gt: '>',\n  lt: '<',\n  ge: '>=',\n  le: '<=',\n  eq: '==',\n  ne: '!=',\n  in: 'in',\n  notin: '!in',\n  // NOT SUPPORTED\n  like: '==',\n  // NOT SUPPORTED\n  ilike: '=='\n};\n\nconst reversOperations: { [key in Operations]: string } = {\n  gt: operationsAliases.le,\n  lt: operationsAliases.ge,\n  ge: operationsAliases.lt,\n  le: operationsAliases.gt,\n  eq: operationsAliases.ne,\n  ne: operationsAliases.eq,\n  in: operationsAliases.notin,\n  notin: operationsAliases.in,\n  like: operationsAliases.ne,\n  ilike: operationsAliases.ne\n};\n\nexport interface Feature<\n  G extends GeometryObject | null = Geometry,\n  P = GeoJsonProperties\n> extends F<G, P> {\n  _featureFilterId?: string;\n}\n\nconst PAINT = {\n  color: 'blue',\n  opacity: 1,\n  radius: 10\n};\n\ntype MapboxLayerType = 'fill' | 'line' | 'symbol' | 'circle';\n\nexport abstract class VectorAdapter<\n  O extends VectorAdapterOptions = VectorAdapterOptions\n> extends BaseAdapter<O>\n  implements VectorLayerAdapter<Map, TLayer, O, Feature> {\n  selected = false;\n\n  protected featureIdName = 'id';\n  protected _types: VectorAdapterLayerType[] = ['fill', 'circle', 'line'];\n  protected readonly _sourceId: string;\n  protected readonly _selectionName: string;\n  protected _selectedFeatureIds: (number | string)[] | false = [];\n\n  protected _selectProperties?: PropertiesFilter;\n  protected _filterProperties?: PropertiesFilter;\n\n  private $onLayerClick?: (e: MapLayerMouseEvent) => void;\n\n  constructor(public map: Map, public options: O) {\n    super(map, options);\n    this._sourceId = this.options.source\n      ? (this.options.source as string)\n      : `source-${this._layerId}`;\n\n    if (this.options.featureIdName) {\n      this.featureIdName = this.options.featureIdName;\n    } else if (this.options.source) {\n      this.featureIdName = '$id';\n    } else {\n      this.featureIdName = '_fid';\n    }\n\n    this._selectionName = this._layerId + '-highlighted';\n    this.$onLayerClick = this._onLayerClick.bind(this);\n  }\n\n  async addLayer(options: O): Promise<TLayer> {\n    options = this.options = { ...this.options, ...(options || {}) };\n\n    this.layer = [];\n    const types = (this._types = options.type ? [options.type] : this._types);\n    if (options.paint) {\n      this._onAddLayer(this._sourceId);\n      // const types = this._types;\n      for (const t of types) {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          let type = t;\n          if (t === 'circle') {\n            const paintType = this._detectPaintType(options.paint);\n            if (paintType === 'icon') {\n              type = 'icon';\n            }\n          }\n          const layer = this._getLayerNameFromType(t);\n          const geomFilter =\n            types.length > 1 ? ['==', '$type', geomType] : undefined;\n\n          await this._addLayer(layer, type, [\n            geomFilter,\n            this._getNativeFilter()\n          ]);\n          this.layer.push(layer);\n          if (options.selectedPaint) {\n            const selectionLayer = this._getSelectionLayerNameFromType(t);\n            await this._addLayer(\n              selectionLayer,\n              type,\n              [geomFilter, ['in', this.featureIdName, '']],\n              this.options.selectedLayout\n            );\n            this.layer.push(selectionLayer);\n          }\n        }\n      }\n    }\n\n    this._addEventsListeners();\n\n    return this.layer;\n  }\n\n  propertiesFilter(filters: PropertiesFilter, options?: FilterOptions) {\n    this._filterProperties = filters;\n    this._updatePropertiesFilter();\n  }\n\n  removeFilter() {\n    this._filterProperties = undefined;\n    this._updateFilter();\n  }\n\n  select(properties?: DataLayerFilter<F, TLayer> | PropertiesFilter) {\n    if (typeof properties !== 'function') {\n      this._selectProperties = properties;\n      this._updateFilter();\n    }\n    this.selected = true;\n  }\n\n  unselect() {\n    this._selectProperties = undefined;\n    this._updateFilter();\n    this.selected = false;\n  }\n\n  removeLayer() {\n    const map = this.map;\n    if (this.layer) {\n      this.layer.forEach(layerId => {\n        map.removeLayer(layerId);\n      });\n    }\n  }\n\n  protected _updateWithNativeFilter(filter: any[]) {\n    const nativeFilter = this._getNativeFilter();\n    if (nativeFilter.length) {\n      filter.push(nativeFilter);\n    }\n    return filter;\n  }\n\n  protected _getNativeFilter() {\n    return (this.options.nativeFilter\n      ? this.options.nativeFilter\n      : []) as PropertyFilter;\n  }\n\n  protected async _addLayer(\n    name: string,\n    type: VectorAdapterLayerType,\n    filter?: any[],\n    layout?: AnyLayout\n  ) {\n    const { minZoom, maxZoom } = this.options;\n    let mType: MapboxLayerType;\n    if (type === 'icon') {\n      mType = 'symbol';\n    } else {\n      mType = type;\n    }\n    layout = (layout || this.options.layout || {}) as AnyLayout;\n    const layerOpt: Layer = {\n      id: name,\n      type: mType,\n      source: this._sourceId,\n      layout: {\n        visibility: 'none',\n        ...layout\n      },\n      ...this._getAdditionalLayerOptions()\n    };\n    if (minZoom) {\n      layerOpt.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOpt.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(layerOpt);\n\n    const filters = ['all', ...(filter || [])].filter(x => x);\n    if (filters.length > 1) {\n      this.map.setFilter(layerOpt.id, filters);\n    }\n  }\n\n  protected _onAddLayer(sourceId: string, options?: AnySourceData) {\n    // ignore\n  }\n\n  protected async _updateLayerPaint(type: VectorAdapterLayerType) {\n    const layerName = this._getLayerNameFromType(type);\n\n    if (this.options.paint) {\n      const layers: [string, VectorAdapterLayerPaint | GetPaintCallback][] = [\n        [layerName, this.options.paint]\n      ];\n      if (this.options.selectedPaint) {\n        const selName = this._getSelectionLayerNameFromType(type);\n        layers.push([selName, this.options.selectedPaint]);\n      }\n\n      for (const [name, paint] of layers) {\n        let _paint: any;\n        if (this.options.nativePaint) {\n          _paint =\n            typeof this.options.nativePaint === 'boolean'\n              ? paint\n              : this.options.nativePaint;\n        } else {\n          _paint = await this._createPaintForType(paint, type, name);\n        }\n\n        if ('icon-image' in _paint) {\n          // If true, the icon will be visible even if it collides with other previously drawn symbols.\n          _paint['icon-allow-overlap'] = true;\n          for (const p in _paint) {\n            this.map.setLayoutProperty(name, p, _paint[p]);\n          }\n        } else {\n          for (const p in _paint) {\n            this.map.setPaintProperty(name, p, _paint[p]);\n          }\n        }\n      }\n    }\n  }\n\n  protected _getLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._layerId;\n  }\n\n  protected _getSelectionLayerNameFromType(type: VectorAdapterLayerType) {\n    return type + '-' + this._selectionName;\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name?: string\n  ): Promise<any> {\n    if (typeof paint !== 'function') {\n      const mapboxPaint: any = {};\n      const _paint = { ...PAINT, ...(paint || {}) };\n      if (paint.type === 'icon' && paint.html) {\n        await this._registerImage(paint);\n        return {\n          'icon-image': paint.html\n        };\n      } else {\n        for (const p in _paint) {\n          const allowed = allowedByType[type];\n          if (allowed) {\n            const allowedType = allowed.find(x => {\n              if (typeof x === 'string') {\n                return x === p;\n              } else if (Array.isArray(x)) {\n                return x[0] === p;\n              }\n              return false;\n            });\n            if (allowedType) {\n              const paramName = Array.isArray(allowedType)\n                ? allowedType[1]\n                : allowedType;\n              // @ts-ignore\n              mapboxPaint[type + '-' + paramName] = _paint[p];\n            }\n          }\n        }\n        mapboxPaint[type + '-opacity-transition'] = { duration: 0 };\n        return mapboxPaint;\n      }\n    }\n  }\n\n  protected _getFeatureFilterId(feature: Feature): string | number | undefined {\n    // @ts-ignore\n    const id = feature._featureFilterId;\n    if (id !== undefined) {\n      return id;\n    } else if (\n      feature.properties &&\n      feature.properties[this.featureIdName] !== undefined\n    ) {\n      return feature.properties[this.featureIdName];\n    }\n    return feature.id;\n  }\n\n  protected async _registerImage(paint: IconOptions) {\n    if (paint.html) {\n      const imageExist = this.map.hasImage(paint.html);\n      if (!imageExist) {\n        let width = 12;\n        let height = 12;\n        if (paint.iconSize) {\n          width = paint.iconSize[0];\n          height = paint.iconSize[1];\n        }\n        const image = await getImage(paint.html, {\n          width,\n          height\n        });\n\n        this.map.addImage(paint.html, image);\n      }\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _unselectFeature(feature: Feature | Feature[]) {\n    // ignore\n  }\n\n  protected _getAdditionalLayerOptions() {\n    return {};\n  }\n\n  protected _updateFilter() {\n    this._updatePropertiesFilter();\n  }\n\n  protected _updatePropertiesFilter() {\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          const selectProperties = this._selectProperties;\n          const filterProperties = this._filterProperties;\n          const propertyFilters =\n            filterProperties && this._convertToMapboxFilter(filterProperties);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              let filters: any[] = [];\n              if (selectProperties || this._selectedFeatureIds) {\n                if (selectProperties) {\n                  filters = this._convertToMapboxFilter(selectProperties) || [];\n                } else if (this._selectedFeatureIds) {\n                  filters = [\n                    ['in', this.featureIdName, ...this._selectedFeatureIds]\n                  ];\n                }\n                if (propertyFilters) {\n                  propertyFilters.forEach(x => filters.push(x));\n                }\n                this.map.setFilter(selLayerName, [\n                  'all',\n                  geomFilter,\n                  ...filters\n                ]);\n              } else {\n                filters = ['in', '$id', ''];\n                this.map.setFilter(selLayerName, filters);\n              }\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filters_: any[] = ['all', geomFilter];\n            this._updateWithNativeFilter(filters_);\n            if (selectProperties) {\n              const selectFilters = this._convertToMapboxFilter(\n                selectProperties,\n                true\n              );\n              selectFilters.forEach(x => filters_.push(x));\n            } else if (this._selectedFeatureIds) {\n              filters_.push([\n                '!in',\n                this.featureIdName,\n                ...this._selectedFeatureIds\n              ]);\n            }\n            if (propertyFilters) {\n              propertyFilters.forEach(x => filters_.push(x));\n            }\n            this.map.setFilter(layerName, filters_);\n          }\n        }\n      });\n    }\n  }\n\n  protected _convertToMapboxFilter(filters: PropertiesFilter, reverse = false) {\n    const _operationsAliases = reverse ? reversOperations : operationsAliases;\n    const filter = filters.map(x => {\n      if (typeof x === 'string') {\n        return x;\n      } else if (checkIfPropertyFilter(x)) {\n        const [field, operation, value] = x;\n        const operationAlias = _operationsAliases[operation];\n        if (operation === 'in' || operation === 'notin') {\n          return [operationAlias, field, ...value];\n        }\n        return [operationAlias, field, value];\n      }\n    });\n    return filter;\n  }\n\n  protected isFeatureSelected(feature: Feature) {\n    if (this._selectedFeatureIds) {\n      const filterId = this._getFeatureFilterId(feature);\n      if (filterId) {\n        return this._selectedFeatureIds.indexOf(filterId) !== -1;\n      }\n    }\n    return false;\n  }\n\n  private _onLayerClick(e: MapLayerMouseEvent) {\n    e.preventDefault();\n    // const features = this.map.queryRenderedFeatures(e.point, {\n    //   layers: this.layer\n    // });\n    if (this.layer) {\n      const features = this.layer.reduce((a, b) => {\n        const features_ = this.map.queryRenderedFeatures(e.point, {\n          layers: [b]\n        });\n        const c = a.concat(features_);\n        return c;\n      }, [] as MapboxGeoJSONFeature[]);\n      const feature = features[0] as Feature;\n      if (feature) {\n        let isSelected = this.isFeatureSelected(feature);\n        if (isSelected) {\n          if (this.options && this.options.unselectOnSecondClick) {\n            this._unselectFeature(feature);\n          }\n        } else {\n          this._selectFeature(feature);\n        }\n        isSelected = this.isFeatureSelected(feature);\n        if (this.options.onLayerClick) {\n          this.options.onLayerClick({\n            layer: this,\n            feature,\n            selected: isSelected\n          });\n        }\n      }\n    }\n  }\n\n  private _detectPaintType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback\n  ): string | undefined {\n    if ('type' in paint) {\n      return paint.type;\n    } else if (typeof paint === 'function') {\n      try {\n        const falsePaint = paint({\n          type: 'Feature',\n          properties: {},\n          geometry: {} as Geometry\n        });\n        return this._detectPaintType(falsePaint);\n      } catch (er) {\n        //\n      }\n    }\n  }\n\n  private _addEventsListeners() {\n    if (this.layer && this.options && this.options.selectable) {\n      this.layer.forEach(x => {\n        if (this.$onLayerClick) {\n          const onLayerClick = this.$onLayerClick;\n          this.map.on('click', x, (e: MapLayerMouseEvent) => {\n            onLayerClick(e);\n          });\n        }\n\n        this.map.on('mousemove', x, () => {\n          this.map.getCanvas().style.cursor = 'pointer';\n        });\n        this.map.on('mouseleave', x, () => {\n          this.map.getCanvas().style.cursor = '';\n        });\n      });\n    }\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { MvtAdapterOptions } from '@nextgis/webmap';\nimport { VectorAdapter } from './VectorAdapter';\nimport { TLayer } from '../MapboxglMapAdapter';\n\nexport class MvtAdapter extends VectorAdapter<MvtAdapterOptions> {\n  static sources: string[] = [];\n\n  source?: string;\n\n  async addLayer(options: MvtAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    this._updateLayerPaint(this.options.type || 'fill');\n\n    return layer;\n  }\n\n  protected _getAdditionalLayerOptions() {\n    const exist = MvtAdapter.sources.includes(this.options.url);\n    if (!exist) {\n      this.map.addSource(this.options.url, {\n        type: 'vector',\n        tiles: [this.options.url]\n      });\n      this.source = this.options.url;\n      MvtAdapter.sources.push(this.options.url);\n    }\n    const mvtLayerOptions: Partial<mapboxgl.Layer> = {\n      source: this.options.url,\n      'source-layer': this.options.sourceLayer\n    };\n    return mvtLayerOptions;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { BaseAdapter } from './BaseAdapter';\nimport { RasterSource, ResourceType, Layer } from 'mapbox-gl';\n\nexport class TileAdapter extends BaseAdapter<TileAdapterOptions>\n  implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    options = { ...this.options, ...(options || {}) };\n    const { minZoom, maxZoom } = options;\n    let tiles: string[];\n    if (options && options.subdomains) {\n      tiles = options.subdomains.split('').map(x => {\n        const subUrl = options.url.replace('{s}', x);\n        return subUrl;\n      });\n    } else {\n      tiles = [options.url];\n    }\n    if (options.headers) {\n      // @ts-ignore\n      const transformRequests = this.map.transformRequests;\n      transformRequests.push((url: string, resourceType: ResourceType) => {\n        let staticUrl = url;\n        staticUrl = staticUrl.replace(/(z=\\d+)/, 'z={z}');\n        staticUrl = staticUrl.replace(/(x=\\d+)/, 'x={x}');\n        staticUrl = staticUrl.replace(/(y=\\d+)/, 'y={y}');\n        if (staticUrl === options.url) {\n          return {\n            url,\n            headers: options.headers\n          };\n        }\n      });\n    }\n\n    const sourceOptions: RasterSource = {\n      type: 'raster',\n      // point to our third-party tiles. Note that some examples\n      // show a \"url\" property. This only applies to tilesets with\n      // corresponding TileJSON (such as mapbox tiles).\n      tiles,\n      tileSize: 256 // opt && opt.tileSize ||\n    };\n    if (options.attribution) {\n      sourceOptions.attribution = options.attribution;\n    }\n    const layerOptions: Layer = {\n      id: this._layerId,\n      type: 'raster',\n      layout: {\n        visibility: 'none'\n      },\n      source: sourceOptions\n      // TODO: clean remove before options from all existing apps\n    };\n\n    if (minZoom) {\n      layerOptions.minzoom = minZoom - 1;\n    }\n    if (maxZoom) {\n      layerOptions.maxzoom = maxZoom - 1;\n    }\n\n    this.map.addLayer(\n      layerOptions,\n      // @ts-ignore\n      options.before\n    );\n    const layer = (this.layer = [this._layerId]);\n    return layer;\n  }\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { BaseLayerAdapter, TileAdapterOptions } from '@nextgis/webmap';\nimport { TileAdapter } from './TileAdapter';\n\nconst OPTIONS = {\n  url: 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n  attribution:\n    '&copy; <a href=\"http://osm.org/copyright\" target=\"_blank\">OpenStreetMap</a> contributors',\n  subdomains: 'abc'\n};\n\nexport class OsmAdapter extends TileAdapter implements BaseLayerAdapter {\n  addLayer(options: TileAdapterOptions): string[] {\n    return super.addLayer(Object.assign({}, OPTIONS, options));\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\nimport { ZoomControlOptions } from '@nextgis/webmap';\n\nexport class ZoomControl extends NavigationControl {\n  options: ZoomControlOptions & any;\n\n  constructor(options: ZoomControlOptions & any = {}) {\n    options = { ...options, showCompass: false };\n    super(options);\n  }\n\n  _createButton(className: string, ariaLabel: string, fn: () => any) {\n    // @ts-ignore\n    const element = super._createButton(className, ariaLabel, fn);\n    const aliases: any = {\n      'Zoom in': 'zoomInTitle',\n      'Zoom out': 'zoomOutTitle'\n    };\n    const alias = aliases[ariaLabel];\n    const label = alias && this.options[alias];\n    if (label) {\n      element.title = label;\n      element.setAttribute('aria-label', label);\n    }\n\n    return element;\n  }\n}\n","import { NavigationControl } from 'mapbox-gl';\n\nexport class CompassControl extends NavigationControl {\n  constructor(options = {}) {\n    options = Object.assign({}, options, { showZoom: false });\n    super(options);\n  }\n}\n","// import { MapControl } from '@nextgis/webmap';\nimport { AttributionControl as AC } from 'mapbox-gl';\n\nexport class AttributionControl extends AC {}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport { Map, GeoJSONSource, GeoJSONSourceRaw } from 'mapbox-gl';\nimport {\n  GeoJsonAdapterOptions,\n  VectorAdapterLayerType,\n  VectorAdapterLayerPaint,\n  GetPaintCallback,\n  DataLayerFilter,\n  LayerDefinition,\n  PropertiesFilter\n} from '@nextgis/webmap';\nimport {\n  GeoJsonObject,\n  FeatureCollection,\n  GeometryCollection,\n  GeometryObject\n} from 'geojson';\nimport { TLayer } from '../MapboxglMapAdapter';\nimport { VectorAdapter, Feature } from './VectorAdapter';\nimport {\n  detectType,\n  typeAlias,\n  typeAliasForFilter,\n  geometryFilter\n} from '../util/geom_type';\n\nlet ID = 0;\n\nexport class GeoJsonAdapter extends VectorAdapter<GeoJsonAdapterOptions> {\n  selected = false;\n  source?: string;\n  private _features: Feature[] = [];\n  private _filteredFeatureIds?: (string | number)[] | undefined;\n  private _filterFun?: DataLayerFilter<Feature>;\n  private _sources: Record<string, GeoJSONSource> = {};\n\n  constructor(public map: Map, public options: GeoJsonAdapterOptions) {\n    super(map, options);\n    this.source = this._sourceId;\n  }\n\n  async addLayer(options: GeoJsonAdapterOptions): Promise<TLayer> {\n    const layer = await super.addLayer(options);\n    if (this.options.data) {\n      this.addData(this.options.data);\n    }\n    return layer;\n  }\n\n  removeLayer() {\n    super.removeLayer();\n    const source = this.map.getSource(this._sourceId);\n    if (source) {\n      this.map.removeSource(this._sourceId);\n    }\n  }\n\n  clearLayer(cb?: (feature: Feature) => boolean) {\n    let features: Feature[] = [];\n    const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n    if (cb) {\n      features = this._features = this._features.filter(x => !cb(x));\n    }\n    source.setData({ type: 'FeatureCollection', features });\n  }\n\n  async addData(data: GeoJsonObject) {\n    let type: VectorAdapterLayerType | undefined;\n    if (this.options.type) {\n      type = this.options.type;\n    }\n    if (!type && data) {\n      const detectedType = detectType(data);\n      type = typeAlias[detectedType];\n    }\n    if (data && type) {\n      const features = this.filterGeometries(data, type);\n      features.forEach(x => {\n        // to avoid id = 0 is false\n        const fid = '_' + ID++;\n        x._featureFilterId = fid;\n        if (x.properties) {\n          x.properties[this.featureIdName] = fid;\n        }\n      });\n      if (this._filterFun) {\n        this._filter(this._filterFun);\n      }\n      await this._updateLayerPaint(type);\n      const source = this.map.getSource(this._sourceId) as GeoJSONSource;\n      source.setData({ type: 'FeatureCollection', features: this._features });\n    }\n  }\n\n  getLayers() {\n    const filtered = this._filteredFeatureIds;\n    return this._getFeatures().map(feature => {\n      let visible = false;\n      if (filtered) {\n        const id = this._getFeatureFilterId(feature);\n        if (id !== undefined) {\n          visible = filtered.indexOf(id) !== -1;\n        }\n      }\n      return {\n        feature,\n        visible\n      };\n    });\n  }\n\n  filter(fun: DataLayerFilter<Feature, TLayer>) {\n    this._filterFun = fun;\n    this._filter(fun);\n  }\n\n  removeFilter() {\n    this._filterFun = undefined;\n    this._filteredFeatureIds = undefined;\n    this._updateFilter();\n  }\n\n  getSelected() {\n    const features: LayerDefinition<Feature, TLayer>[] = [];\n    this._getFeatures().forEach(x => {\n      const id = this._getFeatureFilterId(x);\n      if (\n        id &&\n        this._selectedFeatureIds &&\n        this._selectedFeatureIds.indexOf(id) !== -1\n      ) {\n        features.push({ feature: x });\n      }\n    });\n    return features;\n  }\n\n  select(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter(x => find({ feature: x }));\n        this._selectFeature(features);\n      } else {\n        this.selected = true;\n        this._selectProperties = find;\n        super._updateFilter();\n      }\n    } else if (!this.selected) {\n      this._selectFeature(this._getFeatures());\n    }\n  }\n\n  unselect(find?: DataLayerFilter<Feature, TLayer> | PropertiesFilter) {\n    this._selectProperties = undefined;\n    if (find) {\n      if (typeof find === 'function') {\n        const features = this._getFeatures().filter(x => find({ feature: x }));\n        this._unselectFeature(features);\n        this.selected = Array.isArray(this._selectedFeatureIds) ? true : false;\n      }\n    } else if (this.selected) {\n      this.selected = false;\n      this._unselectFeature();\n    }\n  }\n\n  protected _onAddLayer(sourceId: string) {\n    let source = this.map.getSource(sourceId) as GeoJSONSource;\n    if (!source) {\n      const sourceOpt: GeoJSONSourceRaw = {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features: []\n        }\n      };\n      const _opts: (keyof GeoJsonAdapterOptions)[] = [\n        'cluster',\n        'clusterMaxZoom',\n        'clusterRadius'\n      ];\n      _opts.forEach(x => {\n        const opt = this.options[x] as GeoJsonAdapterOptions;\n        if (opt !== undefined) {\n          //@ts-ignore\n          sourceOpt[x] = opt;\n        }\n      });\n      this.map.addSource(sourceId, sourceOpt);\n      source = this.map.getSource(sourceId) as GeoJSONSource;\n    }\n    this._sources[sourceId] = source;\n    if (this.options.type) {\n      this._updateLayerPaint(this.options.type);\n    }\n  }\n\n  protected async _createPaintForType(\n    paint: VectorAdapterLayerPaint | GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ): Promise<any> {\n    if (typeof paint === 'function') {\n      return await this._getPaintFromCallback(paint, type, name);\n    } else {\n      return super._createPaintForType(paint, type, name);\n    }\n  }\n\n  protected _selectFeature(feature: Feature | Feature[]) {\n    let selectedFeatureIds = this._selectedFeatureIds || [];\n    if (this.options && !this.options.multiselect) {\n      selectedFeatureIds = [];\n    }\n    let features: Feature[] = [];\n    if (Array.isArray(feature)) {\n      features = feature;\n    } else {\n      features = [feature];\n    }\n    features.forEach(f => {\n      const id = this._getFeatureFilterId(f);\n      if (id !== undefined) {\n        selectedFeatureIds.push(id);\n      }\n    });\n    this._selectedFeatureIds = selectedFeatureIds;\n    this._updateFilter();\n  }\n\n  protected _unselectFeature(feature?: Feature | Feature[]) {\n    if (feature) {\n      let features: Feature[] = [];\n      if (Array.isArray(feature)) {\n        features = feature;\n      } else {\n        features = [feature];\n      }\n      if (features.length) {\n        features.forEach(f => {\n          const id = this._getFeatureFilterId(f);\n          const selected = this._selectedFeatureIds;\n          if (selected && id !== undefined) {\n            const index = selected.indexOf(id);\n            if (index !== -1) {\n              selected.splice(index, 1);\n            }\n          }\n        });\n      }\n    } else {\n      this._selectedFeatureIds = false;\n    }\n    this._updateFilter();\n  }\n\n  protected _updateFilter() {\n    // it is not yet possible to use callbacks and properties filters together\n    if (this._filterProperties || this._selectProperties) {\n      return super._updateFilter();\n    }\n    const selected = this._selectedFeatureIds;\n    let selectionArray: (string | number)[] = [];\n    const filteredArray: (string | number)[] = [];\n    const filtered = this._filteredFeatureIds;\n    if (filtered) {\n      this._getFeatures().forEach(x => {\n        const id = this._getFeatureFilterId(x);\n        if (id !== undefined && filtered.indexOf(id) !== -1) {\n          if (selected && selected.indexOf(id) !== -1) {\n            selectionArray.push(id);\n          } else {\n            filteredArray.push(id);\n          }\n        }\n      });\n    } else if (selected) {\n      selectionArray = selected;\n    }\n    this.selected = !!selected;\n    const layers = this.layer;\n    if (layers) {\n      this._types.forEach(t => {\n        const geomType = typeAliasForFilter[t];\n        if (geomType) {\n          const geomFilter = ['==', '$type', geomType];\n          const layerName = this._getLayerNameFromType(t);\n          const selLayerName = this._getSelectionLayerNameFromType(t);\n          if (layers.indexOf(selLayerName) !== -1) {\n            if (this._selectionName) {\n              this.map.setFilter(selLayerName, [\n                'all',\n                geomFilter,\n                ['in', this.featureIdName, ...selectionArray]\n              ]);\n            }\n          }\n          if (layers.indexOf(layerName) !== -1) {\n            const filter_: any[] = ['all', geomFilter];\n            if (filtered) {\n              filter_.push(['in', this.featureIdName, ...filteredArray]);\n            } else {\n              filter_.push(['!in', this.featureIdName, ...selectionArray]);\n              this._updateWithNativeFilter(filter_);\n            }\n            this.map.setFilter(layerName, filter_);\n          }\n        }\n      });\n    }\n  }\n\n  private _getFeatures(): Feature[] {\n    if (this.source) {\n      const features = this.map.querySourceFeatures(this.source);\n      return features;\n    }\n    return this._features;\n  }\n\n  private _filter(fun: DataLayerFilter<Feature, TLayer>) {\n    const filtered: (string | number)[] = [];\n    this._getFeatures().forEach(feature => {\n      const ok = fun({ feature });\n      const id = this._getFeatureFilterId(feature);\n      if (ok && id) {\n        filtered.push(id);\n      }\n    });\n    this._filteredFeatureIds = filtered;\n    this._updateFilter();\n  }\n\n  private filterGeometries(\n    data: GeoJsonObject,\n    type: VectorAdapterLayerType\n  ): Feature[] {\n    let newFeatures: Feature[] = [];\n    if (data.type === 'FeatureCollection') {\n      const features = (data as FeatureCollection).features.filter(f =>\n        geometryFilter(f.geometry.type, type)\n      ) as Feature[];\n      (data as FeatureCollection).features = features;\n      newFeatures = features;\n    } else if (data.type === 'Feature') {\n      const allow = geometryFilter((data as Feature).geometry.type, type);\n      if (!allow) {\n        return [];\n      }\n      newFeatures.push(data as Feature);\n    } else if (data.type === 'GeometryCollection') {\n      const geomCollection = data as GeometryCollection;\n      geomCollection.geometries = geomCollection.geometries.filter(g =>\n        geometryFilter(g.type, type)\n      );\n      newFeatures = geomCollection.geometries.map(x => {\n        const f: Feature = {\n          type: 'Feature',\n          geometry: x as GeometryObject,\n          properties: {}\n        };\n        return f;\n      });\n    } else if (typeAlias[data.type]) {\n      const obj: Feature = {\n        type: 'Feature',\n        geometry: data as GeometryObject,\n        properties: {}\n      };\n      newFeatures = [obj];\n    }\n    this._features = this._features.concat(newFeatures);\n    return newFeatures;\n  }\n\n  private async _getPaintFromCallback(\n    paint: GetPaintCallback,\n    type: VectorAdapterLayerType,\n    name: string\n  ) {\n    const style: any = {};\n    for (const feature of this._features) {\n      const _paint = paint(feature);\n      if (_paint.type === 'icon') {\n        await this._registerImage(_paint);\n        if (feature.properties) {\n          feature.properties['_icon-image-' + name] = _paint.html;\n        }\n        style['icon-image'] = `{_icon-image-${name}}`;\n      } else {\n        for (const p in _paint) {\n          // @ts-ignore\n          const toSave = _paint[p];\n          if (feature.properties) {\n            feature.properties[`_paint_${p}_${name}`] = toSave;\n          }\n          style[p] = ['get', `_paint_${p}_${name}`];\n        }\n      }\n    }\n    if ('icon-image' in style) {\n      return style;\n    }\n    const styleFromCb = this._createPaintForType(style, type, name);\n    return styleFromCb;\n  }\n}\n","import { MapControl, CreateControlOptions } from '@nextgis/webmap';\nimport { IControl } from 'mapbox-gl';\n\nexport function createControl(\n  control: MapControl,\n  options: CreateControlOptions = {}\n): IControl {\n  class Control implements IControl {\n    private _container?: HTMLElement;\n\n    getDefaultPosition() {\n      return 'top-left';\n    }\n\n    onAdd() {\n      const element = document.createElement('div');\n      const content: HTMLElement = control.onAdd();\n      element.classList.add('mapboxgl-ctrl');\n      if (options.bar) {\n        // add custom css for boarder style\n        element.classList.add('mapboxgl-bar');\n      }\n      if (options.addClass) {\n        element.classList.add(options.addClass);\n      }\n      element.appendChild(content);\n      this._container = element;\n      return this._container;\n    }\n\n    onRemove() {\n      if (this._container) {\n        const parent = this._container.parentNode;\n        if (parent) {\n          parent.removeChild(this._container);\n        }\n      }\n      return control.onRemove();\n    }\n\n    remove() {\n      this.onRemove();\n    }\n  }\n\n  return new Control();\n  // return control;\n}\n","/**\n * @module mapboxgl-map-adapter\n */\nimport {\n  MapAdapter,\n  FitOptions,\n  MapControl,\n  ControlPositions,\n  ButtonControlOptions,\n  LngLatArray,\n  MapOptions,\n  LayerAdapter,\n  LngLatBoundsArray,\n  WebMapEvents,\n  CreateControlOptions\n} from '@nextgis/webmap';\nimport { MvtAdapter } from './layer-adapters/MvtAdapter';\nimport mapboxgl, {\n  Map,\n  IControl,\n  MapEventType,\n  EventData,\n  MapboxOptions,\n  RequestParameters,\n  ResourceType\n} from 'mapbox-gl';\nimport { OsmAdapter } from './layer-adapters/OsmAdapter';\nimport { TileAdapter } from './layer-adapters/TileAdapter';\nimport { EventEmitter } from 'events';\nimport { ZoomControl } from './controls/ZoomControl';\nimport { CompassControl } from './controls/CompassControl';\nimport { AttributionControl } from './controls/AttributionControl';\nimport { GeoJsonAdapter } from './layer-adapters/GeoJsonAdapter';\nimport { createControl } from './controls/createControl';\nimport { createButtonControl } from './controls/createButtonControl';\n\nexport type TLayer = string[];\ntype TLayerAdapter = LayerAdapter<Map, TLayer>;\n\nconst fitBoundsOptions: FitOptions = {\n  // padding: 100\n};\n\nexport interface MapboxglMapAdapterOptions extends MapOptions {\n  style?: Partial<mapboxgl.Style> | string;\n  accessToken?: string;\n}\n\nexport class MapboxglMapAdapter implements MapAdapter<Map, TLayer, IControl> {\n  static layerAdapters = {\n    TILE: TileAdapter,\n    // IMAGE: ImageAdapter,\n    MVT: MvtAdapter,\n    OSM: OsmAdapter,\n    GEOJSON: GeoJsonAdapter\n  };\n\n  static controlAdapters: { [name: string]: any } = {\n    ZOOM: ZoomControl,\n    COMPASS: CompassControl,\n    ATTRIBUTION: AttributionControl\n  };\n\n  options: MapboxglMapAdapterOptions = {};\n  map!: Map;\n\n  emitter = new EventEmitter();\n\n  layerAdapters = MapboxglMapAdapter.layerAdapters;\n  controlAdapters = MapboxglMapAdapter.controlAdapters;\n  isLoaded = false;\n\n  private _universalEvents: (keyof WebMapEvents)[] = [\n    'zoomstart',\n    'zoom',\n    'zoomend',\n    'movestart',\n    'move',\n    'moveend'\n  ];\n\n  private _sourceDataLoading: { [name: string]: any[] } = {};\n  private _sortTimerId?: number;\n\n  // create(options: MapOptions = {target: 'map'}) {\n  create(options: MapboxglMapAdapterOptions) {\n    return new Promise((resolve, reject) => {\n      if (!this.map) {\n        this.options = options;\n        if (options.accessToken) {\n          mapboxgl.accessToken = options.accessToken;\n        }\n        if (options.target) {\n          const mapOpt: MapboxOptions = {\n            container: options.target,\n            attributionControl: false,\n            // @ts-ignore\n            bounds: options.bounds,\n            fitBoundsOptions: { ...options.fitOptions, ...fitBoundsOptions },\n            transformRequest: (url: string, resourceType: ResourceType) => {\n              const transformed = this._transformRequest(url, resourceType);\n              if (transformed) {\n                return transformed;\n              } else {\n                return {\n                  url\n                };\n              }\n            }\n          };\n          if (typeof options.style === 'string') {\n            mapOpt.style = options.style;\n          } else {\n            mapOpt.style = {\n              ...{\n                version: 8,\n                name: 'Empty style',\n                sources: {},\n                layers: []\n              },\n              ...options.style\n            };\n          }\n          if (options.center !== undefined) {\n            mapOpt.center = options.center;\n          }\n          if (options.zoom !== undefined) {\n            mapOpt.zoom = options.zoom - 1;\n          }\n          if (options.maxZoom) {\n            mapOpt.maxZoom = options.maxZoom - 1;\n          }\n          if (options.minZoom) {\n            mapOpt.minZoom = options.minZoom - 1;\n          }\n          this.map = new Map(mapOpt);\n\n          this.map.once('load', () => {\n            // @ts-ignore\n            this.map.transformRequests = [];\n            this.isLoaded = true;\n            this.emitter.emit('create', this);\n            resolve(this);\n          });\n          this._addEventsListeners();\n        }\n      }\n    });\n  }\n\n  destroy() {\n    if (this.map) {\n      this.map.remove();\n    }\n  }\n\n  getContainer() {\n    return this.map && this.map.getContainer();\n  }\n\n  setView(center: LngLatArray, zoom?: number) {\n    if (this.map) {\n      const options: mapboxgl.CameraOptions = { center };\n      if (zoom) {\n        options.zoom = zoom - 1;\n      }\n      this.map.jumpTo(options);\n    }\n  }\n\n  setCenter(latLng: LngLatArray): void {\n    if (this.map) {\n      this.map.setCenter(latLng);\n    }\n  }\n\n  getCenter(): LngLatArray | undefined {\n    if (this.map) {\n      const center = this.map.getCenter();\n      return [center.lng, center.lat];\n    }\n  }\n\n  setZoom(zoom: number): void {\n    if (this.map) {\n      this.map.setZoom(zoom - 1);\n    }\n  }\n\n  getZoom(): number | undefined {\n    if (this.map) {\n      const zoom = this.map.getZoom();\n      return zoom ? zoom + 1 : undefined;\n    }\n  }\n\n  // [extent_left, extent_bottom, extent_right, extent_top];\n  fitBounds(e: LngLatBoundsArray, options: FitOptions = {}): void {\n    if (this.map) {\n      this.map.fitBounds(\n        [\n          [e[0], e[1]],\n          [e[2], e[3]]\n        ],\n        {\n          linear: true,\n          ...options,\n          ...fitBoundsOptions\n        }\n      );\n    }\n  }\n\n  setRotation(angle: number): void {\n    // ignore\n  }\n\n  showLayer(layerIds: string[]): void {\n    layerIds.forEach(layerId => {\n      this._toggleLayer(layerId, true);\n    });\n  }\n\n  hideLayer(layerIds: string[]): void {\n    layerIds.forEach(layerId => {\n      this._toggleLayer(layerId, false);\n    });\n  }\n\n  removeLayer(layerIds: string[]): void {\n    if (this.map) {\n      const _map = this.map;\n      layerIds.forEach(layerId => {\n        _map.removeLayer(layerId);\n        const source = _map.getSource(layerId);\n        if (source) {\n          _map.removeSource(layerId);\n        }\n      });\n    }\n  }\n\n  setLayerOrder(\n    layerIds: string[],\n    order: number,\n    layers: { [x: string]: TLayerAdapter }\n  ): void {\n    if (this._sortTimerId) {\n      window.clearTimeout(this._sortTimerId);\n    }\n    this._sortTimerId = window.setTimeout(() => this._setLayerOrder(layers));\n  }\n\n  setLayerOpacity(layerIds: string[], opacity: number): void {\n    const _map = this.map;\n    if (_map) {\n      layerIds.forEach(layerId => {\n        this._onMapLoad().then(() => {\n          const layer = _map.getLayer(layerId);\n          if (layer) {\n            if (layer.type === 'symbol') {\n              _map.setPaintProperty(layerId, 'text-opacity', opacity);\n              _map.setPaintProperty(layerId, 'icon-opacity', opacity);\n            } else {\n              _map.setPaintProperty(layerId, layer.type + '-opacity', opacity);\n            }\n          }\n        });\n      });\n    }\n  }\n\n  createControl(control: MapControl, options?: CreateControlOptions): IControl {\n    return createControl(control, options);\n  }\n\n  createButtonControl(options: ButtonControlOptions): IControl {\n    return createButtonControl(options);\n  }\n\n  addControl(\n    control: IControl,\n    position: ControlPositions\n  ): IControl | undefined {\n    if (this.map) {\n      this.map.addControl(control, position);\n      return control;\n    }\n  }\n\n  removeControl(control: IControl): void {\n    if (this.map) {\n      this.map.removeControl(control);\n    }\n  }\n\n  onMapClick(evt: MapEventType['click'] & EventData): void {\n    const latLng = evt.lngLat;\n    const { x, y } = evt.point;\n\n    this.emitter.emit('click', { latLng, pixel: { top: y, left: x } });\n  }\n\n  private _onMapLoad(cb?: () => any): Promise<Map> {\n    return new Promise<Map>(resolve => {\n      const _resolve = () => {\n        if (cb) {\n          cb();\n        }\n        if (this.map) {\n          resolve(this.map);\n        }\n      };\n      if (this.isLoaded) {\n        // map.loaded()\n        _resolve();\n      } else if (this.map) {\n        this.emitter.once('create', () => {\n          _resolve();\n        });\n      }\n    });\n  }\n\n  private _setLayerOrder(layers: { [x: string]: TLayerAdapter }): void {\n    const _map = this.map;\n    if (_map) {\n      const baseLayers: TLayerAdapter[] = [];\n      let orderedLayers: TLayerAdapter[] = [];\n      for (const l in layers) {\n        const layer = layers[l];\n        if (layer.options.baseLayer) {\n          baseLayers.push(layer);\n        } else {\n          orderedLayers.push(layer);\n        }\n      }\n\n      orderedLayers = orderedLayers.sort((a, b) => {\n        return a.options.order !== undefined && b.options.order !== undefined\n          ? a.options.order - b.options.order\n          : 0;\n      });\n\n      for (let fry = 0; fry < orderedLayers.length; fry++) {\n        const nextLayer = orderedLayers[fry + 1];\n        const nextLayerId = nextLayer && nextLayer.layer && nextLayer.layer[0];\n        const mem = orderedLayers[fry];\n        const _layers = this._getLayerIds(mem);\n        _layers.forEach(x => {\n          _map.moveLayer(x, nextLayerId);\n        });\n      }\n      const firstRealLayer = orderedLayers.find(x => Array.isArray(x.layer));\n      if (firstRealLayer) {\n        const firstLayerId = this._getLayerIds(firstRealLayer)[0];\n        // normalize layer ordering\n        baseLayers.forEach(x => {\n          if (x.layer) {\n            x.layer.forEach(y => {\n              _map.moveLayer(y, firstLayerId);\n            });\n          }\n        });\n      }\n    }\n  }\n\n  private _getLayerIds(mem: TLayerAdapter): string[] {\n    let _layers: TLayer = [];\n    if (mem) {\n      if (Array.isArray(mem.layer)) {\n        _layers = mem.layer;\n      } else if (mem.getDependLayers) {\n        const dependLayers = mem.getDependLayers();\n        dependLayers.forEach(x => {\n          // @ts-ignore Update x interface\n          const layer: TLayer = (x.layer && x.layer.layer) || x;\n          if (Array.isArray(layer)) {\n            layer.forEach(y => {\n              _layers.push(y);\n            });\n          }\n        });\n      }\n    }\n    return _layers;\n  }\n\n  private _toggleLayer(layerId: string, status: boolean): void {\n    this._onMapLoad().then(_map => {\n      _map.setLayoutProperty(\n        layerId,\n        'visibility',\n        status ? 'visible' : 'none'\n      );\n    });\n  }\n\n  private _onMapSourceData(data: mapboxgl.MapSourceDataEvent & EventData) {\n    if (data.dataType === 'source') {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-loaded', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onMapError(\n    data: mapboxgl.ErrorEvent & mapboxgl.MapSourceDataEvent & EventData\n  ) {\n    if (this._sourceDataLoading[data.sourceId]) {\n      const isLoaded = data.isSourceLoaded;\n      const emit = (target: string) => {\n        this.emitter.emit('data-error', { target });\n      };\n      this._onDataLoad(data, isLoaded, emit);\n    }\n  }\n\n  private _onDataLoad(\n    data: { sourceId: string; tile: any },\n    isLoaded = false,\n    emit: (sourceId: string) => void\n  ) {\n    // if all sources is loaded emmit event for all and clean mem\n    if (isLoaded) {\n      Object.keys(this._sourceDataLoading).forEach(x => {\n        emit(x);\n      });\n      this._sourceDataLoading = {};\n    } else {\n      // check if all tiles in layer is loaded\n      const tiles = this._sourceDataLoading[data.sourceId];\n      if (tiles && data.tile) {\n        const index = tiles.indexOf(data.tile);\n        if (index !== -1) {\n          this._sourceDataLoading[data.sourceId].splice(index, 1);\n        }\n        // if no more loaded tiles in layer emit event and clean mem only for this layer\n        if (!tiles.length) {\n          emit(data.sourceId);\n          delete this._sourceDataLoading[data.sourceId];\n        }\n      }\n    }\n  }\n\n  private _transformRequest(\n    url: string,\n    resourceType: ResourceType\n  ): RequestParameters | undefined {\n    // @ts-ignore\n    const transformRequests = this.map && this.map.transformRequests;\n    if (transformRequests) {\n      for (const r of transformRequests) {\n        const params = r(url, resourceType) as RequestParameters;\n        if (params) {\n          return params;\n        }\n      }\n      return undefined;\n    }\n  }\n\n  private _addEventsListeners(): void {\n    const _map = this.map;\n    if (_map) {\n      // write mem for start loaded layers\n      _map.on('sourcedataloading', data => {\n        this._sourceDataLoading[data.sourceId] =\n          this._sourceDataLoading[data.sourceId] || [];\n        if (data.tile) {\n          this._sourceDataLoading[data.sourceId].push(data.tile);\n        }\n      });\n      // emmit data-loaded for each layer or all sources is loaded\n      _map.on('sourcedata', this._onMapSourceData.bind(this));\n      _map.on('error', this._onMapError.bind(this));\n      _map.on('click', evt => {\n        this.onMapClick(evt);\n      });\n\n      this._universalEvents.forEach(e => {\n        _map.on(e, () => this.emitter.emit(e, this));\n      });\n    }\n  }\n}\n","import { ButtonControlOptions } from '@nextgis/webmap';\nimport { createControl } from './createControl';\n\nexport function createButtonControl(options: ButtonControlOptions) {\n  const link = document.createElement('button');\n  link.className = 'mapboxgl-ctrl-icon';\n\n  link.setAttribute('role', 'button');\n  if (options.title) {\n    link.title = options.title;\n    link.setAttribute('aria-label', options.title);\n  }\n\n  if (options.html) {\n    if (options.html instanceof HTMLElement) {\n      link.appendChild(options.html);\n    } else {\n      link.innerHTML = options.html;\n    }\n    const child = link.firstElementChild as HTMLElement;\n    if (child) {\n      child.style.width = '100%';\n      child.style.height = '100%';\n      child.style.lineHeight = (link.offsetHeight || 30) + 'px';\n    }\n  }\n  if (options.addClass) {\n    options.addClass.split(' ').forEach(x => link.classList.add(x));\n  }\n\n  const onClick = (e: Event) => {\n    e.stopPropagation();\n    options.onClick();\n  };\n  if (options.onClick !== undefined) {\n    link.addEventListener('click', onClick);\n  }\n\n  return createControl(\n    {\n      onAdd() {\n        return link;\n      },\n      onRemove() {\n        const parent = link.parentNode;\n        if (parent) {\n          parent.removeChild(link);\n        }\n        if (options.onClick !== undefined) {\n          link.removeEventListener('click', onClick);\n        }\n      }\n    },\n    { bar: true, addClass: 'mapboxgl-ctrl-group' }\n  );\n}\n","/**\n * @module mapboxgl-map-adapter\n */\n\nimport { MapboxglMapAdapter } from './MapboxglMapAdapter';\nexport * from './MapboxglMapAdapter';\nexport default MapboxglMapAdapter;\n","import WebMap from '@nextgis/webmap';\nimport { NgwMapEvents } from './interfaces';\n\n/**\n * Decorator to run action only after map is created\n */\nexport function onMapLoad() {\n  return WebMap.decorators.onLoad<NgwMapEvents>('build-map');\n}\n","import { NgwResourceDefinition, NgwLayerOptions } from './interfaces';\nimport { NgwLayerOptionsAdditional } from '@nextgis/ngw-kit';\n\nimport { deepmerge } from '@nextgis/utils';\nimport { MapAdapter, StarterKit } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport QmsKit from '@nextgis/qms-kit';\nimport NgwKit from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from './interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: NgwLayerOptionsAdditional,\n  overwriteOptions?: NgwLayerOptionsAdditional\n) {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resourceId: resource\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({ ...defOptions, resourceId, id, ...overwriteOptions });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"http://nextgis.ru\" target=\"_blank\">NextGIS</a>'\n      ]\n    }\n  },\n  pixelRadius: 10\n};\n\nexport function prepareWebMapOptions(\n  mapAdapter: MapAdapter,\n  options: NgwMapOptions\n) {\n  const kits: StarterKit[] = [new QmsKit()];\n\n  if (!options.connector && options.baseUrl) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl,\n      auth: options.auth\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  const opt: NgwMapOptions = deepmerge(OPTIONS, options);\n  if (opt.connector) {\n    kits.push(\n      new NgwKit({\n        connector: opt.connector,\n        auth: opt.auth,\n        identification: opt.identification\n      })\n    );\n  }\n  return {\n    mapAdapter,\n    starterKits: kits,\n    runtimeParams: options.runtimeParams\n  };\n}\n","/**\n * @module ngw-map\n */\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport { fixUrlStr, deepmerge } from '@nextgis/utils';\nimport WebMap, {\n  MapAdapter,\n  ControlPositions,\n  MapControls,\n  WebMapEvents,\n  LayerDef,\n  MapClickEvent,\n  LayerAdapter,\n  PropertiesFilter,\n  FilterOptions,\n  OnLayerClickOptions\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  ResourceItem,\n  CancelablePromise,\n  FeatureLayersIdentify,\n  FeatureItem,\n  FeatureLayersIdentifyItems,\n  LayerFeature\n} from '@nextgis/ngw-connector';\nimport { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport NgwKit, {\n  NgwLayerOptions,\n  ResourceAdapter,\n  WebMapLayerItem,\n  NgwLayerOptionsAdditional,\n  NgwIdentify,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions\n} from '@nextgis/ngw-kit';\nimport { getIcon } from '@nextgis/icons';\n\nimport { onMapLoad } from './decorators';\nimport { appendNgwResources, prepareWebMapOptions, OPTIONS } from './utils';\n\nimport {\n  NgwMapOptions,\n  ControlOptions,\n  NgwMapEvents,\n  NgwLayers\n} from './interfaces';\nimport { Geometry, Feature, FeatureCollection } from 'geojson';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import NgwMap from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap(new MapAdapter(), {\n *   target: 'map',\n *   qmsId: 487,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<M = any, L = any, C = any, O = {}> extends WebMap<\n  M,\n  L,\n  C,\n  NgwMapEvents\n> {\n  static utils = {\n    ...WebMap.utils,\n    ...NgwKit.utils,\n    fixUrlStr,\n    deepmerge\n  };\n  static decorators = { onMapLoad, ...WebMap.decorators };\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwMapEvents\n  > = new EventEmitter();\n\n  options: NgwMapOptions<C> & O = {} as NgwMapOptions<C> & O;\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private __selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private __selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n\n  /**\n   * @param mapAdapter #noapi\n   * @param options\n   */\n  constructor(mapAdapter: MapAdapter, options: NgwMapOptions<C> & O) {\n    super(prepareWebMapOptions(mapAdapter, options));\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this.options = deepmerge(OPTIONS, options);\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      this._addControls();\n    });\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit() {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param [options] - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  @WebMap.decorators.onLoad<NgwMapEvents>('controls:create')\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPositions,\n    options?: MapControls[K]\n  ) {\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource id.\n   * @param options - set layer identification parameters and render method.\n   * @param [adapterOptions] - parameters for the selected adapter\n   *\n   * @example\n   * ```javascript\n   * var ngwMap = new NgwMap({ baseUrl: 'https://demo.nextgis.com', target: 'map' });\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resourceId: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resourceId: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  @onMapLoad()\n  async addNgwLayer(\n    options: NgwLayerOptions\n  ): Promise<ResourceAdapter | undefined> {\n    const keyname = (options as KeynamedNgwLayerOptions).keyname;\n    const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n    if (!keyname && !resourceId) {\n      throw new Error(\n        'resourceId or keyname is required parameter to add NGW layer'\n      );\n    }\n    if (this.options.baseUrl || this.options.baseUrl === '') {\n      try {\n        const adapter = NgwKit.utils.addNgwLayer(\n          options,\n          this,\n          this.options.baseUrl,\n          this.connector\n        );\n\n        const layer = (await this.addLayer(adapter, {\n          visibility: true,\n          // TODO: all options into one object\n          ...options,\n          ...options.adapterOptions\n        })) as ResourceAdapter;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n\n          if (layer.options.baseLayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n\n        return layer;\n      } catch (er) {\n        console.error(\"can't add ngw layer\", er);\n      }\n    }\n  }\n\n  async getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return NgwKit.utils.getNgwLayerItem({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureItem[]> {\n    return NgwKit.utils.getNgwLayerItems({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeature<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return NgwKit.utils.getNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return NgwKit.utils.getNgwLayerFeatures({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false\n  ): CancelablePromise<Feature | undefined> {\n    return NgwKit.utils.getIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple\n    });\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some(x => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as WebMapLayerItem[];\n        const dependFit = dependLayers.find(x => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   * @param layerDef\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.zoomToLayer(ngwLayer);\n   * ngwMap.zoomToLayer('ngw_layer_name');\n   * ```\n   */\n  async zoomToLayer(layerDef: string | ResourceAdapter) {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent);\n        }\n      } else {\n        let item: ResourceItem;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.get('resource.item', null, {\n            id: resourceId\n          });\n        }\n\n        NgwKit.utils.getNgwResourceExtent(item, this.connector).then(extent => {\n          if (extent) {\n            this.fitBounds(extent);\n          }\n        });\n      }\n    }\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection() {\n    if (!this.__selectFromNgwRaster) {\n      this.__selectFromNgwRaster = (ev: MapClickEvent) =>\n        this._selectFromNgwRaster(ev);\n      this.__selectFromNgwVector = (ev: OnLayerClickOptions) =>\n        this._selectFromNgwVector(ev);\n      this.emitter.on('click', this.__selectFromNgwRaster);\n      this.emitter.on('layer:click', this.__selectFromNgwVector);\n    }\n  }\n\n  disableSelection() {\n    if (this.__selectFromNgwRaster) {\n      this.emitter.off('click', this.__selectFromNgwRaster);\n      this.emitter.off('click', this._selectFromNgwVector);\n      this.__selectFromNgwRaster = undefined;\n      this.__selectFromNgwVector = undefined;\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create({ ...this.options });\n    if (this.options.qmsId) {\n      let qmsId: number;\n      let qmsLayerName: string | undefined;\n      if (Array.isArray(this.options.qmsId)) {\n        qmsId = this.options.qmsId[0];\n        qmsLayerName = this.options.qmsId[1];\n      } else {\n        qmsId = Number(this.options.qmsId);\n      }\n      const qmsLayerOptions: QmsAdapterOptions = {\n        qmsId\n      };\n      if (qmsLayerName) {\n        qmsLayerOptions.id = qmsLayerName;\n      }\n\n      await this.addBaseLayer('QMS', qmsLayerOptions).then(layer => {\n        this.showLayer(layer);\n      });\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach(x => {\n        const overwriteOptions = {} as NgwLayerOptionsAdditional;\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n\n    for (const r of resources) {\n      await this.addNgwLayer(r);\n    }\n\n    this._emitStatusEvent('ngw-map:create', this);\n\n    this.enableSelection();\n  }\n\n  private _addControls() {\n    if (this.options.controls) {\n      this.options.controls.forEach(x => {\n        let controlAdapterName = x;\n        let controlOptions: ControlOptions = {};\n        if (typeof x === 'string' && this.options.controlsOptions) {\n          if (this.options.controlsOptions[x]) {\n            controlOptions = this.options.controlsOptions[x];\n            if (controlOptions.control !== undefined) {\n              controlAdapterName = controlOptions.control;\n            }\n          }\n        }\n        const { position, ...options } = controlOptions;\n        this.addControl(controlAdapterName, position || 'top-left', options);\n      });\n    }\n    this._emitStatusEvent('controls:create');\n  }\n\n  private async _selectFromNgwVector(\n    ev: OnLayerClickOptions\n  ): Promise<FeatureLayersIdentify | undefined> {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties,\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature]\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items\n        };\n        this._emitStatusEvent('ngw:select', {\n          ...identify,\n          resources: [id],\n          sourceType: 'vector'\n        });\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    for (const nl in this._ngwLayers) {\n      const layer = this._ngwLayers[nl].layer;\n      if (layer.getIdentificationIds && layer.options.selectable) {\n        promises.push(layer.getIdentificationIds());\n      }\n    }\n    const getIds = await Promise.all(promises);\n    const ids: number[] = [];\n    getIds.forEach(x => {\n      if (x) {\n        x.forEach(y => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    const zoom = this.getZoom();\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const metresPerPixel =\n      (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n      Math.pow(2, zoom + 8);\n    // FIXME: understand the circle creation function\n    const radius = pixelRadius * metresPerPixel * 0.0005;\n    return NgwKit.utils\n      .sendIdentifyRequest(ev, {\n        layers: ids,\n        connector: this.connector,\n        radius\n      })\n      .then(resp => {\n        this._emitStatusEvent('ngw:select', {\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev\n        });\n        return resp;\n      });\n  }\n}\n","/**\n * @module ngw-map\n */\n\nimport { NgwMap } from './NgwMap';\n\nexport * from '@nextgis/webmap';\nexport * from './interfaces';\n\nexport { NgwMap };\nexport default NgwMap;\n","/**\n * @module ngw-connector\n */\ntype Reject = (reason?: any) => void;\ntype Resolve = (value?: any) => void;\n\nconst handleCallback = <T = never>(\n  resolve: Resolve,\n  reject: Reject,\n  callback: Resolve,\n  r: T\n) => {\n  try {\n    resolve(callback(r));\n  } catch (e) {\n    reject(e);\n  }\n};\n\nexport class CancelablePromise<T> implements Promise<T> {\n  readonly [Symbol.toStringTag]: string;\n\n  private _canceled = false;\n\n  private _promise?: Promise<T>;\n\n  constructor(\n    executor: (\n      resolve: (value?: T | PromiseLike<T>) => void,\n      reject: (reason?: any) => void\n    ) => void,\n    private onCancel?: (...args: any[]) => void\n  ) {\n    this._promise = new Promise(executor);\n  }\n\n  static resolve<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise(resolve => resolve(value));\n  }\n\n  static reject<T>(value: T | PromiseLike<T>): CancelablePromise<T> {\n    return new CancelablePromise((resolve, reject) => reject(value));\n  }\n\n  static all<T>(values: (T | PromiseLike<T>)[]): CancelablePromise<T[]> {\n    return new CancelablePromise((resolve, reject) => {\n      Promise.all(values)\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n\n  then<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null\n  ): CancelablePromise<TResult1 | TResult2> {\n    const p = new CancelablePromise(\n      (resolve, reject) => {\n        if (this._promise) {\n          this._promise.then(\n            r => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onfulfilled && !this._canceled) {\n                handleCallback(resolve, reject, onfulfilled, r);\n              } else {\n                resolve(r);\n              }\n            },\n            r => {\n              if (this._canceled) {\n                p.cancel();\n              }\n              if (onrejected && !this._canceled) {\n                handleCallback(resolve, reject, onrejected, r);\n              } else {\n                reject(r);\n              }\n            }\n          );\n        }\n      },\n      () => {\n        this.cancel();\n      }\n    );\n    return p as CancelablePromise<TResult1 | TResult2>;\n  }\n\n  catch<TResult = never>(\n    onrejected?:\n      | ((reason: any) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null\n  ): CancelablePromise<T | TResult> {\n    return this.then(undefined, onrejected);\n  }\n\n  cancel(errorCallback?: (...args: any[]) => void) {\n    this._canceled = true;\n    if (errorCallback && this._promise) {\n      this._promise.catch(errorCallback);\n    }\n    if (this.onCancel) {\n      this.onCancel();\n    }\n    this._destroy();\n    return this;\n  }\n\n  finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    if (this._promise) {\n      return this._promise.finally(onfinally);\n    }\n    return Promise.reject<T>(onfinally);\n  }\n\n  private _destroy() {\n    this.onCancel = undefined;\n    this._promise = undefined;\n  }\n}\n","// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\nimport { RequestOptions } from './interfaces';\n\nexport function loadJSON(\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions = {},\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) {\n  options.method = options.method || 'GET';\n\n  const xhr = new XMLHttpRequest();\n  xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n  if (options.responseType === 'blob') {\n    xhr.responseType = options.responseType;\n  }\n\n  const processingResponce = (forError = false) => {\n    const cb = forError ? error : callback;\n    if (options.responseType === 'blob') {\n      cb(xhr.response);\n    } else {\n      if (xhr.responseText) {\n        try {\n          cb(JSON.parse(xhr.responseText));\n        } catch (er) {\n          cb(xhr.responseText);\n        }\n      } else {\n        error({ message: '' });\n      }\n    }\n  };\n\n  xhr.onreadystatechange = () => {\n    if (\n      (xhr.readyState === 4 && xhr.status === 200) ||\n      (xhr.readyState === 3 && xhr.status === 201)\n    ) {\n      processingResponce();\n    } else if (xhr.readyState === 3 && xhr.status === 400) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 500) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 401) {\n      error(xhr.statusText);\n    } else if (xhr.readyState === 4) {\n      error('request error');\n    }\n  };\n\n  xhr.onerror = er => {\n    error(er);\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      const percentComplete = (e.loaded / e.total) * 100;\n      if (options.onProgress) {\n        options.onProgress(percentComplete);\n      }\n      // console.log(percentComplete + '% uploaded');\n    }\n  };\n\n  const headers = options.headers;\n  if (headers) {\n    for (const h in headers) {\n      const header = headers[h];\n      if (typeof header === 'string') {\n        xhr.setRequestHeader(h, header);\n      }\n    }\n  }\n  if (options.withCredentials !== undefined) {\n    xhr.withCredentials = options.withCredentials;\n  }\n\n  let data: FormData | any;\n  if (options.file) {\n    data = new FormData();\n    data.append('file', options.file);\n    if (options.data) {\n      for (const d in data) {\n        data.append(d, data[d]);\n      }\n    }\n  } else {\n    data = options.data\n      ? typeof options.data === 'string'\n        ? options.data\n        : JSON.stringify(options.data)\n      : null;\n  }\n  if (onCancel) {\n    onCancel.push(() => {\n      xhr.abort();\n    });\n  }\n  xhr.send(data);\n}\n\n// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }) {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","/**\n * @module ngw-connector\n */\nimport { CancelablePromise } from './CancelablePromise';\n\nimport { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport {\n  NgwConnectorOptions,\n  Router,\n  GetRequestItemsResponseMap,\n  RequestOptions,\n  Params,\n  LoadingQueue,\n  UserInfo,\n  Credentials,\n  PyramidRoute,\n  RequestHeaders,\n  PostRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  RequestItemKeys,\n  DeleteRequestItemsResponseMap,\n  PutRequestItemsResponseMap\n} from './interfaces';\nimport { loadJSON, template } from './utils';\nimport { EventEmitter } from 'events';\nimport { ResourceItem } from './types/ResourceItem';\n\nexport class NgwConnector {\n  emitter = new EventEmitter();\n  user?: UserInfo;\n  private routeStr = '/api/component/pyramid/route';\n  private route?: PyramidRoute;\n  private _loadingQueue: { [name: string]: LoadingQueue } = {};\n  private _loadingStatus: { [url: string]: boolean } = {};\n  private _keynames: Record<string, ResourceItem> = {};\n\n  constructor(public options: NgwConnectorOptions) {\n    if (this.options.route) {\n      this.routeStr = this.options.route;\n    }\n  }\n\n  setNextGisWeb(url: string) {\n    this.logout();\n    this.options.baseUrl = url;\n  }\n\n  async connect(): CancelablePromise<Router> {\n    if (this.route) {\n      return Promise.resolve(this.route);\n    } else {\n      if (this.options.auth) {\n        const { login, password } = this.options.auth;\n        if (login && password) {\n          await this.getUserInfo({ login, password });\n        }\n      }\n\n      return await this.makeQuery(this.routeStr, {}, {}).then(\n        (route: PyramidRoute) => {\n          this.route = route;\n          return route;\n        }\n      );\n    }\n  }\n\n  async login(credentials: Credentials) {\n    this.logout();\n    return this.getUserInfo(credentials);\n  }\n\n  logout() {\n    this._rejectLoadingQueue();\n    this._loadingStatus = {};\n    this.options.auth = undefined;\n    this.route = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n  }\n\n  getUserInfo(credentials: Credentials): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials)\n      // withCredentials: true\n    };\n\n    // Do not use request('auth.current_user') to avoid circular-references\n    return this.makeQuery('/api/component/auth/current_user', {}, options)\n      .then((data: UserInfo) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch(er => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  getAuthorizationHeaders(\n    credentials?: Credentials\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials) {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      return window.btoa(unescape(encodeURIComponent(`${login}:${password}`)));\n    }\n  }\n\n  async getResourceByKeyname(keyname: string) {\n    let resource: ResourceItem = this._keynames['keyname'];\n    if (!resource) {\n      const resources = await this.get('resource.search', null, { keyname });\n      resource = resources[0];\n      if (resource) {\n        this._keynames[keyname] = resource;\n      }\n    }\n    return resource;\n  }\n\n  async getResourceChildren(opt: {\n    keyname?: string;\n    resourceId?: number;\n  }): Promise<ResourceItem[]> {\n    let parent = opt.resourceId;\n    if (!opt.keyname && !opt.resourceId) {\n      throw new Error('No keyname or resourceId is set');\n    }\n    if (opt.keyname) {\n      const item = await this.getResourceByKeyname(opt.keyname);\n      parent = item.resource.id;\n    }\n    return await this.get('resource.collection', null, {\n      parent\n    });\n  }\n\n  async request<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys\n  >(\n    name: K,\n    params: (RequestItemsParamsMap[K] | {}) & { [name: string]: any } = {},\n    options?: RequestOptions\n  ): CancelablePromise<P[K]> {\n    const apiItems = await this.connect();\n    let apiItem = apiItems && apiItems[name];\n    if (apiItem) {\n      apiItem = [...apiItem];\n      let url = apiItem.shift();\n      if (apiItem.length) {\n        const replaceParams: {\n          [num: number]: string;\n        } = {};\n        for (let fry = 0; fry < apiItem.length; fry++) {\n          const arg = apiItem[fry];\n          replaceParams[fry] = '{' + arg + '}';\n          if (params[arg] === undefined) {\n            throw new Error(\n              '`' + arg + '`' + ' url api argument is not specified'\n            );\n          }\n        }\n        if (url) {\n          url = template(url, replaceParams);\n        }\n      }\n      // Transfer part of the parameters from `params` to the URL string\n      if (params) {\n        const paramArray = [];\n        for (const p in params) {\n          if (apiItem.indexOf(p) === -1) {\n            paramArray.push(`${p}=${params[p]}`);\n          }\n        }\n        if (paramArray.length) {\n          url = url + '?' + paramArray.join('&');\n        }\n      }\n      if (url) {\n        return this.makeQuery(url, params, options);\n      } else {\n        throw new Error('request url is not set');\n      }\n    }\n    return CancelablePromise.resolve({} as P[K]);\n  }\n\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    options.nocache = true;\n    return this.request<K, PostRequestItemsResponseMap>(name, params, options);\n  }\n\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    options.nocache = true;\n    return this.request<K, GetRequestItemsResponseMap>(name, params, options);\n  }\n\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    options.nocache = true;\n    return this.request<K, PatchRequestItemsResponseMap>(name, params, options);\n  }\n\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    options.nocache = true;\n    return this.request<K, PutRequestItemsResponseMap>(name, params, options);\n  }\n\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParamsMap[K] & { [name: string]: any }\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    options.nocache = true;\n    return this.request<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options\n    );\n  }\n\n  makeQuery(\n    url: string,\n    params?: Params,\n    options: RequestOptions = {}\n  ): CancelablePromise<any> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      // remove double slash\n      url = url.replace(/([^:]\\/)\\/+/g, '$1');\n      if (!this._loadingStatus[url] || options.nocache) {\n        this._loadingStatus[url] = true;\n\n        return this._getJson(url, options)\n          .then(data => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, data);\n            return data;\n          })\n          .catch(er => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, er, true);\n            this.emitter.emit('error', er);\n            throw er;\n          });\n      } else {\n        this._loadingStatus[url] = false;\n        return new CancelablePromise((resolve, reject) => {\n          this._setLoadingQueue(url, resolve, reject);\n        });\n      }\n    } else {\n      throw new Error('No `url` parameter set for option ' + name);\n    }\n  }\n\n  _setLoadingQueue(\n    name: string,\n    resolve: (...args: any[]) => any,\n    reject: (...args: any[]) => any\n  ) {\n    this._loadingQueue[name] = this._loadingQueue[name] || {\n      name,\n      waiting: []\n    };\n    this._loadingQueue[name].waiting.push({\n      resolve,\n      reject,\n      timestamp: new Date()\n    });\n  }\n\n  _rejectLoadingQueue() {\n    for (const q in this._loadingQueue) {\n      const queue = this._loadingQueue[q];\n      queue.waiting.forEach(x => {\n        x.reject();\n      });\n      delete this._loadingQueue[q];\n    }\n  }\n\n  _executeLoadingQueue(name: string, data: any, isError?: boolean) {\n    const queue = this._loadingQueue[name];\n    if (queue) {\n      for (let fry = 0; fry < queue.waiting.length; fry++) {\n        const wait = queue.waiting[fry];\n        if (isError) {\n          if (wait.reject) {\n            wait.reject();\n          }\n        } else {\n          wait.resolve(data);\n        }\n      }\n      queue.waiting = [];\n    }\n  }\n\n  _getJson(url: string, options: RequestOptions): CancelablePromise<any> {\n    const onCancel: (() => void)[] = [];\n    options.responseType = options.responseType || 'json';\n    return new CancelablePromise(\n      (resolve, reject) => {\n        if (this.user) {\n          options = options || {};\n          // options.withCredentials = true;\n          options.headers = {\n            ...this.getAuthorizationHeaders(),\n            ...options.headers\n          };\n        }\n        loadJSON(url, resolve, options, reject, onCancel);\n      },\n      () => {\n        onCancel.forEach(x => x());\n      }\n    );\n  }\n}\n","/**\n * @module ngw-connector\n */\n\nimport { NgwConnector } from './NgwConnector';\n\nexport { CancelablePromise } from './CancelablePromise';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\nexport { NgwConnector };\nexport default NgwConnector;\n","import { Geometry, Feature, FeatureCollection } from 'geojson';\nimport {\n  PropertiesFilter,\n  FilterOptions,\n  PropertyFilter\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  CancelablePromise,\n  FeatureItem\n} from '@nextgis/ngw-connector';\n\nexport interface FeatureRequestParams {\n  srs?: number;\n  fields?: string;\n  geom_format?: string;\n  limit?: number;\n  intersects?: string;\n}\n\nconst FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson'\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry\n  };\n  return feature;\n}\n\nexport function getNgwLayerItem<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<FeatureItem> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  return options.connector.get('feature_layer.feature.item', null, {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params\n  });\n}\n\nexport function getNgwLayerFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<Feature<G, P>> {\n  return getNgwLayerItem(options).then(item => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n\nfunction idFilterWorkAround<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(options: { filterById: any; resourceId: number; connector: NgwConnector }) {\n  const value = options.filterById[2];\n  const featureIds: number[] =\n    typeof value === 'number'\n      ? [value]\n      : value.split(',').map((x: string) => Number(x));\n  if (options.filterById[1] !== 'eq' && options.filterById[1] !== 'in') {\n    throw new Error(\n      'Unable to filter by object id. Except `eq` or `in` operator'\n    );\n  }\n  const promises: Promise<FeatureItem>[] = featureIds.map(featureId => {\n    return getNgwLayerItem<G, P>({\n      connector: options.connector,\n      resourceId: options.resourceId,\n      featureId\n    });\n  });\n  return CancelablePromise.all(promises);\n}\n\nexport function getNgwLayerItems<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & FilterOptions\n): CancelablePromise<FeatureItem[]> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  const { connector, filters, limit, fields, intersects, resourceId } = options;\n  if (filters) {\n    const filters_ = filters.filter(x => Array.isArray(x)) as PropertyFilter[];\n    const filterById = filters_.find(x => x[0] === 'id');\n    if (filterById) {\n      return idFilterWorkAround({ filterById, connector, resourceId });\n    }\n    filters_.forEach(([field, operation, value]) => {\n      params[`fld_${field}__${operation}`] = `${value}`;\n    });\n  }\n  if (limit) {\n    params.limit = limit;\n  }\n  if (fields) {\n    params.fields = fields.join();\n  }\n  if (intersects) {\n    params.intersects = intersects;\n  }\n  return connector.get('feature_layer.feature.collection', null, {\n    id: resourceId,\n    ...params\n  });\n}\n\nexport function getNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & FilterOptions\n): CancelablePromise<FeatureCollection<G, P>> {\n  return getNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach(y => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features\n    };\n    return featureCollection;\n  });\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport {\n  NgwLayerOptions,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions\n} from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector\n) {\n  const keyname = (options as KeynamedNgwLayerOptions).keyname;\n  let resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResourceByKeyname(keyname);\n    resourceId = resourceItem.resource.id;\n  }\n  return resourceId;\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, {\n  VectorLayerAdapter,\n  Type,\n  GeoJsonAdapterOptions,\n  PropertiesFilter,\n  FilterOptions\n} from '@nextgis/webmap';\nimport NgwConnector, { CancelablePromise } from '@nextgis/ngw-connector';\nimport { GeoJsonObject } from 'geojson';\nimport { getNgwLayerFeatures } from './utils/featureLayerUtils';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createGeoJsonAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector\n) {\n  const adapter = webMap.mapAdapter.layerAdapters.GEOJSON as Type<\n    VectorLayerAdapter\n  >;\n\n  let _dataPromise: CancelablePromise<any> | undefined;\n  const _fullDataLoad = false;\n  let _lastFilterArgs:\n    | { filters?: PropertiesFilter; options?: FilterOptions }\n    | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  const geoJsonAdapterCb = async (\n    filters?: PropertiesFilter,\n    opt?: FilterOptions\n  ) => {\n    _lastFilterArgs = { filters, options: opt };\n    _dataPromise = getNgwLayerFeatures({\n      resourceId,\n      filters,\n      connector,\n      ...opt\n    });\n    return await _dataPromise;\n  };\n\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  const onLoad = (data: GeoJsonObject) => {\n    const geoJsonOptions: GeoJsonAdapterOptions = {\n      data\n    };\n    if (options.id) {\n      geoJsonOptions.id = options.id;\n    }\n    return WebMap.utils.updateGeoJsonAdapterOptions(geoJsonOptions);\n  };\n  return class Adapter extends adapter {\n    async addLayer(_opt: GeoJsonAdapterOptions) {\n      let data = {} as GeoJsonObject;\n      if (!_opt.data) {\n        data = await geoJsonAdapterCb(_opt.propertiesFilter, {\n          limit: _opt.limit\n        });\n      }\n      const opt = onLoad(data);\n      const addLayerOptions = { ..._opt, ...opt };\n      if (\n        addLayerOptions.data &&\n        Object.keys(addLayerOptions.data).length === 0\n      ) {\n        addLayerOptions.data = undefined;\n      }\n      return super.addLayer(addLayerOptions);\n    }\n\n    beforeRemove() {\n      abort();\n    }\n\n    async updateLayer() {\n      const { filters, options } = _lastFilterArgs || {};\n      const data = await geoJsonAdapterCb(filters, options);\n      if (this.setData) {\n        this.setData(data);\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter(e => {\n          if (e.feature && e.feature.properties) {\n            return WebMap.utils.propertiesFilter(e.feature.properties, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await geoJsonAdapterCb(filters, opt);\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(function() {\n          return true;\n        });\n      }\n    }\n  };\n}\n","import { NgwLayerOptions, ResourceAdapter } from './interfaces';\nimport WebMap, {\n  BaseLayerAdapter,\n  Type,\n  ImageAdapterOptions,\n  TileAdapterOptions\n} from '@nextgis/webmap';\nimport { getLayerAdapterOptions } from './utils/utils';\nimport NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createRasterAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<BaseLayerAdapter> | undefined> {\n  let adapter = options.adapter || 'IMAGE';\n\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n  if (adapter === 'IMAGE' || adapter === 'TILE' || adapter === 'MVT') {\n    const adapterClass = webMap.mapAdapter.layerAdapters[adapter] as Type<\n      BaseLayerAdapter\n    >;\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    return class Adapter extends adapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = getLayerAdapterOptions(options, webMap, baseUrl);\n        if (opt) {\n          if (opt.resourceId) {\n            const layerAdapterOptions: ImageAdapterOptions = {\n              ...opt,\n              resourceId: opt.resourceId\n            };\n            this.options = { ...this.options, ...layerAdapterOptions };\n          } else {\n            const tileAdapterOptions: TileAdapterOptions = opt;\n            this.options = { ...this.options, ...tileAdapterOptions };\n          }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (id) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","/**\n * @module item\n */\nexport type SelfFilter<X extends any> = (x: X) => boolean;\nexport type RelationFunction<X extends any> = (x: X) => X | X[] | undefined;\n\nexport function filterIn<F extends any = any>(\n  item: F | F[],\n  filterFunc: SelfFilter<F> = (x: F) => !!x,\n  relationFunc: RelationFunction<F>,\n  _filtered: F[] = []\n): F[] {\n  let children: F[] = [];\n  if (Array.isArray(item)) {\n    children = item;\n  } else {\n    const filter = filterFunc(item);\n    if (filter) {\n      _filtered.push(item);\n    }\n    const relChild = relationFunc(item);\n    if (relChild) {\n      if (Array.isArray(relChild)) {\n        children = relChild;\n      } else {\n        children.push(relChild);\n      }\n    }\n  }\n\n  for (let fry = 0; fry < children.length; fry++) {\n    if (children[fry]) {\n      filterIn(children[fry], filterFunc, relationFunc, _filtered);\n    }\n  }\n\n  return _filtered;\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\nimport { filterIn } from './TreeUtil';\n\nexport class TreeHelper {\n  item: Item;\n\n  private _children: Item[] = [];\n  private _parent?: Item;\n\n  constructor(item: Item) {\n    this.item = item;\n  }\n\n  // region Parents\n  setParent(parent: Item) {\n    this._parent = parent;\n  }\n\n  addChild(child: Item) {\n    this._children.push(child);\n  }\n\n  getParent(): Item | undefined {\n    return this._parent;\n  }\n\n  getParents<I extends Item = Item>(filterFunc?: (item: I) => boolean): I[] {\n    const parent = this.getParent() as I;\n    if (parent) {\n      return filterIn(parent, filterFunc, (x: I) => x.tree.getParent() as I);\n    }\n    return [];\n  }\n\n  getRoot<I extends Item = Item>(): I | undefined {\n    let parent = this.getParent() as I;\n    let toReturn = parent;\n    while (parent) {\n      parent = parent.tree.getParent() as I;\n      if (parent) {\n        toReturn = parent;\n      }\n    }\n    return toReturn;\n  }\n  // endregion\n\n  // region Child\n  find(filterFunc?: (item: Item) => boolean) {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    })[0];\n  }\n\n  // getDescendants shortcut\n  all(filterFunc?: (item: Item) => boolean): any[] {\n    return this.getDescendants(filterFunc);\n  }\n\n  getDescendants(filterFunc?: (item: Item) => boolean): any[] {\n    return filterIn(this._children, filterFunc, x => {\n      return x.tree.getChildren();\n    });\n  }\n\n  getChildren<T extends Item = Item>(): T[] {\n    return this._children as T[];\n  }\n}\n","/**\n * @module item\n */\nimport { Item } from '../Item';\nimport { ItemBasePropertyOptions } from '../interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\n// import StrictEventEmitter from 'strict-event-emitter-types/types/src';\n\n// export interface BasePropertyEvents<V, O> {\n//   'change': {value: V, options: O};\n//   'change-tree': {value: V, options: O, item: Item};\n// }\n\nexport abstract class BaseProperty<\n  V = any,\n  O extends ItemBasePropertyOptions<V> = ItemBasePropertyOptions<V>\n> {\n  options: O;\n\n  // emitter: StrictEventEmitter<EventEmitter, BasePropertyEvents<V, O>> = new EventEmitter();\n  emitter = EventEmitter && new EventEmitter();\n  name: string;\n\n  item: Item;\n  protected _blocked = false;\n  protected _container?: HTMLElement;\n  protected _value?: V;\n\n  private _removeEventsListener?: () => void;\n\n  constructor(name: string, item: Item, options: O) {\n    this.item = item;\n    this.options = Object.assign({}, options);\n    this.name = name;\n    this._value = this.getProperty();\n  }\n\n  getProperty() {\n    if (typeof this.options.getProperty === 'function') {\n      return this.options.getProperty.call(this, this.item);\n    }\n    return this.options.value;\n  }\n\n  getParents(): Item[] {\n    return this.item.tree.getParents() || [];\n  }\n\n  getParent() {\n    return this.item.tree.getParent();\n  }\n\n  isGroup() {\n    const children = this.item.tree.getDescendants();\n    return children.length;\n  }\n\n  isBlocked() {\n    if (this._blocked === undefined) {\n      const parents = this.item.tree.getParents();\n      if (parents) {\n        const isBlocked = parents.find((x: Item) => {\n          const parentProp = x.properties && x.properties.property(this.name);\n          if (parentProp) {\n            return !parentProp.get();\n          }\n          return false;\n        });\n        this._blocked = !!isBlocked;\n      } else {\n        this._blocked = false;\n      }\n    }\n    return this._blocked;\n  }\n\n  set(value?: V, options?: O) {\n    this._value = this._prepareValue(value);\n\n    this.update(this._value, options);\n    this._fireChangeEvent(this._value, options);\n  }\n\n  // shortcut for getValue\n  get(): V | undefined {\n    return this.getValue();\n  }\n\n  update(value?: V, options?: O) {\n    this._callOnSet(value, options);\n  }\n\n  getContainer() {\n    return this._container;\n  }\n\n  destroy() {\n    if (this._container) {\n      const parentNode = this._container.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._container);\n      }\n    }\n    if (this._removeEventsListener) {\n      this._removeEventsListener();\n    }\n  }\n\n  getValue(): V | undefined {\n    return this._value !== undefined ? this._value : this.getProperty();\n  }\n\n  protected _prepareValue(value?: V): V | undefined {\n    return value;\n  }\n\n  protected _callOnSet<W extends V = V>(value?: W, options?: O) {\n    if (this.options.onSet) {\n      this.options.onSet.call(this, value, options, this.item);\n    }\n  }\n\n  protected _fireChangeEvent(value?: V, options?: O) {\n    if (this.emitter) {\n      value = value !== undefined ? value : this.getValue();\n      this.emitter.emit('change', { value, options });\n      const parents = this.item.tree.getParents();\n      parents.forEach(x => {\n        const prop = x.properties && x.properties.property(this.name);\n        if (prop) {\n          prop.emitter.emit('change-tree', { value, options, item: this.item });\n        }\n      });\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { TreeHelper } from './TreeHelper';\nimport { ItemProperties } from './properties/ItemProperties';\nimport { ItemOptions } from './interfaces';\n\nlet events;\ntry {\n  events = require('events');\n} catch (er) {\n  // ignore\n}\n// tslint:disable-next-line:variable-name\nconst EventEmitter = events && events.EventEmitter;\n\nlet ID = 0;\nexport class Item<O extends ItemOptions = ItemOptions> {\n  options: O = {} as O;\n\n  properties!: ItemProperties;\n  tree: TreeHelper;\n  id = ID;\n  emitter = EventEmitter && new EventEmitter();\n\n  constructor(options?: O) {\n    ID += 1;\n    this.options = { ...options } as O;\n    this.tree = new TreeHelper(this);\n  }\n\n  initProperties() {\n    this.properties = new ItemProperties(this, this.options.properties);\n  }\n}\n","/**\n * @module item\n */\nimport { BaseProperty } from './BaseProperty';\nimport { Item } from '../Item';\n\nimport { CheckOptions } from '../interfaces';\n\ntype VAL = boolean;\n\nexport class CheckProperty<\n  V extends VAL = VAL,\n  O extends CheckOptions<VAL> = CheckOptions<VAL>\n> extends BaseProperty<VAL, CheckOptions<VAL>> {\n  static options: CheckOptions = {\n    hierarchy: true,\n    bubble: false,\n    propagation: false,\n    label: 'Toggle'\n    // PropertyContainer: IndicatorContainer\n  };\n\n  constructor(name: string, item: Item, options: O) {\n    super(name, item, { ...CheckProperty.options, ...options });\n    this.set(this.get());\n  }\n\n  update(value?: V, options?: O) {\n    if (value) {\n      const bubble = (options && options.bubble) || this.options.bubble;\n      if (bubble) {\n        this.unBlock(options);\n        const parent = this.getParent();\n        const property =\n          parent && parent.properties && parent.properties.property(this.name);\n        if (property) {\n          property.set(\n            value,\n            Object.assign({}, options, { bubble: true, propagation: false })\n          );\n        }\n      }\n      if (!this.isBlocked()) {\n        this._turnOn(options);\n      }\n    } else {\n      this._turnOff(options);\n    }\n    const propagation =\n      (options && options.propagation) || this.options.propagation;\n    if (propagation) {\n      this._propagation(value, options);\n    }\n  }\n\n  getHierarchyValue() {\n    return (\n      this.get() &&\n      this.getParents().every(x => {\n        const property = x.properties && x.properties.get(this.name);\n        return property && property.get();\n      })\n    );\n  }\n\n  _prepareValue(value?: any): V | undefined {\n    return value;\n  }\n\n  _turnOff(options?: O) {\n    if (this.options.turnOff) {\n      this.options.turnOff.call(this, options);\n    }\n    this._callOnSet(false, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.blockChilds(options);\n    }\n  }\n\n  _turnOn(options?: O) {\n    if (this.options.turnOn) {\n      this.options.turnOn.call(this, options);\n    }\n    this._callOnSet(true, options);\n    if (this.options.hierarchy && this.isGroup()) {\n      this.unblockChilds(options);\n    }\n  }\n\n  block(options?: O) {\n    this._blocked = true;\n    this._block(options);\n  }\n\n  _block(options?: O) {\n    this._turnOff(options);\n  }\n\n  unBlock(options?: O) {\n    this._blocked = false;\n    if (this.getValue()) {\n      this._unBlock(options);\n    }\n  }\n\n  _unBlock(options?: O) {\n    this._turnOn(options);\n  }\n\n  blockChilds(options?: O) {\n    this.item.tree.getDescendants().forEach(x => this._blockChild(x, options));\n  }\n\n  unblockChilds(options?: O) {\n    this.item.tree.getChildren().forEach(x => this._unBlockChild(x, options));\n  }\n\n  _blockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.block) {\n      prop.block(options);\n    }\n  }\n\n  _unBlockChild(item: Item, options?: O) {\n    const prop =\n      item.properties &&\n      (item.properties.property(this.name) as CheckProperty<V, O>);\n    if (prop && prop.unBlock) {\n      prop.unBlock(options);\n    }\n  }\n\n  _propagation(value?: V, options?: O) {\n    if (this.isGroup()) {\n      const children = this.item.tree.getChildren();\n      for (let fry = 0; fry < children.length; fry++) {\n        const child = children[fry];\n        const property =\n          child.properties &&\n          (child.properties.property(this.name) as CheckProperty<V, O>);\n        if (property) {\n          property.set(value, {\n            ...options,\n            ...{\n              propagation: true,\n              bubble: false\n            }\n          });\n        }\n      }\n    }\n  }\n}\n","/**\n * @module item\n */\n\nimport { BaseProperty } from './BaseProperty';\nimport { CheckProperty } from './CheckProperty';\nimport { Item } from '../Item';\n\nimport {\n  ItemBasePropertyOptions,\n  Type,\n  ItemPropertyConfig,\n  ItemPropertyTypes\n} from '../interfaces';\n\nexport class ItemProperties {\n  static handlers: { [name: string]: Type<BaseProperty> } = {\n    CheckProperty\n  };\n\n  options = {};\n\n  private _properties: { [propName: string]: BaseProperty } = {};\n  private _propertiesList: string[];\n\n  constructor(\n    public item: Item,\n    propertiesList?: ItemPropertyConfig<keyof ItemPropertyTypes>[]\n  ) {\n    this._propertiesList = []; // ordered list\n    if (propertiesList) {\n      propertiesList.forEach(this._setPropertyHandler.bind(this));\n    }\n  }\n\n  add(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    this._setPropertyHandler(propOpt);\n  }\n\n  _setPropertyHandler(propOpt: ItemPropertyConfig<keyof ItemPropertyTypes>) {\n    const handlers = ItemProperties.handlers;\n    let handler = propOpt.handler;\n    if (!handler && propOpt.type) {\n      switch (propOpt.type) {\n        case 'boolean':\n          handler = handlers.CheckProperty;\n          break;\n        case 'string':\n          handler = handlers.BaseProperty;\n          break;\n        default:\n          handler = handlers.BaseProperty;\n      }\n    }\n    if (handler && propOpt.name) {\n      const options = { ...(propOpt || {}) };\n      this._properties[propOpt.name] = new handler(\n        propOpt.name,\n        this.item,\n        options\n      );\n      this._propertiesList.push(propOpt.name);\n    }\n  }\n\n  update() {\n    this.list().forEach(x => {\n      x.update();\n    });\n  }\n\n  get(name: string) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.get();\n    }\n  }\n\n  set<K extends keyof ItemPropertyTypes>(\n    name: string,\n    value: ItemPropertyTypes[K],\n    options?: ItemBasePropertyOptions<ItemPropertyTypes[K]>\n  ) {\n    const prop = this.property(name);\n    if (prop) {\n      return prop.set(value, options);\n    }\n  }\n\n  property(name: string) {\n    return this._properties[name];\n  }\n\n  list() {\n    return this._propertiesList.map(x => this._properties[x]);\n  }\n\n  destroy() {\n    for (const p in this._properties) {\n      const prop = this.property(p);\n      if (prop && prop.destroy) {\n        prop.destroy();\n      }\n    }\n    this._properties = {};\n    this._propertiesList = [];\n  }\n}\n","/**\n * @module item\n */\n\nimport { Item } from './Item';\n\nexport * from './interfaces';\nexport * from './properties/BaseProperty';\nexport * from './properties/CheckProperty';\nexport * from './properties/ItemProperties';\n\nexport { Item };\nexport default Item;\n","/**\n * @module ngw-kit\n */\n\nimport Item, { ItemOptions } from '@nextgis/item';\n\nimport WebMap, { LayerAdaptersOptions, LayerAdapter } from '@nextgis/webmap';\nimport { TreeGroup, TreeLayer } from './interfaces';\nimport { setScaleRatio } from './utils/utils';\n\nexport class WebMapLayerItem extends Item<ItemOptions> {\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: WebMapLayerItem) {\n          if (item) {\n            if (item.item.item_type === 'group') {\n              return true;\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            } else if (item.item.item_type === 'root') {\n              return true;\n            }\n          }\n          return false;\n        },\n        onSet(value: boolean, options?: any, item?: WebMapLayerItem) {\n          if (item && item.layer && item.item.item_type === 'layer') {\n            if (value) {\n              item.webMap.showLayer(item.layer);\n            } else {\n              item.webMap.hideLayer(item.layer);\n            }\n            item.item['layer_enabled'] = value;\n          }\n        }\n      }\n    ]\n  };\n\n  item: TreeGroup | TreeLayer;\n  layer?: LayerAdapter;\n\n  _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    parent?: WebMapLayerItem\n  ) {\n    super({ ...WebMapLayerItem.options, ...options });\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n\n    this.initProperties();\n    this._init(item);\n  }\n\n  async initItem(item: TreeGroup | TreeLayer) {\n    let newLayer = item._layer;\n    const i = item;\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        item.children.reverse().forEach(x => {\n          const children = new WebMapLayerItem(\n            this.webMap,\n            x,\n            this.options,\n            this\n          );\n          this.tree.addChild(children);\n        });\n      }\n    } else if (item.item_type === 'layer') {\n      const adapter = (item.adapter ||\n        item.layer_adapter.toUpperCase()) as keyof LayerAdaptersOptions;\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      const options: any = {\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n        ...item,\n        headers: this.options.headers\n      };\n      if (this.options.order) {\n        const subOrder = this.options.drawOrderEnabled\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n        options.order = Number((this.options.order | 0) + '.' + subOrder);\n      }\n      newLayer = await this.webMap.addLayer(adapter, options);\n    }\n    if (newLayer) {\n      i._layer = newLayer;\n      this.layer = newLayer;\n      if (this.properties && item.item_type === 'layer' && item.layer_enabled) {\n        this.properties.property('visibility').set(true);\n      }\n      const transparency =\n        item.item_type === 'layer' && item.layer_transparency;\n      if (typeof transparency === 'number') {\n        const opacity = (100 - transparency) / 100;\n        this.webMap.setLayerOpacity(newLayer, opacity);\n      }\n    } else {\n      // this.properties.get('visibility').set(true);\n    }\n  }\n\n  bringToFront() {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      console.log(this.item);\n    }\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private async _init(item: TreeGroup | TreeLayer) {\n    await this.initItem(item);\n    this.emitter.emit('init');\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import WebMap, { LngLatBoundsArray, MapClickEvent } from '@nextgis/webmap';\nimport { ResourceItem, CancelablePromise } from '@nextgis/ngw-connector';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  getLayerAdapterOptions,\n  updateWmsParams,\n  sendIdentifyRequest,\n  getWebMapExtent\n} from './utils/utils';\nimport { WebMapLayerItem } from './WebMapLayerItem';\nimport { ItemOptions } from '@nextgis/item';\n\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport {\n  TreeGroup,\n  TreeLayer,\n  NgwLayerAdapterType,\n  WebMapAdapterOptions,\n  WebMapLayerAdapterEvents,\n  ResourceAdapter\n} from './interfaces';\n\nexport class WebMapLayerAdapter implements ResourceAdapter {\n  layer?: WebMapLayerItem;\n\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    WebMapLayerAdapterEvents\n  > = new EventEmitter();\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  private $$onMapClick?: (ev: MapClickEvent) => void;\n\n  constructor(public map: any, public options: WebMapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: WebMapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n\n    this.layer = await this._getWebMapLayerItem();\n\n    if (this.options.identification) {\n      const ids = await this._getWebMapIds();\n      if (ids) {\n        this._webmapLayersIds = ids;\n        this.$$onMapClick = (ev: MapClickEvent) => this._onMapClick(ev);\n        this.options.webMap.emitter.on('click', this.$$onMapClick);\n      }\n    }\n    return this.layer;\n  }\n\n  removeLayer() {\n    const mapAdapter = this.options.webMap.mapAdapter;\n    if (this.$$onMapClick) {\n      this.options.webMap.emitter.off('click', this.$$onMapClick);\n    }\n    this.getDependLayers().forEach(x => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    this.$$onMapClick = undefined;\n    delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getWebMapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<WebMapLayerItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  async getIdentificationIds() {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => a.id - b.id);\n      deps.forEach(x => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  private async _getWebMapLayerItem(): Promise<WebMapLayerItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<WebMapLayerItem>(resolve => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.order = this.options.order;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new WebMapLayerItem(\n            this.options.webMap,\n            webmap.root_item,\n            options\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    try {\n      const data = await this.options.connector.get('resource.item', null, {\n        id\n      });\n      this.response = data;\n      const webmap = data.webmap;\n      if (webmap) {\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    } catch (er) {\n      throw er;\n    }\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map(x =>\n            this._updateItemsParams(x, webMap, data)\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.baseUrl + '/api/component/render/image'\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = params => updateWmsParams(params, resourceId);\n        item = {\n          ...item,\n          ...getLayerAdapterOptions(\n            {\n              adapter: item.layer_adapter.toUpperCase() as NgwLayerAdapterType,\n              resourceId\n            },\n            webMap,\n            this.options.baseUrl\n          )\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: WebMapLayerItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector\n            .get('resource.item', {}, { id })\n            .then(y => {\n              if (y) {\n                const parentId = Number(y.resource.parent.id);\n                item.parentId = parentId;\n                return parentId;\n              }\n            });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter(x => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n\n  private _sendIdentifyRequest(ev: MapClickEvent) {\n    if (this._webmapLayersIds) {\n      return sendIdentifyRequest(ev, {\n        layers: this._webmapLayersIds,\n        connector: this.options.connector,\n        radius: this.pixelRadius\n      }).then(resp => {\n        this.emitter.emit('identify', { ev, data: resp });\n        return resp;\n      });\n    }\n  }\n\n  private _onMapClick(ev: MapClickEvent) {\n    this._sendIdentifyRequest(ev);\n  }\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { getNgwResourceExtent } from './utils/utils';\nimport { LngLatBoundsArray } from '@nextgis/webmap';\n\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  private _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await getNgwResourceExtent(\n        this.item,\n        this.connector\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem\n} from '@nextgis/ngw-connector';\nimport WebMap, { LayerAdapter, Type } from '@nextgis/webmap';\nimport QmsKit from '@nextgis/qms-kit';\nimport { ResourceAdapter, NgwLayerOptions } from './interfaces';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createWebMapAdapter';\nimport { applyMixins } from './utils/utils';\nimport { NgwResource } from './NgwResource';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nconst styles: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'raster_style'\n];\n\nasync function createAdapterFromFirstStyle(\n  parent: number,\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n) {\n  const childrenStyles = await connector.get('resource.collection', null, {\n    parent\n  });\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...options, resourceId: firstStyle.resource.id },\n      webMap,\n      baseUrl,\n      connector\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: Promise<Type<LayerAdapter> | undefined> | undefined;\n  let item: ResourceItem | undefined;\n  try {\n    const adapterType = options.adapter;\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    if (resourceId) {\n      item = await connector.get('resource.item', null, { id: resourceId });\n\n      if (item) {\n        const _options: NgwLayerOptions = { ...options, resourceId };\n        if (item.webmap) {\n          adapter = createWebMapAdapter(_options, webMap, baseUrl, connector);\n        } else if (styles.indexOf(item.resource.cls) !== -1) {\n          if (adapterType === 'GEOJSON') {\n            const parentOptions: NgwLayerOptions = {\n              ...options,\n              resourceId: item.resource.parent.id\n            };\n            adapter = createGeoJsonAdapter(parentOptions, webMap, connector);\n          } else {\n            adapter = createRasterAdapter(_options, webMap, baseUrl, connector);\n          }\n        } else if (item.resource.cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            } else {\n              return createAdapterFromFirstStyle(\n                item.resource.id,\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            }\n          } else {\n            adapter = createGeoJsonAdapter(_options, webMap, connector);\n          }\n        } else if (item.resource.cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(\n            item.resource.id,\n            _options,\n            webMap,\n            baseUrl,\n            connector\n          );\n        } else if (item.basemap_layer && item.basemap_layer.qms) {\n          adapter = Promise.resolve(QmsKit.utils.createQmsAdapter(webMap));\n          adapter.then(x => {\n            if (x && item && item.basemap_layer && item.basemap_layer.qms) {\n              const qms = JSON.parse(item.basemap_layer.qms);\n              x.prototype.qms = qms;\n              x.prototype.baseLayer = true;\n            }\n          });\n        }\n      } else {\n        throw new Error(\n          \"Can't add NGW layer because Resource item is not found\"\n        );\n      }\n    }\n  } catch (er) {\n    // if (options.adapter === 'GEOJSON') {\n    //   adapter = createGeoJsonAdapter(options, webMap, connector);\n    // } else {\n    //   adapter = createRasterAdapter(options, webMap, baseUrl);\n    // }\n  }\n  if (adapter) {\n    return adapter.then(x => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        resourceAdapter.prototype.item = item;\n        resourceAdapter.prototype.connector = connector;\n\n        applyMixins(resourceAdapter, [NgwResource]);\n\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, { Type } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createWebMapAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<WebMapLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class Adapter extends WebMapLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        webMap,\n        resourceId,\n        baseUrl,\n        connector\n      });\n    }\n  };\n}\n","import WebMap, {\n  Type,\n  LngLatBoundsArray,\n  MapClickEvent\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  WebmapResource,\n  ResourceItem,\n  FeatureLayersIdentify\n} from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../createAsyncAdapter';\nimport {\n  NgwLayerOptions,\n  WebMapAdapterOptions,\n  IdentifyRequestOptions,\n  ResourceAdapter,\n  ResourceIdNgwLayerOptions\n} from '../interfaces';\nimport { WebMapLayerAdapter } from '../WebMapLayerAdapter';\n\nexport function updateWmsParams(params: any, resourceId: number) {\n  const { bbox, width, height } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now()\n  };\n}\n\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string\n) {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  // const keyname = (options as KeynamedNgwLayerOptions).keyname;\n  const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n  // if (!resourceId && keyname) {\n  //   const resourceItem = await connector.getResourceByKeyname(keyname);\n  //   resourceId = resourceItem.resource.id;\n  // }\n  if (resourceId) {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          updateWmsParams: (params: any) => updateWmsParams(params, resourceId)\n        };\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url\n      };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId;\n      return { url, adapter };\n    }\n  } else {\n    console.log('Options `resourceId` not set');\n  }\n}\n\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, baseUrl, connector);\n}\n\nexport function getWebMapExtent(\n  webmap: WebmapResource\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function getNgwLayerExtent(\n  id: number,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  return connector.get('layer.extent', name, { id }).then(resp => {\n    if (resp) {\n      const { maxLat, maxLon, minLat, minLon } = resp.extent;\n      const extenrArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n      return extenrArray;\n    }\n  });\n}\n\nexport async function getNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return getWebMapExtent(item.webmap);\n  } else {\n    const resource = item.resource;\n    if (resource.cls.indexOf('style') !== -1) {\n      return connector\n        .get('resource.item', null, {\n          id: resource.parent.id\n        })\n        .then(res => {\n          return getNgwLayerExtent(res.resource.id, connector);\n        });\n    } else {\n      return getNgwLayerExtent(resource.id, connector);\n    }\n  }\n}\n\ninterface FeatureIdentifyRequestOptions {\n  /**\n   * WKT Polygon geometry\n   */\n  geom: string;\n  srs: 3857;\n  layers: number[];\n}\n\nconst d2r = Math.PI / 180; // degrees to radians\nconst r2d = 180 / Math.PI; // radians to degrees\nconst earthsradius = 3963; // 3963 is the radius of the earth in miles\n\nexport function getCirclePoly(\n  lng: number,\n  lat: number,\n  radius = 10,\n  points = 6\n) {\n  // find the radius in lat/lon\n  const rlat = (radius / earthsradius) * r2d;\n  const rlng = rlat / Math.cos(lat * d2r);\n\n  const extp = [];\n  for (let i = 0; i < points + 1; i++) {\n    // one extra here makes sure we connect the\n\n    const theta = Math.PI * (i / (points / 2));\n    const ex = lng + rlng * Math.cos(theta); // center a + radius x * cos(theta)\n    const ey = lat + rlat * Math.sin(theta); // center b + radius y * sin(theta)\n    extp.push([ex, ey]);\n  }\n\n  // add the circle to the map\n  return extp;\n}\n\nexport function degrees2meters(lng: number, lat: number): [number, number] {\n  const x = (lng * 20037508.34) / 180;\n  let y = Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);\n  y = (y * 20037508.34) / 180;\n  return [x, y];\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions\n  // webMap: WebMap\n): Promise<FeatureLayersIdentify> {\n  // webMap.emitter.emit('start-identify', { ev });\n  const geom = getCirclePoly(ev.latLng.lng, ev.latLng.lat, options.radius);\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  // webMap.addLayer('GEOJSON', {\n  //   visibility: true,\n  //   data: {\n  //     type: 'Feature',\n  //     geometry: {\n  //       type: 'Polygon',\n  //       coordinates: [geom]\n  //     }\n  //   }\n  // })\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\ninterface ExtendWebMapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendWebMapLayerAdapter(\n  opt: ExtendWebMapLayerAdapterOptions\n): Type<WebMapLayerAdapter> {\n  class A extends WebMapLayerAdapter {\n    constructor(map: any, options: WebMapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth() {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        baseCtor.prototype,\n        name\n      );\n      if (descriptor) {\n        Object.defineProperty(derivedCtor.prototype, name, descriptor);\n      }\n    });\n  });\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number) {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 104) {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n  if (lat) {\n    const centerLat = lat;\n    const crsScale =\n      (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n    const zoom = getZoomFromScale(crsScale);\n    return zoom;\n  }\n  return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import { LayerFeature } from '@nextgis/ngw-connector';\nimport { getNgwLayerFeature, createGeoJsonFeature } from './featureLayerUtils';\nimport { GetIdentifyGeoJsonOptions, NgwIdentify } from '../interfaces';\nimport { Geometry } from 'geojson';\n\nexport function getIdentifyGeoJsonParams(\n  identify: NgwIdentify,\n  multiple = false\n) {\n  let params: { resourceId: number; featureId: number } | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort(function(a, b) {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const layerFeatures = identify[l].features;\n    const resourceId = Number(l);\n    const f: LayerFeature | undefined = layerFeatures[0];\n    if (f) {\n      params = {\n        featureId: f.id,\n        resourceId\n      };\n      paramsList.push(params);\n      if (!multiple) {\n        break;\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function getIdentifyGeoJson(options: GetIdentifyGeoJsonOptions) {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      const withGeom = item.features.find(x => x.geom);\n\n      if (withGeom && withGeom.geom) {\n        const geom = withGeom.geom as Geometry;\n        return createGeoJsonFeature({\n          ...withGeom,\n          geom\n        });\n      }\n    }\n  }\n\n  const params = getIdentifyGeoJsonParams(identify);\n  if (params) {\n    return getNgwLayerFeature({ connector, ...params[0] });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport WebMap, { StarterKit, Type } from '@nextgis/webmap';\nimport {\n  getNgwResourceExtent,\n  sendIdentifyRequest,\n  pixelsInMeterWidth,\n  updateWmsParams,\n  getLayerAdapterOptions,\n  addNgwLayer,\n  extendWebMapLayerAdapter,\n  setScaleRatio\n} from './utils/utils';\n\nimport {\n  getIdentifyGeoJson,\n  getIdentifyGeoJsonParams\n} from './utils/identifyUtils';\n\nimport {\n  getNgwLayerItems,\n  getNgwLayerItem,\n  getNgwLayerFeatures,\n  getNgwLayerFeature,\n  createGeoJsonFeature\n} from './utils/featureLayerUtils';\n\nimport { NgwKitOptions, WebMapAdapterOptions } from './interfaces';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\n\nexport class NgwKit implements StarterKit {\n  static utils = {\n    addNgwLayer,\n    getNgwResourceExtent,\n    sendIdentifyRequest,\n    pixelsInMeterWidth,\n    getNgwLayerFeature,\n    getNgwLayerFeatures,\n    getNgwLayerItems,\n    getNgwLayerItem,\n    getIdentifyGeoJson,\n    getIdentifyGeoJsonParams,\n    createGeoJsonFeature,\n    setScaleRatio\n  };\n\n  static updateWmsParams = updateWmsParams;\n\n  static getLayerAdapterOptions = getLayerAdapterOptions;\n\n  static addNgwLayer = addNgwLayer;\n\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl;\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth\n      });\n    }\n  }\n\n  async onLoadSync(webMap: WebMap) {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: WebMapAdapterOptions = {\n            resourceId: r,\n            connector: this.connector,\n            baseUrl: this.url,\n            webMap\n          };\n          const layer = (await webMap.addLayer(WebMapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            identification: this.options.identification,\n            pixelRadius: this.options.pixelRadius,\n            ...options\n          })) as WebMapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap))\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<WebMapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendWebMapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl\n    });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport { NgwKit } from './NgwKit';\n\nexport * from './interfaces';\nexport * from './WebMapLayerAdapter';\nexport * from './WebMapLayerItem';\n\nexport { NgwKit };\nexport default NgwKit;\n"],"sourceRoot":""}