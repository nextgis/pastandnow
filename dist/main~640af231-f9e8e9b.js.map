{"version":3,"sources":["webpack:///./nextgisweb_frontend/packages/qms-kit/src/utility.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/QmsKit.ts","webpack:///./nextgisweb_frontend/packages/qms-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/decorators.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/NgwMap.ts","webpack:///./nextgisweb_frontend/packages/ngw-map/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/featureLayerUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/resourceIdFromLayerOptions.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createGeoJsonAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createRasterAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerItem.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/WebMapLayerAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwResource.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createAsyncAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/createWebMapAdapter.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/utils/identifyUtils.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/NgwKit.ts","webpack:///./nextgisweb_frontend/packages/ngw-kit/src/index.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/utils.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/NgwConnector.ts","webpack:///./nextgisweb_frontend/packages/ngw-connector/src/index.ts"],"names":["alias","tms","loadJSON","url","Promise","resolve","reject","xmlHttp","XMLHttpRequest","onreadystatechange","readyState","status","responseText","JSON","parse","er","open","send","createQmsAdapter","webMap","map","options","this","baseLayer","addLayer","qms","qmsId","type","webMapAdapter","mapAdapter","layerAdapters","maxZoom","minZoom","protocol","location","replace","name","attribution","copyright_text","z_max","z_min","updateQmsOptions","getLayerAdapters","createAdapter","webmap","_createAdapter","utils","onMapLoad","decorators","onLoad","appendNgwResources","resource","defOptions","overwriteOptions","Number","push","resourceId","Array","isArray","id","OPTIONS","target","baseUrl","controls","controlsOptions","ZOOM","position","ATTRIBUTION","customAttribution","pixelRadius","kits","connector","auth","opt","identification","starterKits","runtimeParams","prepareWebMapOptions","emitter","_ngwLayers","_createWebMap","then","container","getContainer","classList","add","_addControls","fit","center","zoom","bounds","setCenter","setZoom","fitBounds","addControl","controlDef","addNgwLayer","keyname","Error","adapter","visibility","adapterOptions","layer","getLayerId","getActiveBaseLayer","console","error","getNgwLayerItem","getNgwLayerItems","getNgwLayerFeature","getNgwLayerFeatures","getIdentifyGeoJson","identify","multiple","getNgwLayers","getNgwLayerByResourceId","mem","n","getIdentificationIds","ids","some","x","getDependLayers","dependLayers","dependFit","find","item","parentId","zoomToLayer","layerDef","String","ngwLayer","getExtent","extent","get","getNgwResourceExtent","event","removeLayer","getLayer","layerId","enableSelection","__selectFromNgwRaster","ev","_selectFromNgwRaster","__selectFromNgwVector","_selectFromNgwVector","on","disableSelection","off","undefined","_isFitFromResource","params","_initMapState","create","qmsLayerName","qmsLayerOptions","addBaseLayer","showLayer","resources","layerFitAllowed","webmapId","forEach","r","_emitStatusEvent","controlAdapterName","controlOptions","control","feature","featureId","identifyFeature","fields","properties","label","parent","geom","geometry","featureCount","features","sourceType","nl","promises","selectable","all","getIds","y","length","getCenter","getZoom","metresPerPixel","Math","abs","cos","PI","pow","radius","sendIdentifyRequest","layers","resp","fixUrlStr","deepmerge","getIcon","FEATURE_REQUEST_PARAMS","srs","geom_format","createGeoJsonFeature","fid","idFilterWorkAround","value","filterById","featureIds","split","getNgwLayerItemsRequest","limit","intersects","paramList","join","filters","createFeatureFieldFilterQueries","_queries","_parentAllParams","logic","filters_","filter","createParam","pf","f","itemsParts","items","reduce","a","b","concat","splice","data","resourceIdFromLayerOptions","getResourceByKeyname","resourceItem","createGeoJsonAdapter","GEOJSON","_fullDataLoad","geoJsonAdapterCb","_lastFilterArgs","_dataPromise","abort","cancel","geoJsonOptions","updateGeoJsonAdapterOptions","_opt","propertiesFilter","addLayerOptions","Object","keys","beforeRemove","updateLayer","setData","e","clearLayer","removeFilter","createRasterAdapter","IMAGE","adapterClass","_options","getLayerAdapterOptions","layerAdapterOptions","tileAdapterOptions","addOptions","WebMapLayerItem","_rootDescendantsCount","tree","setParent","item_type","_sumUp","children","root","getRoot","initProperties","_init","initItem","newLayer","_layer","i","reverse","addChild","layer_adapter","toUpperCase","layer_max_scale_denom","_mapScaleToZoomLevel","layer_min_scale_denom","minScale","maxScale","headers","order","subOrder","drawOrderEnabled","draw_order_position","layer_enabled","property","set","transparency","layer_transparency","opacity","setLayerOpacity","bringToFront","log","scale","setScaleRatio","emit","totalValue","child","getProperty","onSet","hideLayer","_getWebMapLayerItem","_getWebMapIds","_webmapLayersIds","$$onMapClick","_onMapClick","response","getWebMapExtent","getDescendants","visibleLayers","sort","visible","isBlocked","getWebMapConfig","root_item","getAuthorizationHeaders","draw_order_enabled","_updateItemsParams","display_name","layer_style_id","updateWmsParams","webMapItem","promise","_sendIdentifyRequest","_extent","styles","createAdapterFromFirstStyle","childrenStyles","firstStyle","createAsyncAdapter","adapterType","createWebMapAdapter","indexOf","cls","parentOptions","basemap_layer","prototype","resourceAdapter","derivedCtor","baseCtor","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","defineProperty","bbox","size","width","height","timestamp","Date","now","isImageAllowed","simplification","bottom","left","top","right","getNgwLayerExtent","maxLat","maxLon","minLat","minLon","res","_pixelsInMeter","d2r","r2d","lng","lat","points","rlat","rlng","extp","theta","ex","ey","sin","getCirclePoly","latLng","polygon","tan","post","pixelsInMeterWidth","div","document","createElement","style","cssText","body","appendChild","px","offsetWidth","removeChild","centerLat","LN2","getZoomFromScale","getMapWidthForLanInMeters","round","getIdentifyGeoJsonParams","paramsList","l","isNaN","sortingArr","fry","layerFeatures","withGeom","onLoadSync","resourceIds","_getLayerAdapter","templateRe","template","str","s","key","routeStr","_loadingQueue","_loadingStatus","_keynames","route","setNextGisWeb","logout","connect","login","password","getUserInfo","makeQuery","credentials","_rejectLoadingQueue","user","catch","client","makeClientId","Authorization","window","btoa","unescape","encodeURIComponent","getResourceChildren","request","apiItems","apiItem","shift","replaceParams","arg","p","method","nocache","patch","put","delete","_getJson","_executeLoadingQueue","_setLoadingQueue","waiting","q","isError","queue","wait","onCancel","responseType","callback","xhr","processingResponce","forError","cb","message","statusText","onerror","upload","onprogress","lengthComputable","percentComplete","loaded","total","onProgress","h","header","setRequestHeader","withCredentials","file","FormData","append","d","stringify"],"mappings":"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","file":"main~640af231-f9e8e9b.js","sourcesContent":["import {\n  WebMap,\n  BaseLayerAdapter,\n  LayerAdaptersOptions,\n  Type,\n  AdapterOptions\n} from '@nextgis/webmap';\nimport { fixUrlStr } from '@nextgis/utils';\nimport {\n  QmsAdapterOptions,\n  QmsBasemap,\n  QmsLayerType,\n  QmsAdapter as QA\n} from './interfaces';\n\nconst alias: { [key in QmsLayerType]: keyof LayerAdaptersOptions } = {\n  tms: 'TILE'\n};\n\nexport function updateQmsOptions(\n  qms: QmsBasemap\n): AdapterOptions & { url: string } {\n  const protocol = (location.protocol === 'https:' ? 'https' : 'http') + '://';\n  const serviceUrl = qms.url.replace(/^(https?|ftp):\\/\\//, protocol);\n  return {\n    url: serviceUrl,\n    name: qms.name,\n    attribution: qms.copyright_text,\n    maxZoom: qms.z_max,\n    minZoom: qms.z_min\n  };\n}\n\nexport function loadJSON<T = any>(url: string): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.onreadystatechange = () => {\n      if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {\n        if (xmlHttp.responseText) {\n          try {\n            resolve(JSON.parse(xmlHttp.responseText));\n          } catch (er) {\n            reject(er);\n          }\n        }\n      }\n    };\n    xmlHttp.open('GET', fixUrlStr(url), true); // true for asynchronous\n    xmlHttp.send();\n  });\n}\n\nexport function createQmsAdapter(\n  webMap: WebMap,\n  url = 'https://qms.nextgis.com'\n): Type<BaseLayerAdapter> {\n  class QmsAdapter<M = any> implements BaseLayerAdapter<M>, QA {\n    qms?: QmsBasemap;\n\n    options: QmsAdapterOptions;\n    map: M;\n\n    constructor(map: M, options: QmsAdapterOptions) {\n      this.map = map;\n      this.options = options;\n      this.options.baseLayer = true;\n    }\n\n    async addLayer(options: QmsAdapterOptions): Promise<any> {\n      // qmsId for request, id for store\n      if (!this.qms && options.qmsId) {\n        this.qms = await loadJSON<QmsBasemap>(\n          url + '/api/v1/geoservices/' + options.qmsId\n        );\n      }\n      const qms = this.qms;\n      if (qms) {\n        const type = alias[qms.type || 'tms'];\n        const webMapAdapter = webMap.mapAdapter.layerAdapters[type];\n        if (webMapAdapter) {\n          if (type === 'TILE') {\n            options = {\n              maxZoom: webMap.options.maxZoom,\n              minZoom: webMap.options.minZoom,\n              ...this.options,\n              ...updateQmsOptions(qms)\n            };\n            this.options = options;\n            const adapter = new webMapAdapter(this.map, options);\n            return adapter.addLayer(options);\n          }\n        }\n      }\n    }\n  }\n  return QmsAdapter;\n}\n","/**\n * @module qms-kit\n */\n\nimport WebMap, { StarterKit, Type, BaseLayerAdapter } from '@nextgis/webmap';\nimport { QmsOptions } from './interfaces';\nimport { createQmsAdapter } from './utility';\n\nexport class QmsKit implements StarterKit {\n  static utils = {\n    createQmsAdapter\n  };\n\n  options: QmsOptions = {\n    url: 'https://qms.nextgis.com'\n  };\n\n  url: string;\n\n  constructor(options?: QmsOptions) {\n    this.options = { ...this.options, ...options };\n    this.url = this.options.url;\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([\n      {\n        name: 'QMS',\n        createAdapter: (webmap: WebMap) =>\n          Promise.resolve(this._createAdapter(webmap))\n      }\n    ]);\n  }\n\n  private _createAdapter(webMap: WebMap): Type<BaseLayerAdapter> {\n    return createQmsAdapter(webMap, this.url);\n  }\n}\n","/**\n * @module qms-kit\n */\n\nimport { QmsKit } from './QmsKit';\n\nexport * from './interfaces';\n\nexport { QmsKit };\nexport default QmsKit;\n","import WebMap from '@nextgis/webmap';\nimport { NgwMapEvents } from './interfaces';\n\n/**\n * Decorator to run action only after map is created\n */\nexport function onMapLoad() {\n  return WebMap.decorators.onLoad<NgwMapEvents>('build-map');\n}\n","import { NgwResourceDefinition, NgwLayerOptions } from './interfaces';\nimport { NgwLayerOptionsAdditional } from '@nextgis/ngw-kit';\n\nimport { deepmerge } from '@nextgis/utils';\nimport { MapAdapter, StarterKit } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport QmsKit from '@nextgis/qms-kit';\nimport NgwKit from '@nextgis/ngw-kit';\n\nimport { NgwMapOptions } from './interfaces';\n\nexport function appendNgwResources(\n  options: NgwLayerOptions[],\n  resource?: NgwResourceDefinition,\n  defOptions?: NgwLayerOptionsAdditional,\n  overwriteOptions?: NgwLayerOptionsAdditional\n) {\n  if (typeof resource === 'number' || typeof resource === 'string') {\n    resource = Number(resource);\n    options.push({\n      ...defOptions,\n      resourceId: resource\n    });\n  } else if (Array.isArray(resource)) {\n    const [resourceId, id] = resource;\n    options.push({ ...defOptions, resourceId, id, ...overwriteOptions });\n  } else if (typeof resource === 'object') {\n    options.push({ ...defOptions, ...resource, ...overwriteOptions });\n  }\n}\n\nexport const OPTIONS: NgwMapOptions = {\n  target: 'map',\n  baseUrl: '',\n  controls: ['ZOOM', 'ATTRIBUTION'],\n  controlsOptions: {\n    ZOOM: { position: 'top-left' },\n    ATTRIBUTION: {\n      position: 'bottom-right',\n      customAttribution: [\n        '<a href=\"http://nextgis.ru\" target=\"_blank\">Â©NextGIS</a>'\n      ]\n    }\n  },\n  pixelRadius: 10\n};\n\nexport function prepareWebMapOptions(\n  mapAdapter: MapAdapter,\n  options: NgwMapOptions\n) {\n  const kits: StarterKit[] = [new QmsKit()];\n\n  if (!options.connector && options.baseUrl) {\n    options.connector = new NgwConnector({\n      baseUrl: options.baseUrl,\n      auth: options.auth\n    });\n  } else if (options.connector) {\n    options.baseUrl = options.connector.options.baseUrl;\n  }\n  const opt: NgwMapOptions = deepmerge(OPTIONS, options);\n  if (opt.connector) {\n    kits.push(\n      new NgwKit({\n        connector: opt.connector,\n        auth: opt.auth,\n        identification: opt.identification\n      })\n    );\n  }\n  return {\n    mapAdapter,\n    starterKits: kits,\n    runtimeParams: options.runtimeParams\n  };\n}\n","/**\n * @module ngw-map\n */\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport { fixUrlStr, deepmerge, CancelablePromise } from '@nextgis/utils';\nimport WebMap, {\n  MapAdapter,\n  ControlPositions,\n  MapControls,\n  WebMapEvents,\n  LayerDef,\n  MapClickEvent,\n  LayerAdapter,\n  PropertiesFilter,\n  FilterOptions,\n  OnLayerClickOptions\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  ResourceItem,\n  FeatureLayersIdentify,\n  FeatureItem,\n  FeatureLayersIdentifyItems,\n  LayerFeature\n} from '@nextgis/ngw-connector';\nimport { QmsAdapterOptions } from '@nextgis/qms-kit';\nimport NgwKit, {\n  NgwLayerOptions,\n  ResourceAdapter,\n  WebMapLayerItem,\n  NgwLayerOptionsAdditional,\n  NgwIdentify,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions\n} from '@nextgis/ngw-kit';\nimport { getIcon } from '@nextgis/icons';\n\nimport { onMapLoad } from './decorators';\nimport { appendNgwResources, prepareWebMapOptions, OPTIONS } from './utils';\n\nimport {\n  NgwMapOptions,\n  ControlOptions,\n  NgwMapEvents,\n  NgwLayers\n} from './interfaces';\nimport { Geometry, Feature, FeatureCollection } from 'geojson';\n\n/**\n * Base class containing the logic of interaction WebMap with NextGIS services.\n *\n * @example\n * ```javascript\n * import NgwMap from '@nextgis/ngw-map';\n * import MapAdapter from '@nextgis/leaflet-map-adapter';\n * // styles are not included in the leaflet-map-adapter\n * import 'leaflet/dist/leaflet.css';\n *\n * const ngwMap = new NgwMap(new MapAdapter(), {\n *   target: 'map',\n *   qmsId: 487,\n *   baseUrl: 'https://demo.nextgis.com',\n *   webmapId: 3985\n * });\n * ```\n */\nexport class NgwMap<M = any, L = any, C = any, O = {}> extends WebMap<\n  M,\n  L,\n  C,\n  NgwMapEvents\n> {\n  static utils = {\n    ...WebMap.utils,\n    ...NgwKit.utils,\n    fixUrlStr,\n    deepmerge\n  };\n  static decorators = { onMapLoad, ...WebMap.decorators };\n  static getIcon = getIcon;\n\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    NgwMapEvents\n  > = new EventEmitter();\n\n  options: NgwMapOptions<C> & O = {} as NgwMapOptions<C> & O;\n  connector!: NgwConnector;\n\n  protected _ngwLayers: NgwLayers = {};\n  private __selectFromNgwRaster?: (ev: MapClickEvent) => void;\n  private __selectFromNgwVector?: (ev: OnLayerClickOptions) => void;\n\n  /**\n   * @param mapAdapter #noapi\n   * @param options\n   */\n  constructor(mapAdapter: MapAdapter, options: NgwMapOptions<C> & O) {\n    super(prepareWebMapOptions(mapAdapter, options));\n    if (options.connector) {\n      this.connector = options.connector;\n    }\n    this.options = deepmerge(OPTIONS, options);\n    this._createWebMap().then(() => {\n      const container = this.getContainer();\n      if (container) {\n        container.classList.add('ngw-map-container');\n      }\n      this._addControls();\n    });\n  }\n\n  /**\n   * Pans and zooms the map to the initial position specified in the options\n   */\n  fit() {\n    const { center, zoom, bounds } = this.options;\n    if (center) {\n      this.setCenter(center);\n      if (zoom) {\n        this.setZoom(zoom);\n      }\n    } else if (bounds) {\n      this.fitBounds(bounds);\n    }\n  }\n\n  /**\n   * Organized addition to the map design and controls elements,\n   * calling `control.onAdd(this.webMap.mapAdapter)`\n   * @param control - object with onAdd and onRemove methods\n   *                or a string value indicating the name of the control installed in the map adapter\n   * @param position - position relative to the map angles\n   * @param [options] - initialization parameters if the control is set as a string value\n   *\n   * @example\n   * ```javascript\n   * ngwMap.addControl(new CustomControl(), 'bottom-left');\n   * ngwMap.addControl('ZOOM', 'top-right')\n   * ```\n   */\n  @WebMap.decorators.onLoad<NgwMapEvents>('controls:create')\n  async addControl<K extends keyof MapControls>(\n    controlDef: K | C,\n    position: ControlPositions,\n    options?: MapControls[K]\n  ) {\n    return super.addControl(controlDef, position, options);\n  }\n\n  /**\n   * Add any (style, vector, webmap) NGW layer by resource id.\n   * @param options - set layer identification parameters and render method.\n   * @param [adapterOptions] - parameters for the selected adapter\n   *\n   * @example\n   * ```javascript\n   * var ngwMap = new NgwMap({ baseUrl: 'https://demo.nextgis.com', target: 'map' });\n   * // add raster layer resourceId is the style of 4004 layer\n   * ngwMap.addNgwLayer({ resourceId: 4005 });\n   * // add vector data from layer GEOJSON source\n   * ngwMap.addNgwLayer({\n   *   resourceId: 4038,\n   *   adapter: 'GEOJSON',\n   *   adapterOptions: { paint: { color: 'red' } }\n   * });\n   * ```\n   */\n  @onMapLoad()\n  async addNgwLayer(\n    options: NgwLayerOptions\n  ): Promise<ResourceAdapter | undefined> {\n    const keyname = (options as KeynamedNgwLayerOptions).keyname;\n    const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n    if (!keyname && !resourceId) {\n      throw new Error(\n        'resourceId or keyname is required parameter to add NGW layer'\n      );\n    }\n    if (this.options.baseUrl || this.options.baseUrl === '') {\n      try {\n        const adapter = NgwKit.utils.addNgwLayer(\n          options,\n          this,\n          this.options.baseUrl,\n          this.connector\n        );\n\n        const layer = (await this.addLayer(adapter, {\n          visibility: true,\n          // TODO: all options into one object\n          ...options,\n          ...options.adapterOptions\n        })) as ResourceAdapter;\n        const id = layer && this.getLayerId(layer);\n        if (layer && id) {\n          this._ngwLayers[id] = { layer, resourceId: layer.resourceId };\n\n          if (layer.options.baseLayer) {\n            const visibleLayerBaseLayer = this.getActiveBaseLayer();\n            if (visibleLayerBaseLayer) {\n              return layer;\n            }\n          }\n        }\n\n        return layer;\n      } catch (er) {\n        console.error(\"can't add ngw layer\", er);\n      }\n    }\n  }\n\n  async getNgwLayerItem(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<FeatureItem> {\n    return NgwKit.utils.getNgwLayerItem({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerItems(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureItem[]> {\n    return NgwKit.utils.getNgwLayerItems({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeature<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(options: {\n    resourceId: number;\n    featureId: number;\n  }): CancelablePromise<Feature<G, P>> {\n    return NgwKit.utils.getNgwLayerFeature<G, P>({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getNgwLayerFeatures<\n    G extends Geometry | null = Geometry,\n    P extends Record<string, any> = Record<string, any>\n  >(\n    options: {\n      resourceId: number;\n      connector?: NgwConnector;\n      filters?: PropertiesFilter;\n    } & FilterOptions\n  ): CancelablePromise<FeatureCollection<G, P>> {\n    return NgwKit.utils.getNgwLayerFeatures({\n      connector: this.connector,\n      ...options\n    });\n  }\n\n  async getIdentifyGeoJson(\n    identify: NgwIdentify,\n    multiple = false\n  ): CancelablePromise<Feature | undefined> {\n    return NgwKit.utils.getIdentifyGeoJson({\n      identify,\n      connector: this.connector,\n      multiple\n    });\n  }\n\n  async getNgwLayers(): Promise<NgwLayers> {\n    await this.onLoad();\n    return this._ngwLayers;\n  }\n\n  async getNgwLayerByResourceId(id: number): Promise<LayerAdapter | undefined> {\n    for (const n in this._ngwLayers) {\n      const mem = this._ngwLayers[n];\n      if (mem.resourceId === id) {\n        return mem && mem.layer;\n      } else if (mem.layer.getIdentificationIds) {\n        const ids = await mem.layer.getIdentificationIds();\n        if (ids && ids.some(x => x === id)) {\n          return mem.layer;\n        }\n      }\n      if (mem.layer.getDependLayers) {\n        const dependLayers = mem.layer.getDependLayers() as WebMapLayerItem[];\n        const dependFit = dependLayers.find(x => {\n          return x.item && x.item.parentId === id;\n        });\n        if (dependFit) {\n          return dependFit.layer;\n        }\n      }\n    }\n  }\n\n  /**\n   * Move map to layer. If the layer is NGW resource, extent will be received from the server\n   * @param layerDef\n   *\n   * @example\n   * ```javascript\n   * const ngwLayer = ngwMap.addNgwLayer({ id: 'ngw_layer_name', resourceId: 4005 });\n   * ngwMap.zoomToLayer(ngwLayer);\n   * ngwMap.zoomToLayer('ngw_layer_name');\n   * ```\n   */\n  async zoomToLayer(layerDef: string | ResourceAdapter) {\n    let id: string | undefined;\n    if (typeof layerDef === 'string' || typeof layerDef === 'number') {\n      id = String(id);\n    } else {\n      id = layerDef.id;\n    }\n    const ngwLayer = id && this._ngwLayers[id];\n    if (ngwLayer) {\n      if (ngwLayer.layer.getExtent) {\n        const extent = await ngwLayer.layer.getExtent();\n        if (extent) {\n          this.fitBounds(extent);\n        }\n      } else {\n        let item: ResourceItem;\n        if (ngwLayer.layer.item) {\n          item = ngwLayer.layer.item;\n        } else {\n          const resourceId = ngwLayer.resourceId;\n          item = await this.connector.get('resource.item', null, {\n            id: resourceId\n          });\n        }\n\n        NgwKit.utils.getNgwResourceExtent(item, this.connector).then(extent => {\n          if (extent) {\n            this.fitBounds(extent);\n          }\n        });\n      }\n    }\n  }\n\n  onLoad(event: keyof NgwMapEvents = 'ngw-map:create'): Promise<this> {\n    return super.onLoad(event as keyof WebMapEvents);\n  }\n\n  removeLayer(layerDef: LayerDef) {\n    const layer = this.getLayer(layerDef);\n    if (layer) {\n      const layerId = this.getLayerId(layer);\n      if (layerId) {\n        delete this._ngwLayers[layerId];\n      }\n      super.removeLayer(layer);\n    }\n  }\n\n  enableSelection() {\n    if (!this.__selectFromNgwRaster) {\n      this.__selectFromNgwRaster = (ev: MapClickEvent) =>\n        this._selectFromNgwRaster(ev);\n      this.__selectFromNgwVector = (ev: OnLayerClickOptions) =>\n        this._selectFromNgwVector(ev);\n      this.emitter.on('click', this.__selectFromNgwRaster);\n      this.emitter.on('layer:click', this.__selectFromNgwVector);\n    }\n  }\n\n  disableSelection() {\n    if (this.__selectFromNgwRaster) {\n      this.emitter.off('click', this.__selectFromNgwRaster);\n      this.emitter.off('click', this._selectFromNgwVector);\n      this.__selectFromNgwRaster = undefined;\n      this.__selectFromNgwVector = undefined;\n    }\n  }\n\n  private _isFitFromResource() {\n    const params = this._initMapState;\n    if (params.zoom && params.center) {\n      return false;\n    }\n    return true;\n  }\n\n  private async _createWebMap() {\n    await this.create({ ...this.options });\n    if (this.options.qmsId) {\n      let qmsId: number;\n      let qmsLayerName: string | undefined;\n      if (Array.isArray(this.options.qmsId)) {\n        qmsId = this.options.qmsId[0];\n        qmsLayerName = this.options.qmsId[1];\n      } else {\n        qmsId = Number(this.options.qmsId);\n      }\n      const qmsLayerOptions: QmsAdapterOptions = {\n        qmsId\n      };\n      if (qmsLayerName) {\n        qmsLayerOptions.id = qmsLayerName;\n      }\n\n      await this.addBaseLayer('QMS', qmsLayerOptions).then(layer => {\n        this.showLayer(layer);\n      });\n    }\n\n    const resources: NgwLayerOptions[] = [];\n    const layerFitAllowed = this._isFitFromResource();\n    if (this.options.webmapId) {\n      appendNgwResources(resources, this.options.webmapId, {\n        fit: layerFitAllowed\n      });\n    }\n    if (this.options.resources && Array.isArray(this.options.resources)) {\n      this.options.resources.forEach(x => {\n        const overwriteOptions = {} as NgwLayerOptionsAdditional;\n        if (!layerFitAllowed) {\n          overwriteOptions.fit = false;\n        }\n        appendNgwResources(resources, x, {}, overwriteOptions);\n      });\n    }\n\n    for (const r of resources) {\n      await this.addNgwLayer(r);\n    }\n\n    this._emitStatusEvent('ngw-map:create', this);\n\n    this.enableSelection();\n  }\n\n  private _addControls() {\n    if (this.options.controls) {\n      this.options.controls.forEach(x => {\n        let controlAdapterName = x;\n        let controlOptions: ControlOptions = {};\n        if (typeof x === 'string' && this.options.controlsOptions) {\n          if (this.options.controlsOptions[x]) {\n            controlOptions = this.options.controlsOptions[x];\n            if (controlOptions.control !== undefined) {\n              controlAdapterName = controlOptions.control;\n            }\n          }\n        }\n        const { position, ...options } = controlOptions;\n        this.addControl(controlAdapterName, position || 'top-left', options);\n      });\n    }\n    this._emitStatusEvent('controls:create');\n  }\n\n  private async _selectFromNgwVector(\n    ev: OnLayerClickOptions\n  ): Promise<FeatureLayersIdentify | undefined> {\n    const layer: ResourceAdapter = ev.layer as ResourceAdapter;\n    // item property means layer is NgwResource\n    const id = layer.item && layer.item.resource.id;\n    const feature = ev.feature;\n\n    if (id !== undefined && feature) {\n      const featureId = feature.id;\n      if (featureId) {\n        const identifyFeature: LayerFeature = {\n          id: Number(featureId),\n          fields: feature.properties,\n          label: `#${id}`,\n          layerId: Number(id),\n          parent: '',\n          geom: feature.geometry\n        };\n        const items: FeatureLayersIdentifyItems = {\n          featureCount: 1,\n          features: [identifyFeature]\n        };\n        const identify: FeatureLayersIdentify = {\n          featureCount: 1,\n          [id]: items\n        };\n        this._emitStatusEvent('ngw:select', {\n          ...identify,\n          resources: [id],\n          sourceType: 'vector'\n        });\n        return identify;\n      }\n    }\n  }\n\n  private async _selectFromNgwRaster(ev: MapClickEvent) {\n    this._emitStatusEvent('ngw:preselect');\n\n    const promises: Promise<number[] | undefined>[] = [];\n    for (const nl in this._ngwLayers) {\n      const layer = this._ngwLayers[nl].layer;\n      if (layer.getIdentificationIds && layer.options.selectable) {\n        promises.push(layer.getIdentificationIds());\n      }\n    }\n    const getIds = await Promise.all(promises);\n    const ids: number[] = [];\n    getIds.forEach(x => {\n      if (x) {\n        x.forEach(y => ids.push(y));\n      }\n    });\n\n    if (!ids.length) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n\n    const pixelRadius = this.options.pixelRadius || 10;\n    const center = this.getCenter();\n    const zoom = this.getZoom();\n    if (!center || !zoom) {\n      this._emitStatusEvent('ngw:select', null);\n      return;\n    }\n    const metresPerPixel =\n      (40075016.686 * Math.abs(Math.cos((center[1] * 180) / Math.PI))) /\n      Math.pow(2, zoom + 8);\n    // FIXME: understand the circle creation function\n    const radius = pixelRadius * metresPerPixel * 0.0005;\n    return NgwKit.utils\n      .sendIdentifyRequest(ev, {\n        layers: ids,\n        connector: this.connector,\n        radius\n      })\n      .then(resp => {\n        this._emitStatusEvent('ngw:select', {\n          ...resp,\n          resources: ids,\n          sourceType: 'raster',\n          event: ev\n        });\n        return resp;\n      });\n  }\n}\n","/**\n * @module ngw-map\n */\n\nimport { NgwMap } from './NgwMap';\n\nexport * from '@nextgis/webmap';\nexport * from './interfaces';\n\nexport { NgwMap };\nexport default NgwMap;\n","import { Geometry, Feature, FeatureCollection } from 'geojson';\nimport {\n  PropertiesFilter,\n  FilterOptions,\n  PropertyFilter\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  FeatureItem,\n  RequestItemAdditionalParams\n} from '@nextgis/ngw-connector';\nimport {\n  propertiesFilter,\n  checkIfPropertyFilter,\n  CancelablePromise\n} from '@nextgis/utils';\n\nexport interface FeatureRequestParams {\n  srs?: number;\n  fields?: string;\n  geom_format?: string;\n  limit?: number;\n  intersects?: string;\n}\n\nexport interface GetNgwLayerItemsOptions {\n  resourceId: number;\n  connector: NgwConnector;\n  filters?: PropertiesFilter;\n}\n\nconst FEATURE_REQUEST_PARAMS: FeatureRequestParams = {\n  srs: 4326,\n  geom_format: 'geojson'\n};\n\nexport function createGeoJsonFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(item: Pick<FeatureItem, 'id' | 'geom' | 'fields'>): Feature<G, P> {\n  const geometry = item.geom as G;\n  const feature: Feature<G, P> = {\n    id: item.id,\n    type: 'Feature',\n    properties: item.fields as P,\n    geometry\n  };\n  return feature;\n}\n\nexport function getNgwLayerItem<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<FeatureItem> {\n  const params: FeatureRequestParams & { [name: string]: any } = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  return options.connector.get('feature_layer.feature.item', null, {\n    id: options.resourceId,\n    fid: options.featureId,\n    ...params\n  });\n}\n\nexport function getNgwLayerFeature<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    featureId: number;\n    connector: NgwConnector;\n  } & FilterOptions\n): CancelablePromise<Feature<G, P>> {\n  return getNgwLayerItem(options).then(item => {\n    return createGeoJsonFeature<G, P>(item);\n  });\n}\n\nfunction idFilterWorkAround<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(options: { filterById: any; resourceId: number; connector: NgwConnector }) {\n  const value = options.filterById[2];\n  const featureIds: number[] =\n    typeof value === 'number'\n      ? [value]\n      : value.split(',').map((x: string) => Number(x));\n  if (options.filterById[1] !== 'eq' && options.filterById[1] !== 'in') {\n    throw new Error(\n      'Unable to filter by object id. Except `eq` or `in` operator'\n    );\n  }\n  const promises: Promise<FeatureItem>[] = featureIds.map(featureId => {\n    return getNgwLayerItem<G, P>({\n      connector: options.connector,\n      resourceId: options.resourceId,\n      featureId\n    });\n  });\n  return CancelablePromise.all(promises);\n}\n\n// NGW REST API is not able to filtering by combined queries\n// therefore the filter is divided into several requests\nfunction createFeatureFieldFilterQueries(\n  opt: Required<GetNgwLayerItemsOptions> & FilterOptions,\n  _queries: CancelablePromise<FeatureItem[]>[] = [],\n  _parentAllParams: [string, any][] = []\n): CancelablePromise<FeatureItem[]> {\n  const { filters, connector, resourceId } = opt;\n\n  const logic = typeof filters[0] === 'string' ? filters[0] : 'all';\n\n  const filters_ = filters.filter(x => Array.isArray(x)) as PropertyFilter[];\n\n  const createParam = (pf: PropertyFilter): [string, any] => {\n    const [field, operation, value] = pf;\n    return [`fld_${field}__${operation}`, value];\n  };\n\n  if (logic === 'any') {\n    filters_.forEach(f => {\n      if (f[0] === 'id') {\n        _queries.push(\n          idFilterWorkAround({ filterById: f, connector, resourceId })\n        );\n      }\n      if (checkIfPropertyFilter(f)) {\n        _queries.push(\n          getNgwLayerItemsRequest({\n            ...opt,\n            paramList: [..._parentAllParams, createParam(f)]\n          })\n        );\n      } else {\n        createFeatureFieldFilterQueries(\n          {\n            ...opt,\n            filters: f\n          },\n          _queries,\n          [..._parentAllParams]\n        );\n      }\n    });\n  } else if (logic === 'all') {\n    const filterById = filters_.find(x => x[0] === 'id');\n    if (filterById) {\n      _queries.push(idFilterWorkAround({ filterById, connector, resourceId }));\n    } else {\n      const filters: [string, any][] = [];\n      const propertiesFilterList: PropertiesFilter[] = [];\n      filters_.forEach(f => {\n        if (checkIfPropertyFilter(f)) {\n          filters.push(createParam(f));\n        } else {\n          propertiesFilterList.push(f);\n        }\n      });\n\n      if (propertiesFilterList.length) {\n        propertiesFilterList.forEach(x => {\n          createFeatureFieldFilterQueries(\n            {\n              ...opt,\n              filters: x\n            },\n            _queries,\n            [..._parentAllParams, ...filters]\n          );\n        });\n      } else {\n        _queries.push(\n          getNgwLayerItemsRequest({\n            ...opt,\n            paramList: [..._parentAllParams, ...filters]\n          })\n        );\n      }\n    }\n  }\n\n  return CancelablePromise.all(_queries).then((itemsParts: FeatureItem[][]) => {\n    const items = itemsParts.reduce((a, b) => a.concat(b), []);\n    if (opt.limit) {\n      return items.splice(0, opt.limit);\n    }\n    return items;\n  });\n}\n\nfunction getNgwLayerItemsRequest<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: GetNgwLayerItemsOptions &\n    FilterOptions & { paramList?: [string, any][] }\n): CancelablePromise<FeatureItem[]> {\n  const params: FeatureRequestParams & RequestItemAdditionalParams = {\n    ...FEATURE_REQUEST_PARAMS\n  };\n  const {\n    connector,\n    limit,\n    fields,\n    intersects,\n    resourceId,\n    paramList\n  } = options;\n  if (limit) {\n    params.limit = limit;\n  }\n  if (fields) {\n    params.fields = fields.join();\n  }\n  if (intersects) {\n    params.intersects = intersects;\n  }\n  if (paramList) {\n    params.paramList = paramList;\n  }\n  return connector.get('feature_layer.feature.collection', null, {\n    id: resourceId,\n    ...params\n  });\n}\n\nexport function getNgwLayerItems<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: GetNgwLayerItemsOptions & FilterOptions\n): CancelablePromise<FeatureItem[]> {\n  const filters = options.filters;\n  if (filters) {\n    return createFeatureFieldFilterQueries({ ...options, filters });\n  } else {\n    return getNgwLayerItemsRequest(options).then(data => {\n      if (filters) {\n        // control\n        return data.filter(y => {\n          const fields = y.fields;\n          if (fields) {\n            propertiesFilter(fields, filters);\n          }\n        });\n      }\n      return data;\n    });\n  }\n}\n\nexport function getNgwLayerFeatures<\n  G extends Geometry | null = Geometry,\n  P extends Record<string, any> = Record<string, any>\n>(\n  options: {\n    resourceId: number;\n    connector: NgwConnector;\n    filters?: PropertiesFilter;\n  } & FilterOptions\n): CancelablePromise<FeatureCollection<G, P>> {\n  return getNgwLayerItems(options).then((x: FeatureItem[]) => {\n    const features: Array<Feature<G, P>> = [];\n    x.forEach(y => {\n      features.push(createGeoJsonFeature(y));\n    });\n\n    const featureCollection: FeatureCollection<G, P> = {\n      type: 'FeatureCollection',\n      features\n    };\n    return featureCollection;\n  });\n}\n","import NgwConnector from '@nextgis/ngw-connector';\nimport {\n  NgwLayerOptions,\n  KeynamedNgwLayerOptions,\n  ResourceIdNgwLayerOptions\n} from '../interfaces';\n\nexport async function resourceIdFromLayerOptions(\n  options: NgwLayerOptions,\n  connector: NgwConnector\n) {\n  const keyname = (options as KeynamedNgwLayerOptions).keyname;\n  let resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n  if (!resourceId && keyname) {\n    const resourceItem = await connector.getResourceByKeyname(keyname);\n    resourceId = resourceItem.resource.id;\n  }\n  return resourceId;\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, {\n  VectorLayerAdapter,\n  Type,\n  GeoJsonAdapterOptions,\n  PropertiesFilter,\n  FilterOptions\n} from '@nextgis/webmap';\nimport { CancelablePromise } from '@nextgis/utils';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { GeoJsonObject } from 'geojson';\nimport { getNgwLayerFeatures } from './utils/featureLayerUtils';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createGeoJsonAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  connector: NgwConnector\n) {\n  const adapter = webMap.mapAdapter.layerAdapters.GEOJSON as Type<\n    VectorLayerAdapter\n  >;\n\n  let _dataPromise: CancelablePromise<any> | undefined;\n  const _fullDataLoad = false;\n  let _lastFilterArgs:\n    | { filters?: PropertiesFilter; options?: FilterOptions }\n    | undefined;\n\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n\n  const geoJsonAdapterCb = async (\n    filters?: PropertiesFilter,\n    opt?: FilterOptions\n  ) => {\n    _lastFilterArgs = { filters, options: opt };\n    _dataPromise = getNgwLayerFeatures({\n      resourceId,\n      filters,\n      connector,\n      ...opt\n    });\n    return await _dataPromise;\n  };\n\n  const abort = () => {\n    if (_dataPromise) {\n      _dataPromise.cancel();\n      _dataPromise = undefined;\n    }\n  };\n\n  const onLoad = (data: GeoJsonObject) => {\n    const geoJsonOptions: GeoJsonAdapterOptions = {\n      data\n    };\n    if (options.id) {\n      geoJsonOptions.id = options.id;\n    }\n    return WebMap.utils.updateGeoJsonAdapterOptions(geoJsonOptions);\n  };\n  return class Adapter extends adapter {\n    async addLayer(_opt: GeoJsonAdapterOptions) {\n      let data = {} as GeoJsonObject;\n      if (!_opt.data) {\n        data = await geoJsonAdapterCb(_opt.propertiesFilter, {\n          limit: _opt.limit\n        });\n      }\n      const opt = onLoad(data);\n      const addLayerOptions = { ..._opt, ...opt };\n      if (\n        addLayerOptions.data &&\n        Object.keys(addLayerOptions.data).length === 0\n      ) {\n        addLayerOptions.data = undefined;\n      }\n      return super.addLayer(addLayerOptions);\n    }\n\n    beforeRemove() {\n      abort();\n    }\n\n    async updateLayer() {\n      const { filters, options } = _lastFilterArgs || {};\n      const data = await geoJsonAdapterCb(filters, options);\n      if (this.setData) {\n        this.setData(data);\n      }\n    }\n\n    async propertiesFilter(filters: PropertiesFilter, opt?: FilterOptions) {\n      abort();\n      if (this.filter && _fullDataLoad) {\n        this.filter(e => {\n          if (e.feature && e.feature.properties) {\n            return WebMap.utils.propertiesFilter(e.feature.properties, filters);\n          }\n          return true;\n        });\n      } else if (this.setData) {\n        if (this.clearLayer) {\n          this.clearLayer();\n        }\n        const data = await geoJsonAdapterCb(filters, opt);\n        this.setData(data);\n      }\n    }\n\n    removeFilter() {\n      _lastFilterArgs = undefined;\n      this.propertiesFilter([]);\n      if (this.filter) {\n        this.filter(function() {\n          return true;\n        });\n      }\n    }\n  };\n}\n","import { NgwLayerOptions, ResourceAdapter } from './interfaces';\nimport WebMap, {\n  BaseLayerAdapter,\n  Type,\n  ImageAdapterOptions,\n  TileAdapterOptions\n} from '@nextgis/webmap';\nimport { getLayerAdapterOptions } from './utils/utils';\nimport NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createRasterAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<BaseLayerAdapter> | undefined> {\n  let adapter = options.adapter || 'IMAGE';\n\n  if (adapter === 'IMAGE') {\n    const layerAdapters = webMap.getLayerAdapters();\n    const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n    if (!isImageAllowed) {\n      adapter = 'TILE';\n    }\n  }\n  if (adapter === 'IMAGE' || adapter === 'TILE' || adapter === 'MVT') {\n    const adapterClass = webMap.mapAdapter.layerAdapters[adapter] as Type<\n      BaseLayerAdapter\n    >;\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    return class Adapter extends adapterClass implements ResourceAdapter {\n      // options = {};\n      item?: ResourceItem;\n      resourceId = resourceId;\n\n      constructor(public map: any, _options: any) {\n        super(map, _options);\n        const opt = getLayerAdapterOptions(options, webMap, baseUrl);\n        if (opt) {\n          if (opt.resourceId) {\n            const layerAdapterOptions: ImageAdapterOptions = {\n              ...opt,\n              resourceId: opt.resourceId\n            };\n            this.options = { ...this.options, ...layerAdapterOptions };\n          } else {\n            const tileAdapterOptions: TileAdapterOptions = opt;\n            this.options = { ...this.options, ...tileAdapterOptions };\n          }\n        }\n      }\n      addLayer(addOptions: any) {\n        return super.addLayer({ ...this.options, ...addOptions });\n      }\n\n      async getIdentificationIds() {\n        const id = this.item && this.item.resource.parent.id;\n        if (id) {\n          return [id];\n        }\n      }\n      // beforeRemove() {\n\n      // }\n    };\n  } else {\n    throw new Error(adapter + ' not supported yet. Only TILE');\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport Item, { ItemOptions } from '@nextgis/item';\n\nimport WebMap, { LayerAdaptersOptions, LayerAdapter } from '@nextgis/webmap';\nimport { TreeGroup, TreeLayer } from './interfaces';\nimport { setScaleRatio } from './utils/utils';\n\nexport class WebMapLayerItem extends Item<ItemOptions> {\n  static options: ItemOptions = {\n    properties: [\n      {\n        type: 'boolean',\n        name: 'visibility',\n        getProperty(item?: WebMapLayerItem) {\n          if (item) {\n            if (item.item.item_type === 'group') {\n              return true;\n            } else if (item.item.item_type === 'layer') {\n              return item.item.layer_enabled;\n            } else if (item.item.item_type === 'root') {\n              return true;\n            }\n          }\n          return false;\n        },\n        onSet(value: boolean, options?: any, item?: WebMapLayerItem) {\n          if (item && item.layer && item.item.item_type === 'layer') {\n            if (value) {\n              item.webMap.showLayer(item.layer);\n            } else {\n              item.webMap.hideLayer(item.layer);\n            }\n            item.item['layer_enabled'] = value;\n          }\n        }\n      }\n    ]\n  };\n\n  item: TreeGroup | TreeLayer;\n  layer?: LayerAdapter;\n\n  _rootDescendantsCount = 0;\n\n  constructor(\n    public webMap: WebMap,\n    item: TreeGroup | TreeLayer,\n    options?: ItemOptions,\n    parent?: WebMapLayerItem\n  ) {\n    super({ ...WebMapLayerItem.options, ...options });\n    if (parent) {\n      this.tree.setParent(parent);\n    }\n    this.item = item;\n    if (this.item.item_type === 'root') {\n      this._rootDescendantsCount = this._sumUp(this.item.children);\n    } else {\n      const root = this.tree.getRoot<this>();\n      if (root) {\n        this._rootDescendantsCount = root._rootDescendantsCount;\n      }\n    }\n\n    this.initProperties();\n    this._init(item);\n  }\n\n  async initItem(item: TreeGroup | TreeLayer) {\n    let newLayer = item._layer;\n    const i = item;\n    if (item.item_type === 'group' || item.item_type === 'root') {\n      if (item.children && item.children.length) {\n        item.children.reverse().forEach(x => {\n          const children = new WebMapLayerItem(\n            this.webMap,\n            x,\n            this.options,\n            this\n          );\n          this.tree.addChild(children);\n        });\n      }\n    } else if (item.item_type === 'layer') {\n      const adapter = (item.adapter ||\n        item.layer_adapter.toUpperCase()) as keyof LayerAdaptersOptions;\n      const maxZoom = item.layer_max_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_max_scale_denom)\n        : this.webMap.options.maxZoom;\n      const minZoom = item.layer_min_scale_denom\n        ? this._mapScaleToZoomLevel(item.layer_min_scale_denom)\n        : this.webMap.options.minZoom;\n      const options: any = {\n        maxZoom,\n        minZoom,\n        minScale: item.layer_min_scale_denom,\n        maxScale: item.layer_max_scale_denom,\n        ...item,\n        headers: this.options.headers\n      };\n      if (this.options.order) {\n        const subOrder = this.options.drawOrderEnabled\n          ? this._rootDescendantsCount - item.draw_order_position\n          : this.id;\n        options.order = Number((this.options.order | 0) + '.' + subOrder);\n      }\n      newLayer = await this.webMap.addLayer(adapter, options);\n    }\n    if (newLayer) {\n      i._layer = newLayer;\n      this.layer = newLayer;\n      if (this.properties && item.item_type === 'layer' && item.layer_enabled) {\n        this.properties.property('visibility').set(true);\n      }\n      const transparency =\n        item.item_type === 'layer' && item.layer_transparency;\n      if (typeof transparency === 'number') {\n        const opacity = (100 - transparency) / 100;\n        this.webMap.setLayerOpacity(newLayer, opacity);\n      }\n    } else {\n      // this.properties.get('visibility').set(true);\n    }\n  }\n\n  bringToFront() {\n    //\n  }\n\n  fit(): void {\n    if (this.item.item_type === 'layer') {\n      console.log(this.item);\n    }\n  }\n\n  private _mapScaleToZoomLevel(scale: number) {\n    return setScaleRatio(scale);\n  }\n\n  private async _init(item: TreeGroup | TreeLayer) {\n    await this.initItem(item);\n    this.emitter.emit('init');\n  }\n\n  private _sumUp(children: Array<TreeGroup | TreeLayer>, totalValue = 0) {\n    for (const child of children) {\n      if (child.item_type === 'layer') {\n        totalValue += 1;\n        child.draw_order_position = child.draw_order_position || totalValue;\n      } else if (child.item_type === 'group') {\n        totalValue = this._sumUp(child.children, totalValue);\n      }\n    }\n    return totalValue;\n  }\n}\n","import WebMap, { LngLatBoundsArray, MapClickEvent } from '@nextgis/webmap';\nimport { ResourceItem } from '@nextgis/ngw-connector';\nimport { fixUrlStr, CancelablePromise } from '@nextgis/utils';\nimport {\n  getLayerAdapterOptions,\n  updateWmsParams,\n  sendIdentifyRequest,\n  getWebMapExtent\n} from './utils/utils';\nimport { WebMapLayerItem } from './WebMapLayerItem';\nimport { ItemOptions } from '@nextgis/item';\n\nimport StrictEventEmitter from 'strict-event-emitter-types';\nimport { EventEmitter } from 'events';\n\nimport {\n  TreeGroup,\n  TreeLayer,\n  NgwLayerAdapterType,\n  WebMapAdapterOptions,\n  WebMapLayerAdapterEvents,\n  ResourceAdapter\n} from './interfaces';\n\nexport class WebMapLayerAdapter implements ResourceAdapter {\n  layer?: WebMapLayerItem;\n\n  /**\n   * Radius for searching objects in pixels\n   */\n  pixelRadius = 10; // webmapSettings.identify_radius,\n  resourceId!: number;\n  readonly emitter: StrictEventEmitter<\n    EventEmitter,\n    WebMapLayerAdapterEvents\n  > = new EventEmitter();\n  private response?: ResourceItem;\n  private _webmapLayersIds?: number[];\n\n  private $$onMapClick?: (ev: MapClickEvent) => void;\n\n  constructor(public map: any, public options: WebMapAdapterOptions) {\n    const r = options.resourceId;\n    if (Array.isArray(r)) {\n      this.resourceId = r[0];\n      this.options.id = r[1];\n    } else {\n      this.resourceId = r;\n    }\n\n    if (!this.resourceId) {\n      throw new Error('NGW `resourceId` is not defined');\n    }\n  }\n\n  async addLayer(options: WebMapAdapterOptions): Promise<any> {\n    this.options = { ...this.options, ...options };\n\n    this.layer = await this._getWebMapLayerItem();\n\n    if (this.options.identification) {\n      const ids = await this._getWebMapIds();\n      if (ids) {\n        this._webmapLayersIds = ids;\n        this.$$onMapClick = (ev: MapClickEvent) => this._onMapClick(ev);\n        this.options.webMap.emitter.on('click', this.$$onMapClick);\n      }\n    }\n    return this.layer;\n  }\n\n  removeLayer() {\n    const mapAdapter = this.options.webMap.mapAdapter;\n    if (this.$$onMapClick) {\n      this.options.webMap.emitter.off('click', this.$$onMapClick);\n    }\n    this.getDependLayers().forEach(x => {\n      if (!('layer' in x)) return;\n      // @ts-ignore Update x interface\n      mapAdapter.removeLayer(x.layer.layer);\n    });\n    this.$$onMapClick = undefined;\n    delete this.options;\n    delete this.layer;\n    delete this.response;\n    delete this._webmapLayersIds;\n  }\n\n  showLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(true);\n    }\n  }\n\n  hideLayer() {\n    if (this.layer && this.layer.properties) {\n      this.layer.properties.property('visibility').set(false);\n    }\n  }\n\n  getExtent(): LngLatBoundsArray | undefined {\n    const webmap = this.response && this.response.webmap;\n    if (webmap) {\n      return getWebMapExtent(webmap);\n    }\n  }\n\n  getDependLayers(): Array<WebMapLayerItem> {\n    return (this.layer && this.layer.tree.getDescendants()) || [];\n  }\n\n  async getIdentificationIds() {\n    const visibleLayers: number[] = [];\n    let ids = this._webmapLayersIds;\n    if (!ids) {\n      ids = await this._getWebMapIds();\n      this._webmapLayersIds = ids;\n    }\n    if (ids && ids.length) {\n      let deps = this.getDependLayers();\n      deps = deps.sort((a, b) => a.id - b.id);\n      deps.forEach(x => {\n        const item = x.item;\n        const parentId = item.parentId;\n        if (parentId !== undefined && item.item_type === 'layer') {\n          const visible = x.properties.property('visibility');\n          const isVisible = visible.get() && !visible.isBlocked();\n          if (isVisible) {\n            visibleLayers.push(parentId);\n          }\n        }\n      });\n    }\n    return visibleLayers;\n  }\n\n  private async _getWebMapLayerItem(): Promise<WebMapLayerItem | undefined> {\n    if (this.resourceId) {\n      const webmap = await this.getWebMapConfig(this.resourceId);\n      if (webmap && webmap.root_item) {\n        return new Promise<WebMapLayerItem>(resolve => {\n          const options: ItemOptions = {};\n          if (this.options.connector && this.options.connector.options.auth) {\n            const headers = this.options.connector.getAuthorizationHeaders();\n            if (headers) {\n              options.headers = headers;\n            }\n          }\n          options.order = this.options.order;\n          options.drawOrderEnabled = webmap.draw_order_enabled;\n          const layer = new WebMapLayerItem(\n            this.options.webMap,\n            webmap.root_item,\n            options\n          );\n          layer.emitter.on('init', () => resolve(layer));\n        });\n      }\n    }\n  }\n\n  private async getWebMapConfig(id: number) {\n    try {\n      const data = await this.options.connector.get('resource.item', null, {\n        id\n      });\n      this.response = data;\n      const webmap = data.webmap;\n      if (webmap) {\n        this._updateItemsParams(webmap.root_item, this.options.webMap, data);\n        return webmap;\n      } else {\n        // TODO: resource is no webmap\n      }\n    } catch (er) {\n      throw er;\n    }\n  }\n\n  private _updateItemsParams(\n    item: TreeGroup | TreeLayer,\n    webMap: WebMap,\n    data: ResourceItem\n  ) {\n    if (item) {\n      if (item.item_type === 'group' || item.item_type === 'root') {\n        if (item.children) {\n          item.children = item.children.map(x =>\n            this._updateItemsParams(x, webMap, data)\n          );\n        }\n        if (item.item_type === 'root') {\n          item.display_name = data.resource.display_name;\n        }\n      } else if (item.item_type === 'layer') {\n        const url = fixUrlStr(\n          this.options.baseUrl + '/api/component/render/image'\n        );\n        const resourceId = item.layer_style_id;\n        item.url = url;\n        item.resourceId = resourceId;\n        item.updateWmsParams = params => updateWmsParams(params, resourceId);\n        item = {\n          ...item,\n          ...getLayerAdapterOptions(\n            {\n              adapter: item.layer_adapter.toUpperCase() as NgwLayerAdapterType,\n              resourceId\n            },\n            webMap,\n            this.options.baseUrl\n          )\n        };\n      }\n    }\n    return item;\n  }\n\n  private async _getWebMapIds(): Promise<number[] | undefined> {\n    const webMapItem = this.layer;\n    if (webMapItem && webMapItem.item.item_type === 'root') {\n      const layers = webMapItem.tree.getDescendants();\n      const promises: Array<CancelablePromise<any>> = [];\n      layers.forEach((x: WebMapLayerItem) => {\n        const item = x.item;\n        if (item.item_type === 'layer') {\n          const id = item.layer_style_id;\n          const promise = this.options.connector\n            .get('resource.item', {}, { id })\n            .then(y => {\n              if (y) {\n                const parentId = Number(y.resource.parent.id);\n                item.parentId = parentId;\n                return parentId;\n              }\n            });\n          promises.push(promise);\n        }\n      });\n      const ids = await Promise.all(promises);\n      return ids.filter(x => x !== undefined);\n      // const id = item['layer_style_id']\n    }\n  }\n\n  private _sendIdentifyRequest(ev: MapClickEvent) {\n    if (this._webmapLayersIds) {\n      return sendIdentifyRequest(ev, {\n        layers: this._webmapLayersIds,\n        connector: this.options.connector,\n        radius: this.pixelRadius\n      }).then(resp => {\n        this.emitter.emit('identify', { ev, data: resp });\n        return resp;\n      });\n    }\n  }\n\n  private _onMapClick(ev: MapClickEvent) {\n    this._sendIdentifyRequest(ev);\n  }\n}\n","import NgwConnector, { ResourceItem } from '@nextgis/ngw-connector';\nimport { getNgwResourceExtent } from './utils/utils';\nimport { LngLatBoundsArray } from '@nextgis/webmap';\n\nexport class NgwResource {\n  item!: ResourceItem;\n  connector!: NgwConnector;\n\n  private _extent?: LngLatBoundsArray;\n\n  async getExtent(): Promise<LngLatBoundsArray | undefined> {\n    if (this._extent) {\n      return this._extent;\n    }\n    if (this.item) {\n      this._extent = await getNgwResourceExtent(\n        this.item,\n        this.connector\n      ).then();\n      return this._extent;\n    }\n  }\n}\n","import NgwConnector, {\n  ResourceCls,\n  ResourceItem\n} from '@nextgis/ngw-connector';\nimport WebMap, { LayerAdapter, Type } from '@nextgis/webmap';\nimport QmsKit from '@nextgis/qms-kit';\nimport { ResourceAdapter, NgwLayerOptions } from './interfaces';\n\nimport { createGeoJsonAdapter } from './createGeoJsonAdapter';\nimport { createRasterAdapter } from './createRasterAdapter';\nimport { createWebMapAdapter } from './createWebMapAdapter';\nimport { applyMixins } from './utils/utils';\nimport { NgwResource } from './NgwResource';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nconst styles: ResourceCls[] = [\n  'mapserver_style',\n  'qgis_vector_style',\n  'qgis_raster_style',\n  'raster_style'\n];\n\nasync function createAdapterFromFirstStyle(\n  parent: number,\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n) {\n  const childrenStyles = await connector.get('resource.collection', null, {\n    parent\n  });\n  const firstStyle = childrenStyles && childrenStyles[0];\n  if (firstStyle) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return createAsyncAdapter(\n      { ...options, resourceId: firstStyle.resource.id },\n      webMap,\n      baseUrl,\n      connector\n    );\n  }\n}\n\nexport async function createAsyncAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  let adapter: Promise<Type<LayerAdapter> | undefined> | undefined;\n  let item: ResourceItem | undefined;\n  try {\n    const adapterType = options.adapter;\n    const resourceId = await resourceIdFromLayerOptions(options, connector);\n    if (resourceId) {\n      item = await connector.get('resource.item', null, { id: resourceId });\n\n      if (item) {\n        const _options: NgwLayerOptions = { ...options, resourceId };\n        if (item.webmap) {\n          adapter = createWebMapAdapter(_options, webMap, baseUrl, connector);\n        } else if (styles.indexOf(item.resource.cls) !== -1) {\n          if (adapterType === 'GEOJSON') {\n            const parentOptions: NgwLayerOptions = {\n              ...options,\n              resourceId: item.resource.parent.id\n            };\n            adapter = createGeoJsonAdapter(parentOptions, webMap, connector);\n          } else {\n            adapter = createRasterAdapter(_options, webMap, baseUrl, connector);\n          }\n        } else if (item.resource.cls === 'vector_layer') {\n          if (adapterType !== undefined && adapterType !== 'GEOJSON') {\n            if (adapterType === 'MVT') {\n              adapter = createRasterAdapter(\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            } else {\n              return createAdapterFromFirstStyle(\n                item.resource.id,\n                _options,\n                webMap,\n                baseUrl,\n                connector\n              );\n            }\n          } else {\n            adapter = createGeoJsonAdapter(_options, webMap, connector);\n          }\n        } else if (item.resource.cls === 'raster_layer') {\n          return createAdapterFromFirstStyle(\n            item.resource.id,\n            _options,\n            webMap,\n            baseUrl,\n            connector\n          );\n        } else if (item.basemap_layer && item.basemap_layer.qms) {\n          adapter = Promise.resolve(QmsKit.utils.createQmsAdapter(webMap));\n          adapter.then(x => {\n            if (x && item && item.basemap_layer && item.basemap_layer.qms) {\n              const qms = JSON.parse(item.basemap_layer.qms);\n              x.prototype.qms = qms;\n              x.prototype.baseLayer = true;\n            }\n          });\n        }\n      } else {\n        throw new Error(\n          \"Can't add NGW layer because Resource item is not found\"\n        );\n      }\n    }\n  } catch (er) {\n    // if (options.adapter === 'GEOJSON') {\n    //   adapter = createGeoJsonAdapter(options, webMap, connector);\n    // } else {\n    //   adapter = createRasterAdapter(options, webMap, baseUrl);\n    // }\n  }\n  if (adapter) {\n    return adapter.then(x => {\n      if (x) {\n        const resourceAdapter = x as Type<ResourceAdapter>;\n        resourceAdapter.prototype.item = item;\n        resourceAdapter.prototype.connector = connector;\n\n        applyMixins(resourceAdapter, [NgwResource]);\n\n        return resourceAdapter;\n      }\n    });\n  }\n}\n","import { NgwLayerOptions } from './interfaces';\nimport WebMap, { Type } from '@nextgis/webmap';\nimport NgwConnector from '@nextgis/ngw-connector';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\nimport { resourceIdFromLayerOptions } from './utils/resourceIdFromLayerOptions';\n\nexport async function createWebMapAdapter(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<WebMapLayerAdapter>> {\n  const resourceId = await resourceIdFromLayerOptions(options, connector);\n  return class Adapter extends WebMapLayerAdapter {\n    constructor(map: any) {\n      super(map, {\n        webMap,\n        resourceId,\n        baseUrl,\n        connector\n      });\n    }\n  };\n}\n","import WebMap, {\n  Type,\n  LngLatBoundsArray,\n  MapClickEvent\n} from '@nextgis/webmap';\nimport NgwConnector, {\n  WebmapResource,\n  ResourceItem,\n  FeatureLayersIdentify\n} from '@nextgis/ngw-connector';\nimport { createAsyncAdapter } from '../createAsyncAdapter';\nimport {\n  NgwLayerOptions,\n  WebMapAdapterOptions,\n  IdentifyRequestOptions,\n  ResourceAdapter,\n  ResourceIdNgwLayerOptions\n} from '../interfaces';\nimport { WebMapLayerAdapter } from '../WebMapLayerAdapter';\n\nexport function updateWmsParams(params: any, resourceId: number) {\n  const { bbox, width, height } = params;\n  return {\n    resource: resourceId,\n    extent: bbox,\n    size: width + ',' + height,\n    timestamp: Date.now()\n  };\n}\n\nexport function getLayerAdapterOptions(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string\n) {\n  let adapter = options.adapter || 'IMAGE';\n  let url: string;\n  const layerAdapters = webMap.getLayerAdapters();\n  const isImageAllowed = layerAdapters ? layerAdapters.IMAGE : true;\n\n  // const keyname = (options as KeynamedNgwLayerOptions).keyname;\n  const resourceId = (options as ResourceIdNgwLayerOptions).resourceId;\n  // if (!resourceId && keyname) {\n  //   const resourceItem = await connector.getResourceByKeyname(keyname);\n  //   resourceId = resourceItem.resource.id;\n  // }\n  if (resourceId) {\n    if (adapter === 'IMAGE') {\n      if (isImageAllowed) {\n        url = baseUrl + '/api/component/render/image';\n        return {\n          url,\n          resourceId,\n          headers: options.headers,\n          updateWmsParams: (params: any) => updateWmsParams(params, resourceId)\n        };\n      } else {\n        adapter = 'TILE';\n      }\n    }\n    if (adapter === 'MVT') {\n      url =\n        baseUrl +\n        '/api/component/feature_layer/mvt?x={x}&y={y}&z={z}&' +\n        'resource=' +\n        resourceId +\n        '&simplification=' +\n        (options.simplification || 0);\n      // url = baseUrl + '/api/resource/' + options.resourceId + '/{z}/{x}/{y}.mvt';\n      return {\n        url\n      };\n    }\n    if (adapter === 'TILE') {\n      url =\n        baseUrl +\n        '/api/component/render/tile?z={z}&x={x}&y={y}&resource=' +\n        resourceId;\n      return { url, adapter };\n    }\n  } else {\n    console.log('Options `resourceId` not set');\n  }\n}\n\nexport function addNgwLayer(\n  options: NgwLayerOptions,\n  webMap: WebMap,\n  baseUrl: string,\n  connector: NgwConnector\n): Promise<Type<ResourceAdapter> | undefined> {\n  const headers = connector.getAuthorizationHeaders();\n  if (headers) {\n    options.headers = headers;\n  }\n\n  return createAsyncAdapter(options, webMap, baseUrl, connector);\n}\n\nexport function getWebMapExtent(\n  webmap: WebmapResource\n): LngLatBoundsArray | undefined {\n  const bottom = webmap['extent_bottom'];\n  const left = webmap['extent_left'];\n  const top = webmap['extent_top'];\n  const right = webmap['extent_right'];\n  if (bottom && left && top && right) {\n    const extent: LngLatBoundsArray = [left, bottom, right, top];\n    if (extent[3] > 82) {\n      extent[3] = 82;\n    }\n    if (extent[1] < -82) {\n      extent[1] = -82;\n    }\n    return extent;\n  }\n}\n\nexport function getNgwLayerExtent(\n  id: number,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  return connector.get('layer.extent', name, { id }).then(resp => {\n    if (resp) {\n      const { maxLat, maxLon, minLat, minLon } = resp.extent;\n      const extenrArray: LngLatBoundsArray = [minLon, minLat, maxLon, maxLat];\n      return extenrArray;\n    }\n  });\n}\n\nexport async function getNgwResourceExtent(\n  item: ResourceItem,\n  connector: NgwConnector\n): Promise<LngLatBoundsArray | undefined> {\n  if (item.webmap) {\n    return getWebMapExtent(item.webmap);\n  } else {\n    const resource = item.resource;\n    if (resource.cls.indexOf('style') !== -1) {\n      return connector\n        .get('resource.item', null, {\n          id: resource.parent.id\n        })\n        .then(res => {\n          return getNgwLayerExtent(res.resource.id, connector);\n        });\n    } else {\n      return getNgwLayerExtent(resource.id, connector);\n    }\n  }\n}\n\ninterface FeatureIdentifyRequestOptions {\n  /**\n   * WKT Polygon geometry\n   */\n  geom: string;\n  srs: 3857;\n  layers: number[];\n}\n\nconst d2r = Math.PI / 180; // degrees to radians\nconst r2d = 180 / Math.PI; // radians to degrees\nconst earthsradius = 3963; // 3963 is the radius of the earth in miles\n\nexport function getCirclePoly(\n  lng: number,\n  lat: number,\n  radius = 10,\n  points = 6\n) {\n  // find the radius in lat/lon\n  const rlat = (radius / earthsradius) * r2d;\n  const rlng = rlat / Math.cos(lat * d2r);\n\n  const extp = [];\n  for (let i = 0; i < points + 1; i++) {\n    // one extra here makes sure we connect the\n\n    const theta = Math.PI * (i / (points / 2));\n    const ex = lng + rlng * Math.cos(theta); // center a + radius x * cos(theta)\n    const ey = lat + rlat * Math.sin(theta); // center b + radius y * sin(theta)\n    extp.push([ex, ey]);\n  }\n\n  // add the circle to the map\n  return extp;\n}\n\nexport function degrees2meters(lng: number, lat: number): [number, number] {\n  const x = (lng * 20037508.34) / 180;\n  let y = Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);\n  y = (y * 20037508.34) / 180;\n  return [x, y];\n}\n\nexport function sendIdentifyRequest(\n  ev: MapClickEvent,\n  options: IdentifyRequestOptions\n  // webMap: WebMap\n): Promise<FeatureLayersIdentify> {\n  // webMap.emitter.emit('start-identify', { ev });\n  const geom = getCirclePoly(ev.latLng.lng, ev.latLng.lat, options.radius);\n\n  // create wkt string\n  const polygon: string[] = [];\n\n  // webMap.addLayer('GEOJSON', {\n  //   visibility: true,\n  //   data: {\n  //     type: 'Feature',\n  //     geometry: {\n  //       type: 'Polygon',\n  //       coordinates: [geom]\n  //     }\n  //   }\n  // })\n\n  geom.forEach(([lng, lat]) => {\n    const [x, y] = degrees2meters(lng, lat);\n    polygon.push(x + ' ' + y);\n  });\n\n  const wkt = `POLYGON((${polygon.join(', ')}))`;\n\n  const layers: number[] = options.layers;\n\n  const data: FeatureIdentifyRequestOptions = {\n    geom: wkt,\n    srs: 3857,\n    layers\n  };\n\n  return options.connector.post('feature_layer.identify', { data });\n}\n\ninterface ExtendWebMapLayerAdapterOptions {\n  webMap: WebMap;\n  connector: NgwConnector;\n  baseUrl?: string;\n}\n\nexport function extendWebMapLayerAdapter(\n  opt: ExtendWebMapLayerAdapterOptions\n): Type<WebMapLayerAdapter> {\n  class A extends WebMapLayerAdapter {\n    constructor(map: any, options: WebMapAdapterOptions) {\n      options = { ...opt, ...options };\n      super(map, options);\n    }\n  }\n  return A;\n}\n\nlet _pixelsInMeter: number;\n\nexport function pixelsInMeterWidth() {\n  if (_pixelsInMeter === undefined) {\n    const div = document.createElement('div');\n    div.style.cssText =\n      'position: absolute;  left: -100%;  top: -100%;  width: 100cm;';\n    document.body.appendChild(div);\n    const px = div.offsetWidth;\n    document.body.removeChild(div);\n    _pixelsInMeter = px;\n  }\n  return _pixelsInMeter;\n}\n\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        baseCtor.prototype,\n        name\n      );\n      if (descriptor) {\n        Object.defineProperty(derivedCtor.prototype, name, descriptor);\n      }\n    });\n  });\n}\n\n// Returns width of map in meters on specified latitude.\nexport function getMapWidthForLanInMeters(lat: number): number {\n  return 6378137 * 2 * Math.PI * Math.cos((lat * Math.PI) / 180);\n}\n\nexport function getZoomFromScale(scale: number) {\n  return Math.log(scale / 256) / Math.LN2;\n}\n\nexport function setScaleRatio(scale: number, lat = 104) {\n  // TODO: get real center\n  // webmap does not contain center yet\n  // const center = [104, 45]; // this.webMap.getCenter();\n  if (lat) {\n    const centerLat = lat;\n    const crsScale =\n      (pixelsInMeterWidth() * getMapWidthForLanInMeters(centerLat)) / scale;\n    const zoom = getZoomFromScale(crsScale);\n    return zoom;\n  }\n  return Math.round(Math.log(591657550.5 / (scale / 2)) / Math.log(2));\n}\n","import { LayerFeature } from '@nextgis/ngw-connector';\nimport { getNgwLayerFeature, createGeoJsonFeature } from './featureLayerUtils';\nimport { GetIdentifyGeoJsonOptions, NgwIdentify } from '../interfaces';\nimport { Geometry } from 'geojson';\n\nexport function getIdentifyGeoJsonParams(\n  identify: NgwIdentify,\n  multiple = false\n) {\n  let params: { resourceId: number; featureId: number } | undefined;\n  const resources = [];\n  const paramsList = [];\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      resources.push(id);\n    }\n  }\n  const sortingArr = identify.resources;\n  if (sortingArr) {\n    resources.sort(function(a, b) {\n      return sortingArr.indexOf(a) - sortingArr.indexOf(b);\n    });\n  }\n  for (let fry = 0; fry < resources.length; fry++) {\n    const l = resources[fry];\n    const layerFeatures = identify[l].features;\n    const resourceId = Number(l);\n    const f: LayerFeature | undefined = layerFeatures[0];\n    if (f) {\n      params = {\n        featureId: f.id,\n        resourceId\n      };\n      paramsList.push(params);\n      if (!multiple) {\n        break;\n      }\n    }\n  }\n  return paramsList;\n}\n\nexport function getIdentifyGeoJson(options: GetIdentifyGeoJsonOptions) {\n  const { connector, identify } = options;\n  for (const l in identify) {\n    const id = Number(l);\n    if (!isNaN(id)) {\n      const item = identify[l];\n      const withGeom = item.features.find(x => x.geom);\n\n      if (withGeom && withGeom.geom) {\n        const geom = withGeom.geom as Geometry;\n        return createGeoJsonFeature({\n          ...withGeom,\n          geom\n        });\n      }\n    }\n  }\n\n  const params = getIdentifyGeoJsonParams(identify);\n  if (params) {\n    return getNgwLayerFeature({ connector, ...params[0] });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport NgwConnector from '@nextgis/ngw-connector';\nimport WebMap, { StarterKit, Type } from '@nextgis/webmap';\nimport {\n  getNgwResourceExtent,\n  sendIdentifyRequest,\n  pixelsInMeterWidth,\n  updateWmsParams,\n  getLayerAdapterOptions,\n  addNgwLayer,\n  extendWebMapLayerAdapter,\n  setScaleRatio\n} from './utils/utils';\n\nimport {\n  getIdentifyGeoJson,\n  getIdentifyGeoJsonParams\n} from './utils/identifyUtils';\n\nimport {\n  getNgwLayerItems,\n  getNgwLayerItem,\n  getNgwLayerFeatures,\n  getNgwLayerFeature,\n  createGeoJsonFeature\n} from './utils/featureLayerUtils';\n\nimport { NgwKitOptions, WebMapAdapterOptions } from './interfaces';\nimport { WebMapLayerAdapter } from './WebMapLayerAdapter';\n\nexport class NgwKit implements StarterKit {\n  static utils = {\n    addNgwLayer,\n    getNgwResourceExtent,\n    sendIdentifyRequest,\n    pixelsInMeterWidth,\n    getNgwLayerFeature,\n    getNgwLayerFeatures,\n    getNgwLayerItems,\n    getNgwLayerItem,\n    getIdentifyGeoJson,\n    getIdentifyGeoJsonParams,\n    createGeoJsonFeature,\n    setScaleRatio\n  };\n\n  static updateWmsParams = updateWmsParams;\n\n  static getLayerAdapterOptions = getLayerAdapterOptions;\n\n  static addNgwLayer = addNgwLayer;\n\n  url: string;\n  connector: NgwConnector;\n  webMap?: WebMap;\n\n  constructor(public options: NgwKitOptions) {\n    if (this.options.connector) {\n      this.url = this.options.connector.options.baseUrl;\n      this.connector = this.options.connector;\n    } else {\n      if (this.options.baseUrl) {\n        this.url = this.options.baseUrl;\n      } else {\n        throw new Error('url is not defined');\n      }\n      this.connector = new NgwConnector({\n        baseUrl: this.url,\n        auth: this.options.auth\n      });\n    }\n  }\n\n  async onLoadSync(webMap: WebMap) {\n    if (this.options.resourceId && this.url) {\n      // TODO: resources from array\n      const resourceIds = [this.options.resourceId];\n\n      if (resourceIds.length) {\n        for (const r of resourceIds) {\n          const options: WebMapAdapterOptions = {\n            resourceId: r,\n            connector: this.connector,\n            baseUrl: this.url,\n            webMap\n          };\n          const layer = (await webMap.addLayer(WebMapLayerAdapter, {\n            visibility: true,\n            fit: true,\n            identification: this.options.identification,\n            pixelRadius: this.options.pixelRadius,\n            ...options\n          })) as WebMapLayerAdapter;\n          return layer;\n        }\n      }\n    }\n  }\n\n  getLayerAdapters() {\n    return Promise.resolve([this._getLayerAdapter()]);\n  }\n\n  private _getLayerAdapter() {\n    return {\n      name: 'WEBMAP',\n      createAdapter: (webmap: WebMap) =>\n        Promise.resolve(this._createAdapter(webmap))\n    };\n  }\n\n  private _createAdapter(webMap: WebMap): Type<WebMapLayerAdapter> {\n    const connector = this.connector;\n    const baseUrl = this.url;\n    return extendWebMapLayerAdapter({\n      webMap,\n      connector,\n      baseUrl\n    });\n  }\n}\n","/**\n * @module ngw-kit\n */\n\nimport { NgwKit } from './NgwKit';\n\nexport * from './interfaces';\nexport * from './WebMapLayerAdapter';\nexport * from './WebMapLayerItem';\n\nexport { NgwKit };\nexport default NgwKit;\n","// readyState\n// Holds the status of the XMLHttpRequest.\n// 0: request not initialized\n// 1: server connection established\n// 2: request received\n// 3: processing request\n// 4: request finished and response is ready\n\n// status\n// 200: \"OK\"\n// 201 \"Created\"\tThe request has been fulfilled, and a new resource is created\n// 403: \"Forbidden\"\n// 404: \"Page not found\"\n// 500: \"Internal Server Error\"\n// For a complete list go to the Http Messages Reference\n\nimport { RequestOptions } from './interfaces';\n\nexport function loadJSON(\n  url: string,\n  callback: (...args: any[]) => any,\n  options: RequestOptions = {},\n  error: (reason?: any) => void,\n  onCancel: (() => void)[]\n) {\n  options.method = options.method || 'GET';\n\n  const xhr = new XMLHttpRequest();\n  xhr.open(options.method || 'GET', url, true); // true for asynchronous\n\n  if (options.responseType === 'blob') {\n    xhr.responseType = options.responseType;\n  }\n\n  const processingResponce = (forError = false) => {\n    const cb = forError ? error : callback;\n    if (options.responseType === 'blob') {\n      cb(xhr.response);\n    } else {\n      if (xhr.responseText) {\n        try {\n          cb(JSON.parse(xhr.responseText));\n        } catch (er) {\n          cb(xhr.responseText);\n        }\n      } else {\n        error({ message: '' });\n      }\n    }\n  };\n\n  xhr.onreadystatechange = () => {\n    if (\n      (xhr.readyState === 4 && xhr.status === 200) ||\n      (xhr.readyState === 3 && xhr.status === 201)\n    ) {\n      processingResponce();\n    } else if (xhr.readyState === 3 && xhr.status === 400) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 500) {\n      processingResponce();\n    } else if (xhr.readyState === 4 && xhr.status === 401) {\n      error(xhr.statusText);\n    } else if (xhr.readyState === 4) {\n      error('request error');\n    }\n  };\n\n  xhr.onerror = er => {\n    error(er);\n  };\n\n  xhr.upload.onprogress = function(e) {\n    if (e.lengthComputable) {\n      const percentComplete = (e.loaded / e.total) * 100;\n      if (options.onProgress) {\n        options.onProgress(percentComplete);\n      }\n      // console.log(percentComplete + '% uploaded');\n    }\n  };\n\n  const headers = options.headers;\n  if (headers) {\n    for (const h in headers) {\n      const header = headers[h];\n      if (typeof header === 'string') {\n        xhr.setRequestHeader(h, header);\n      }\n    }\n  }\n  if (options.withCredentials !== undefined) {\n    xhr.withCredentials = options.withCredentials;\n  }\n\n  let data: FormData | any;\n  if (options.file) {\n    data = new FormData();\n    data.append('file', options.file);\n    if (options.data) {\n      for (const d in data) {\n        data.append(d, data[d]);\n      }\n    }\n  } else {\n    data = options.data\n      ? typeof options.data === 'string'\n        ? options.data\n        : JSON.stringify(options.data)\n      : null;\n  }\n  if (onCancel) {\n    onCancel.push(() => {\n      xhr.abort();\n    });\n  }\n  xhr.send(data);\n}\n\n// https://github.com/Leaflet/Leaflet/blob/b507e21c510b53cd704fb8d3f89bb46ea925c8eb/src/core/Util.js#L165\nconst templateRe = /\\{ *([\\w_-]+) *\\}/g;\n\nexport function template(str: string, data: { [param: string]: any }) {\n  return str.replace(templateRe, (s, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      throw new Error('No value provided for letiable ' + s);\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n    return value;\n  });\n}\n","/**\n * @module ngw-connector\n */\nimport { CancelablePromise } from '@nextgis/utils';\nimport { EventEmitter } from 'events';\n\nimport { RequestItemsParamsMap } from './types/RequestItemsParamsMap';\nimport {\n  NgwConnectorOptions,\n  Router,\n  GetRequestItemsResponseMap,\n  RequestOptions,\n  Params,\n  LoadingQueue,\n  UserInfo,\n  Credentials,\n  PyramidRoute,\n  RequestHeaders,\n  PostRequestItemsResponseMap,\n  PatchRequestItemsResponseMap,\n  RequestItemKeys,\n  DeleteRequestItemsResponseMap,\n  PutRequestItemsResponseMap,\n  RequestItemsParams\n} from './interfaces';\nimport { loadJSON, template } from './utils';\nimport { ResourceItem } from './types/ResourceItem';\n\nexport class NgwConnector {\n  emitter = new EventEmitter();\n  user?: UserInfo;\n  private routeStr = '/api/component/pyramid/route';\n  private route?: PyramidRoute;\n  private _loadingQueue: { [name: string]: LoadingQueue } = {};\n  private _loadingStatus: { [url: string]: boolean } = {};\n  private _keynames: Record<string, ResourceItem> = {};\n\n  constructor(public options: NgwConnectorOptions) {\n    if (this.options.route) {\n      this.routeStr = this.options.route;\n    }\n  }\n\n  setNextGisWeb(url: string) {\n    this.logout();\n    this.options.baseUrl = url;\n  }\n\n  async connect(): CancelablePromise<Router> {\n    if (this.route) {\n      return Promise.resolve(this.route);\n    } else {\n      if (this.options.auth) {\n        const { login, password } = this.options.auth;\n        if (login && password) {\n          await this.getUserInfo({ login, password });\n        }\n      }\n\n      return await this.makeQuery(this.routeStr, {}, {}).then(\n        (route: PyramidRoute) => {\n          this.route = route;\n          return route;\n        }\n      );\n    }\n  }\n\n  async login(credentials: Credentials) {\n    this.logout();\n    return this.getUserInfo(credentials);\n  }\n\n  logout() {\n    this._rejectLoadingQueue();\n    this._loadingStatus = {};\n    this.options.auth = undefined;\n    this.route = undefined;\n    this.user = undefined;\n    this.emitter.emit('logout');\n  }\n\n  getUserInfo(credentials: Credentials): CancelablePromise<UserInfo> {\n    if (this.user && this.user.id) {\n      return CancelablePromise.resolve(this.user);\n    }\n    if (credentials) {\n      this.options.auth = credentials;\n    }\n    const options: RequestOptions = {\n      headers: this.getAuthorizationHeaders(credentials)\n      // withCredentials: true\n    };\n\n    // Do not use request('auth.current_user') to avoid circular-references\n    return this.makeQuery('/api/component/auth/current_user', {}, options)\n      .then((data: UserInfo) => {\n        this.user = data;\n        this.emitter.emit('login', data);\n        return data;\n      })\n      .catch(er => {\n        this.emitter.emit('login:error', er);\n        throw er;\n      });\n  }\n\n  getAuthorizationHeaders(\n    credentials?: Credentials\n  ): RequestHeaders | undefined {\n    const client = this.makeClientId(credentials);\n    if (client) {\n      return {\n        Authorization: 'Basic ' + client\n      };\n    }\n  }\n\n  makeClientId(credentials?: Credentials) {\n    credentials = credentials || this.options.auth;\n    if (credentials) {\n      const { login, password } = credentials;\n      return window.btoa(unescape(encodeURIComponent(`${login}:${password}`)));\n    }\n  }\n\n  async getResourceByKeyname(keyname: string) {\n    let resource: ResourceItem = this._keynames['keyname'];\n    if (!resource) {\n      const resources = await this.get('resource.search', null, { keyname });\n      resource = resources[0];\n      if (resource) {\n        this._keynames[keyname] = resource;\n      }\n    }\n    return resource;\n  }\n\n  async getResourceChildren(opt: {\n    keyname?: string;\n    resourceId?: number;\n  }): Promise<ResourceItem[]> {\n    let parent = opt.resourceId;\n    if (!opt.keyname && !opt.resourceId) {\n      throw new Error('No keyname or resourceId is set');\n    }\n    if (opt.keyname) {\n      const item = await this.getResourceByKeyname(opt.keyname);\n      parent = item.resource.id;\n    }\n    return await this.get('resource.collection', null, {\n      parent\n    });\n  }\n\n  async request<\n    K extends keyof RequestItemsParamsMap,\n    P extends RequestItemKeys = RequestItemKeys\n  >(\n    name: K,\n    params: RequestItemsParams<K> = {},\n    options?: RequestOptions\n  ): CancelablePromise<P[K]> {\n    const apiItems = await this.connect();\n    let apiItem = apiItems && apiItems[name];\n    if (apiItem) {\n      apiItem = [...apiItem];\n      let url = apiItem.shift();\n      if (apiItem.length) {\n        const replaceParams: {\n          [num: number]: string;\n        } = {};\n        for (let fry = 0; fry < apiItem.length; fry++) {\n          const arg = apiItem[fry];\n          replaceParams[fry] = '{' + arg + '}';\n          if (params[arg] === undefined) {\n            throw new Error(\n              '`' + arg + '`' + ' url api argument is not specified'\n            );\n          }\n        }\n        if (url) {\n          url = template(url, replaceParams);\n        }\n      }\n      // Transfer part of the parameters from `params` to the URL string\n      if (params) {\n        const paramArray = [];\n        const paramList = params.paramList;\n        if (Array.isArray(paramList)) {\n          delete params.paramList;\n          paramList.forEach(x => {\n            paramArray.push(`${x[0]}=${x[1]}`);\n          });\n        }\n        for (const p in params) {\n          if (apiItem.indexOf(p) === -1) {\n            paramArray.push(`${p}=${params[p]}`);\n          }\n        }\n        if (paramArray.length) {\n          url = url + '?' + paramArray.join('&');\n        }\n      }\n      if (url) {\n        return this.makeQuery(url, params, options);\n      } else {\n        throw new Error('request url is not set');\n      }\n    }\n    return CancelablePromise.resolve({} as P[K]);\n  }\n\n  post<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions<'POST'>,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PostRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'POST';\n    options.nocache = true;\n    return this.request<K, PostRequestItemsResponseMap>(name, params, options);\n  }\n\n  get<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<GetRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'GET';\n    options.nocache = true;\n    return this.request<K, GetRequestItemsResponseMap>(name, params, options);\n  }\n\n  patch<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PatchRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PATCH';\n    options.nocache = true;\n    return this.request<K, PatchRequestItemsResponseMap>(name, params, options);\n  }\n\n  put<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<PutRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'PUT';\n    options.nocache = true;\n    return this.request<K, PutRequestItemsResponseMap>(name, params, options);\n  }\n\n  delete<K extends keyof RequestItemsParamsMap>(\n    name: K,\n    options?: RequestOptions | undefined | null,\n    params?: RequestItemsParams<K>\n  ): CancelablePromise<DeleteRequestItemsResponseMap[K]> {\n    options = options || {};\n    options.method = 'DELETE';\n    options.nocache = true;\n    return this.request<K, DeleteRequestItemsResponseMap>(\n      name,\n      params,\n      options\n    );\n  }\n\n  makeQuery(\n    url: string,\n    params?: Params,\n    options: RequestOptions = {}\n  ): CancelablePromise<any> {\n    url = (this.options.baseUrl ? this.options.baseUrl : '') + url;\n    if (url) {\n      if (params) {\n        url = template(url, params);\n      }\n      // remove double slash\n      url = url.replace(/([^:]\\/)\\/+/g, '$1');\n      if (!this._loadingStatus[url] || options.nocache) {\n        this._loadingStatus[url] = true;\n\n        return this._getJson(url, options)\n          .then(data => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, data);\n            return data;\n          })\n          .catch(er => {\n            this._loadingStatus[url] = false;\n            this._executeLoadingQueue(url, er, true);\n            this.emitter.emit('error', er);\n            throw er;\n          });\n      } else {\n        this._loadingStatus[url] = false;\n        return new CancelablePromise((resolve, reject) => {\n          this._setLoadingQueue(url, resolve, reject);\n        });\n      }\n    } else {\n      throw new Error('No `url` parameter set for option ' + name);\n    }\n  }\n\n  _setLoadingQueue(\n    name: string,\n    resolve: (...args: any[]) => any,\n    reject: (...args: any[]) => any\n  ) {\n    this._loadingQueue[name] = this._loadingQueue[name] || {\n      name,\n      waiting: []\n    };\n    this._loadingQueue[name].waiting.push({\n      resolve,\n      reject,\n      timestamp: new Date()\n    });\n  }\n\n  _rejectLoadingQueue() {\n    for (const q in this._loadingQueue) {\n      const queue = this._loadingQueue[q];\n      queue.waiting.forEach(x => {\n        x.reject();\n      });\n      delete this._loadingQueue[q];\n    }\n  }\n\n  _executeLoadingQueue(name: string, data: any, isError?: boolean) {\n    const queue = this._loadingQueue[name];\n    if (queue) {\n      for (let fry = 0; fry < queue.waiting.length; fry++) {\n        const wait = queue.waiting[fry];\n        if (isError) {\n          if (wait.reject) {\n            wait.reject();\n          }\n        } else {\n          wait.resolve(data);\n        }\n      }\n      queue.waiting = [];\n    }\n  }\n\n  _getJson(url: string, options: RequestOptions): CancelablePromise<any> {\n    const onCancel: (() => void)[] = [];\n    options.responseType = options.responseType || 'json';\n    return new CancelablePromise(\n      (resolve, reject) => {\n        if (this.user) {\n          options = options || {};\n          // options.withCredentials = true;\n          options.headers = {\n            ...this.getAuthorizationHeaders(),\n            ...options.headers\n          };\n        }\n        loadJSON(url, resolve, options, reject, onCancel);\n      },\n      () => {\n        onCancel.forEach(x => x());\n      }\n    );\n  }\n}\n","/**\n * @module ngw-connector\n */\n\nimport { NgwConnector } from './NgwConnector';\n\nexport * from './interfaces';\nexport * from './types/ResourceItem';\nexport * from './types/FeatureLayer';\nexport * from './types/RequestItemsParamsMap';\nexport * from './types/ResourceStore';\n\n// for backward compatibility\n// TODO: safe remove backward compatibility\nimport { CancelablePromise } from '@nextgis/utils';\nexport { CancelablePromise };\n\nexport { NgwConnector };\nexport default NgwConnector;\n"],"sourceRoot":""}